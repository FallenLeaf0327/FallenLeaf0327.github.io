[{"title":"CodeForces 1114C","url":"/posts/17917da1/","content":"VJudge  CodeForcces\n算法\n\n数学（质因数分解，因数个数，进制）\n\n\n思路\n根据进制的知识，对于 kkk 进制而言，只有当 n mod ki=0n \\bmod k^{i} = 0nmodki=0 时，kkk 进制意义下的第 iii 位才会为零。\n由于 k≤1012k \\le 10^{12}k≤1012，所以直接进行除法操作肯定不行，考虑将 kkk 质因数分解，对于 kkk 的每一个质因数分别考虑。设 k=∏i=0spiαIk = \\prod_{i = 0}^{s} p_{i}^{\\alpha_{I}}k=∏i=0s​piαI​​，n!=∏i=0spiβin! = \\prod_{i = 0}^{s} p_{i}^{\\beta_i}n!=∏i=0s​piβi​​。则 n!n!n! 在 kkk 进制下末尾 000 的个数为 min⁡i=0s⌊βiαi⌋\\min_{i=0}^{s} \\lfloor \\frac{\\beta_i}{\\alpha_i} \\rfloormini=0s​⌊αi​βi​​⌋ 。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;long long divide[N][2];int cnt = 0;inline long long cal(long long a, long long b) &#123;  if (a &lt; b) return 0;  else return a / b + cal(a / b, b);&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);    cout.tie(nullptr);    long long n, k;  cin &gt;&gt; n &gt;&gt; k;    long long answer = 1ll &lt;&lt; 62;    // ! 注意枚举上界为 sqrt(k) 而不是 k  for (long long i = 2; i * i &lt;= k; i ++) &#123;    if (k % i == 0) &#123;      long long alpha = 0;      while (k % i == 0) &#123;        k /= i;        alpha ++;      &#125;            divide[++ cnt][0] = i;      divide[cnt][1] = alpha;    &#125;  &#125;    if (k &gt; 1) &#123;    divide[++ cnt][0] = k;    divide[cnt][1] = 1;  &#125;    for (int i = 1; i &lt;= cnt; i++) &#123;    long long p = divide[i][0], alpha = divide[i][1], beta = cal(n, p);    answer = min(answer, beta / alpha);  &#125;    cout &lt;&lt; answer &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;","categories":["Solution"],"tags":["CodeForces","Math"]},{"title":"CodeForces 1192B","url":"/posts/38dfbb09/","content":"VJudge    CodeForces\n算法\n\n欧拉序\n线段树\n\n\n思路\n对于这道题考虑使用欧拉序的性质：\n\n对于树上的每一个子树，在欧拉序上都有一个区间与之对应。\n对于 (u,v)(u, v)(u,v) 的最近公共祖先，在欧拉序上表现为区间 [posu,posv][pos_u, pos_v][posu​,posv​] 内深度最浅的节点。\n\n所以可以将原树转化为欧拉序，将树上问题转化为序列上的区间问题，就可以使用线段树解决。\n由于题目要求树的直径，所以用线段树查找区间最值，找到点 (u,v)(u, v)(u,v) 的最近公共祖先 lcalcalca，则 dist(u,v)dist(u, v)dist(u,v) 可以表示为：\ndist(u,v)=depu+depv−2⋅deplca\\large\ndist(u,v) = dep_u + dep_v - 2 \\cdot dep_{lca}\ndist(u,v)=depu​+depv​−2⋅deplca​\n而直径就是 max⁡{dist(u,v)}\\max\\{dist(u, v)\\}max{dist(u,v)}。\n所以原题目的问题就转化为：在欧拉序上找一个三元组 (u,lca,v)(u, lca, v)(u,lca,v)，满足如下条件：\n\ndepu+depv−2⋅deplcadep_u + dep_v - 2 \\cdot dep_{lca}depu​+depv​−2⋅deplca​ 最大。\nlcalcalca 为区间 [posu,posv][pos_u, pos_v][posu​,posv​] 内深度最小的节点。\n\n而第二个条件可以由第一个条件限制，所以可以忽略。\n由上面两个限制条件我们可以得到线段树需要维护的数据：\n\nmaxmaxmax：区间最大值。\nminminmin：区间最小值。\nleft midleft\\ midleft mid（以下简称 LMLMLM）：三元组 (u,lca,v)(u, lca, v)(u,lca,v) 中 depu−2⋅deplcadep_u - 2 \\cdot dep_{lca}depu​−2⋅deplca​ 的最大值。\nmid rightmid\\ rightmid right（以下简称 RMRMRM）：三元组 (u,lca,v)(u, lca, v)(u,lca,v) 中 depv−2⋅deplcadep_v - 2 \\cdot dep_{lca}depv​−2⋅deplca​ 的最大值。\nleft mid rightleft\\ mid\\ rightleft mid right（以下简称 LMRLMRLMR）：三元组 (u,lca,v)(u, lca, v)(u,lca,v) 中 depu+depv−2⋅deplcadep_u + dep_v - 2 \\cdot dep_{lca}depu​+depv​−2⋅deplca​ 的最大值。\n\n接下来考虑如何转移 （即为 push_up(int k) 函数）。\n对于 maxmaxmax 和 minminmin 来说转移很简单，即为：\nmaxk=max⁡(maxlc,maxrc)mink=min⁡(minlc,minrc)\\large\n\\begin{aligned}\nmax_k &amp;= \\max(max_{lc}, max_{rc}) \\\\\nmin_k &amp;= \\min(min_{lc}, min_{rc}) \\\\\n\\end{aligned}\nmaxk​mink​​=max(maxlc​,maxrc​)=min(minlc​,minrc​)​\n而对于 LMLMLM 而言，可以从三个方向转移：\nLM=max⁡(LMlc,LMrc,maxlc−2⋅minrc)\\large\nLM = \\max(LM_{lc}, LM_{rc}, max_{lc} - 2 \\cdot min_{rc})\nLM=max(LMlc​,LMrc​,maxlc​−2⋅minrc​)\n对于 MRMRMR 同理由：\nMR=max⁡(MRlc,MRrc,−2⋅minlc+maxrc)\\large\nMR = \\max(MR_{lc}, MR_{rc}, -2 \\cdot min_{lc} + max_{rc}) \nMR=max(MRlc​,MRrc​,−2⋅minlc​+maxrc​)\n最后合并成 LMRLMRLMR：\nLMR=max⁡(LMRlc,LMRrc,LMlc+maxrc,maxlc+MRrc)\\large\nLMR = \\max(LMR_{lc}, LMR_{rc}, LM_{lc} + max_{rc}, max_{lc} + MR_{rc})\nLMR=max(LMRlc​,LMRrc​,LMlc​+maxrc​,maxlc​+MRrc​)\n代码\n#include &lt;bits/stdc++.h&gt;#define OnlineJudgeconstexpr int N = 1e5 + 5;std::vector&lt;int&gt; euler_seq&#123;-1&#125;;int in[N], out[N], num = 0;int head[N], cnt = 0;int n, q, u, v, fa[N];long long W, d, w, last = 0ll, dist[N];std::vector&lt;std::tuple&lt;int, int, long long&gt;&gt; input_edges;class Edge &#123; public:  int to, next;  long long w;&#125; edges[N &lt;&lt; 4];void add_edge(int u, int v, long long w) &#123;  edges[cnt].to = v;  edges[cnt].w = w;  edges[cnt].next = head[u];  head[u] = cnt++;&#125;class SegmentTree &#123; private:  class Values &#123;    public:    // ! 对 lazy 要初始化（虽然在 build 里面写了，但不知道为什么有些还是没有初始化）    long long max = 0, min = 0, left_mid = 0, mid_right = 0, left_mid_right = 0, lazy = 0;  &#125;;   class NodeInfo &#123;   public:    int left = 0, right = 0;    Values val;  &#125;;    public:  NodeInfo tr[N &lt;&lt; 2];    Values merge_tags(Values a, Values b) &#123;    Values retval;        retval.max = std::max(a.max, b.max);    retval.min = std::min(a.min, b.min);    retval.left_mid = std::max(&#123;a.left_mid, b.left_mid, a.max + -2 * b.min&#125;);    retval.mid_right = std::max(&#123;a.mid_right, b.mid_right, -2 * a.min + b.max&#125;);    retval.left_mid_right = std::max(&#123;a.left_mid_right, b.left_mid_right, a.left_mid + b.max, a.max + b.mid_right&#125;);        return retval;  &#125;    void modify_tags(Values&amp; root, long long value) &#123;    root.lazy += value;    root.max += value;    root.min += value;    root.left_mid -= value;    root.mid_right -= value;  &#125;    void push_up(int k) &#123;    Values lc = tr[k &lt;&lt; 1].val, rc = tr[k &lt;&lt; 1 | 1].val;        int temp = tr[k].val.lazy;    tr[k].val = merge_tags(lc, rc);    tr[k].val.lazy = temp;  &#125;    void push_down(int k) &#123;    if (tr[k].val.lazy == 0) &#123;      return void();    &#125;        modify_tags(tr[k &lt;&lt; 1].val, tr[k].val.lazy);    modify_tags(tr[k &lt;&lt; 1 | 1].val, tr[k].val.lazy);        tr[k].val.lazy = 0;  &#125;    void build_tree(int k, int l, int r) &#123;    tr[k].left = l;    tr[k].right = r;    tr[k].val.lazy = 0;        if (tr[k].left == tr[k].right) &#123;      tr[k].val.max = tr[k].val.min = dist[euler_seq[l]];      tr[k].val.left_mid = tr[k].val.mid_right = -dist[euler_seq[l]];      tr[k].val.left_mid_right = 0;            #ifndef OnlineJudge      std::cout &lt;&lt; &quot;BUILD:\\n&quot;;      std::cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; tr[k].left &lt;&lt; &quot; &quot; &lt;&lt; tr[k].right &lt;&lt; &quot; &quot;;      std::cout &lt;&lt; tr[k].val.max &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.min &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.left_mid &lt;&lt; &quot; &quot;;      std::cout &lt;&lt; tr[k].val.mid_right &lt;&lt; &#x27; &#x27; &lt;&lt; tr[k].val.left_mid_right &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.lazy &lt;&lt; &#x27;\\n&#x27;;      #endif            return void();    &#125;        int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        build_tree(lc, l, mid);    build_tree(rc, mid + 1, r);        push_up(k);        #ifndef OnlineJudge    std::cout &lt;&lt; &quot;BUILD:\\n&quot;;    std::cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; tr[k].left &lt;&lt; &quot; &quot; &lt;&lt; tr[k].right &lt;&lt; &quot; &quot;;    std::cout &lt;&lt; tr[k].val.max &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.min &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.left_mid &lt;&lt; &quot; &quot;;    std::cout &lt;&lt; tr[k].val.mid_right &lt;&lt; &#x27; &#x27; &lt;&lt; tr[k].val.left_mid_right &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.lazy &lt;&lt; &#x27;\\n&#x27;;    #endif  &#125;    void modify(int k, int l, int r, long long value) &#123;    #ifndef OnlineJudge    std::cout &lt;&lt; &quot;MODIFY:\\n&quot;;    std::cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; tr[k].left &lt;&lt; &quot; &quot; &lt;&lt; tr[k].right &lt;&lt; &quot; &quot;;    std::cout &lt;&lt; tr[k].val.max &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.min &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.left_mid &lt;&lt; &quot; &quot;;    std::cout &lt;&lt; tr[k].val.mid_right &lt;&lt; &#x27; &#x27; &lt;&lt; tr[k].val.left_mid_right &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.lazy &lt;&lt; &#x27;\\n&#x27;;    #endif        if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;      modify_tags(tr[k].val, value);      return void();    &#125;        push_down(k);        int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        if (r &lt;= mid) &#123;      modify(lc, l, r, value);    &#125; else if (l &gt; mid) &#123;      modify(rc, l, r, value);    &#125; else &#123;      modify(lc, l, mid, value);      modify(rc, mid + 1, r, value);    &#125;        push_up(k);  &#125;    Values query(int k, int l, int r) &#123;    #ifndef OnlineJudge    std::cout &lt;&lt; &quot;QUERY:\\n&quot;;    std::cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; tr[k].left &lt;&lt; &quot; &quot; &lt;&lt; tr[k].right &lt;&lt; &quot; &quot;;    std::cout &lt;&lt; tr[k].val.max &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.min &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.left_mid &lt;&lt; &quot; &quot;;    std::cout &lt;&lt; tr[k].val.mid_right &lt;&lt; &#x27; &#x27; &lt;&lt; tr[k].val.left_mid_right &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.lazy &lt;&lt; &#x27;\\n&#x27;;    #endif        if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;      return tr[k].val;    &#125;        push_down(k);        int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        if (r &lt;= mid) &#123;      return query(lc, l, r);    &#125; else if (l &gt; mid) &#123;      return query(rc, l, r);    &#125; else &#123;      return merge_tags(query(lc, l, mid), query(rc, mid + 1, r));    &#125;  &#125;&#125; data;void dfs(int u, int father) &#123;  euler_seq.emplace_back(u);  in[u] = euler_seq.size() - 1;    for (int i = head[u]; ~i; i = edges[i].next) &#123;    int v = edges[i].to;    if (v == father) continue;    fa[v] = u;    dist[v] = dist[u] + edges[i].w;    dfs(v, u);    euler_seq.emplace_back(u);  &#125;    out[u] = euler_seq.size() - 1;&#125;int main() &#123;  std::ios::sync_with_stdio(false);  std::cin.tie(nullptr);  std::cout.tie(nullptr);    std::memset(head, -1, sizeof(head));    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; W;    for (int i = 1; i &lt; n; i ++) &#123;    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        add_edge(u, v, w);    add_edge(v, u, w);    input_edges.emplace_back(u, v, w);  &#125;    dfs(1, 1);    // ! 注意调换顺序，保证前面一个点是后面一个点的父亲  for (int i = 0; i &lt; n - 1; i ++) &#123;    if (fa[std::get&lt;0&gt;(input_edges[i])] == std::get&lt;1&gt;(input_edges[i])) &#123;      std::swap(std::get&lt;0&gt;(input_edges[i]), std::get&lt;1&gt;(input_edges[i]));    &#125;  &#125;    data.build_tree(1, 1, euler_seq.size() - 1);    #ifndef OnlineJudge  std::cout &lt;&lt; data.query(1, 1, euler_seq.size() - 1).left_mid_right &lt;&lt; &#x27;\\n&#x27;;  for (auto&amp;&amp; [u, v, w] : input_edges) &#123;    std::cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; v &lt;&lt; &#x27; &#x27; &lt;&lt; w &lt;&lt; &#x27;\\n&#x27;;  &#125;  #endif    last = 0;  for (int i = 1; i &lt;= q; i ++) &#123;    std::cin &gt;&gt; d &gt;&gt; w;    d = (d + last) % (n - 1);    w = (w + last) % W;        // ! 对于边 (u, v, w)，满足 fa[v] == u，则修改后的 w&#x27; 只对 v 的子树有影响，所以只更新 v 的子树即可。    data.modify(1, in[std::get&lt;1&gt;(input_edges[d])], out[std::get&lt;1&gt;(input_edges[d])], w - std::get&lt;2&gt;(input_edges[d]));    // ! 记得将边的信息更新    std::get&lt;2&gt;(input_edges[d]) = w;    last = data.query(1, 1, euler_seq.size() - 1).left_mid_right;        std::cout &lt;&lt; last &lt;&lt; &#x27;\\n&#x27;;  &#125;    return 0;&#125;\n","categories":["Solution"],"tags":["CodeForces","欧拉序","SegmentTree"]},{"title":"Luogu P2831","url":"/posts/aa4147b6/","content":"Luogu\n算法\n\n搜索\n\n\n思路\n由于 n≤18n \\le 18n≤18，可以考虑搜索。\n定义 dfs(cur,a,b)dfs(cur, a, b)dfs(cur,a,b) 表示搜索到了第 curcurcur 头猪，使用了 aaa 条抛物线，前面还有 bbb 头猪为被击中。\n对于一条抛物线 y=ax2+bx+cy=ax^{2}+bx+cy=ax2+bx+c，需要三个点确定其解析式。由于题目钦定了抛物线必定经过 (0,0)(0,0)(0,0)，所以还需要两个点。在前面为被击中的 bbb 头猪中选择一头与第 curcurcur 头猪配对。假设两头猪的坐标为 (x1,y1),(x2,y2)(x_{1}, y_{1}), (x_{2},y_{2})(x1​,y1​),(x2​,y2​)。则\n{ax12+bx1=y1ax22+bx2=y2→{a=(y1x2−y2x1)x12x2−x1x22b=y1−x12ax1\\begin{cases}\na x_{1}^{2} + b x_{1} = y_{1} \\\\\na x_{2}^{2} + b x_{2} = y_{2} \\\\\n\\end{cases}\n\\to\n\\begin{cases}\na = \\frac{(y_{1} x_{2} - y_{2} x_{1})}{x_{1}^{2} x_{2} - x_{1} x_{2}^{2}} \\\\\nb = \\frac{y_{1} - x_{1}^{2} a}{x_{1}} \\\\\n\\end{cases}\n{ax12​+bx1​=y1​ax22​+bx2​=y2​​→{a=x12​x2​−x1​x22​(y1​x2​−y2​x1​)​b=x1​y1​−x12​a​​\n于是就可以得到这两头猪配对的抛物线解析式。\n然后进行剪枝。如果由于前面未配对的猪必须要有一条单独的抛物线经过，所以有最优性剪枝： a+b&gt;answera + b &gt; answera+b&gt;answer 时 return。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 25;constexpr double EPS = 1e-9;pair&lt;double, double&gt; pig[N], line[N], unused[N];int test_case, n, m, answer;bool equal(double a, double b) &#123;  return fabs(a - b) &lt; EPS;&#125;void dfs(int cur, int a, int b) &#123;  if (a + b &gt;= answer) &#123;    return void();  &#125; else if (cur &gt; n) &#123;    answer = min(answer, a + b);    return void();  &#125;    double x = pig[cur].first, y = pig[cur].second;    bool crossed = false;  for (int i = 1; i &lt;= a; i++) &#123;    if (equal(line[i].first * x * x + line[i].second * x, y) == true) &#123;      crossed = true;      break;    &#125;  &#125;    if (crossed == true) &#123;    dfs(cur + 1, a, b);  &#125; else &#123;    for (int i = 1; i &lt;= b; i++) &#123;      double tx = unused[i].first, ty = unused[i].second;            if (equal(x, tx) == true) &#123;        continue;      &#125;            double pa = (y * tx - ty * x) / (x * x * tx - tx * tx * x);      double pb = (y - x * x * pa) / x;            if (pa &gt;= 0) &#123;        continue;      &#125;            line[a + 1] = make_pair(pa, pb);            pair&lt;double, double&gt; tmp = unused[i];      for (int j = i; j &lt;= b - 1; j++) &#123;        unused[j] = unused[j + 1];      &#125;            dfs(cur + 1, a + 1, b - 1);            for (int j = b; j &gt; i; j--) &#123;        unused[j] = unused[j - 1];      &#125;            unused[i] = tmp;    &#125;        unused[b + 1] = pig[cur];    dfs(cur + 1, a, b + 1);  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);    cin &gt;&gt; test_case;    while (test_case --) &#123;    cin &gt;&gt; n &gt;&gt; m;        for (int i = 1; i &lt;= n; i++) &#123;      cin &gt;&gt; pig[i].first &gt;&gt; pig[i].second;    &#125;        answer = 100000;    dfs(1, 0, 0);        cout &lt;&lt; answer &lt;&lt; &quot;\\n&quot;;  &#125;    return 0;&#125;","categories":["Solution"],"tags":["Luogu","搜索"]},{"title":"Luogu P1445","url":"/posts/f9c243e2/","content":"Luogu\n算法\n\n数学（素数筛，因子个数）\n\n\n思路\n对于原式做如下推导：\n1x+1y=1n!x+yxy=1n!n!⋅(x+y)=xyn!⋅x+n!⋅y−xy=0xy−n!⋅x−n!⋅y=0\\large\n\\begin{aligned}\n\\frac{1}{x} + \\frac{1}{y} &amp;= \\frac{1}{n!} \\\\\n\\frac{x + y}{xy} &amp;= \\frac{1}{n!} \\\\\nn! \\cdot (x + y) &amp;= xy \\\\\nn! \\cdot x + n! \\cdot y - xy &amp;= 0 \\\\\nxy - n! \\cdot x - n! \\cdot y &amp;= 0\n\\end{aligned}\nx1​+y1​xyx+y​n!⋅(x+y)n!⋅x+n!⋅y−xyxy−n!⋅x−n!⋅y​=n!1​=n!1​=xy=0=0​\n由上式联想到：\n(a−x)(b−x)→ab−ax−bx−X2\\large\n(a - x) (b - x) \\to ab - ax - bx - X^2\n(a−x)(b−x)→ab−ax−bx−X2\n比较两式，发现缺少 (n!)2(n!)^2(n!)2 项。加上 (n!)2(n!)^2(n!)2，得：\n(x−n!)(y−n!)=(n!)2\\large\n\\begin{aligned}\n(x - n!)(y - n!) = (n!)^2\n\\end{aligned}\n(x−n!)(y−n!)=(n!)2​\n由于等式左边是乘积的形式，所以 (x−n!)(x - n!)(x−n!) 和 (y−n!)(y - n!)(y−n!) 必定是 (n!)2(n!)^2(n!)2 的一对因子。\n将 nnn 质因数分解：\nn=∏i=0kpiαi\\large\nn = \\prod_{i = 0}^{k} p_i^{\\alpha_{i}}\nn=i=0∏k​piαi​​\n对于 n!n!n! 的因子个数 sum1sum_{1}sum1​ 有：\nsum1=∏i=0k(αi+1)sum_{1} = \\prod_{i=0}^{k} (\\alpha_{i}+ 1)\nsum1​=i=0∏k​(αi​+1)\n而 (n!)2(n!)^2(n!)2 的因子个数 sum2sum_{2}sum2​ 为：\nsum2=∏i=0k(α1⋅2+1)sum_{2} = \\prod_{i = 0}^{k} (\\alpha_{1} \\cdot 2 + 1)\nsum2​=i=0∏k​(α1​⋅2+1)\n根据乘法原理，最后的答案为所有 sum2sum_{2}sum2​ 的乘积。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MOD = 1e9 + 7;inline vector&lt;int&gt; GetPrimes(int Limit) &#123;  vector&lt;int&gt; primes;  vector&lt;bool&gt; mark(Limit + 1);    for (int i = 2; i &lt;= Limit; i ++) &#123;    if (mark[i] == false) &#123;      primes.emplace_back(i);    &#125;        for (int j = 0; i * primes[j] &lt;= Limit; j ++) &#123;      mark[i * primes[j]] = true;      if (i % primes[j] == 0) &#123;        break;      &#125;    &#125;  &#125;    return primes;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);    int n;  cin &gt;&gt; n;    vector&lt;int&gt; primes = GetPrimes(n);  // * 注意由于是连乘，所以 answer 的初始值为 1.  long long answer = 1;    for (auto&amp;&amp; p : primes) &#123;    int alpha = 0, number = n;        while (number) &#123;      alpha += number / p;      number /= p;    &#125;        answer = (answer * (alpha + alpha + 1) % MOD) % MOD;  &#125;    cout &lt;&lt; answer % MOD &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;","categories":["Solution"],"tags":["Math","Luogu"]},{"title":"CodeForces 727F","url":"/posts/e6d5c4e8/","content":"VJudge  洛谷   Codeforces\n算法\n\n贪心\n\n\n思路\n考虑特殊情况。当 m=1m=1m=1 时，问题转化为：给定 a0a_0a0​, 求删除最少元素使得对于任意的 iii，满足 Σj=0iaj≥0\\Sigma_{j=0}^{i} a_{j} \\ge 0Σj=0i​aj​≥0。\n将特殊情况扩展到 m≤106m \\le 10^6m≤106，即对于每一个给定的 a0a_0a0​，求解上述问题。\n考虑贪心，即对于一个 iii，满足 Σj=0iaj&lt;0\\Sigma_{j=0}^{i} a_{j} &lt; 0Σj=0i​aj​&lt;0， 则必定删除前面最大的负数，才会使最后的结果最优.于是可以逆向思维，倒序遍历数组 aaa，维护一个大根堆(即维护绝对值最小的负数，对于每一个 ai&lt;0a_{i} &lt; 0ai​&lt;0, 将其入队；对于每一个 ai≥0a_{i} \\ge 0ai​≥0，用 aia_{i}ai​ 抵消堆顶元素，直到堆为空或 ai&lt;0a_{i} &lt; 0ai​&lt;0。\n最后将堆里的元素全部放入一个新数组，即这些负数在 a1→ana_{1} \\to a_{n}a1​→an​ 里都不能被抵消，只能由 a0a_{0}a0​ 抵消，被删除的个数即为剩余负数的个数减去 a0a_{0}a0​ 最多可以抵消的负数，可以二分解决。\n代码\n#include &lt;bits/stdc++.h&gt;#define OnlineJudge  using namespace std;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);    int n, m;  cin &gt;&gt; n &gt;&gt; m;    vector&lt;long long&gt; a(n), b(m);  for (int i = 0; i &lt; n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  priority_queue&lt;long long, vector&lt;long long&gt;, less&lt;long long&gt;&gt; q;  for (int i = n - 1; i &gt;= 0; i--) &#123;    if (a[i] &lt; 0) &#123;      q.emplace(a[i]);    &#125; else &#123;      while (!q.empty() &amp;&amp; a[i] &gt;= 0) &#123;        a[i] += q.top();        q.pop();      &#125;            if (a[i] &lt; 0) &#123;        q.emplace(a[i]);      &#125;    &#125;    continue;  &#125;    vector&lt;long long&gt; modify;    while (!q.empty()) &#123;    modify.emplace_back(-q.top());    q.pop();  &#125;  // reverse(modify.begin(), modify.end());  for (int i = 1; i &lt; static_cast&lt;int&gt;(modify.size()); i++) &#123;    modify[i] = modify[i] + modify[i - 1];  &#125;  #ifndef OnlineJudge  for (auto&amp;&amp; var : modify) &#123;    cout &lt;&lt; var &lt;&lt; &quot; &quot;;  &#125;  cout &lt;&lt; &quot;\\n&quot;;  #endif  for (int i = 0; i &lt; m; i++) &#123;    cin &gt;&gt; b[i];    int answer;    if (modify.empty() || modify.back() &lt;= b[i]) &#123;      answer = 0;    &#125; else &#123;      int pos = upper_bound(modify.begin(), modify.end(), b[i]) - modify.begin();      answer = static_cast&lt;int&gt;(modify.size()) - pos;    &#125;    cout &lt;&lt; answer &lt;&lt; &#x27;\\n&#x27;;  &#125;  return 0;&#125;\n","categories":["Solution"],"tags":["CodeForces","贪心"]},{"title":"Luogu P1471","url":"/posts/d582d438/","content":"Luogu\n算法\n\n线段树\n数学推导（平均数，方差）\n\n\n思路\n区间操作，很容易想到线段树。\n但是方差不好合并，考虑拆解：\ns2=1n∑i=1n(Ai−A‾)2=1n∑i=1n(Ai2−2⋅Ai2⋅A‾+A‾2)=1n(∑i=1nAi2−∑i=1n2⋅Ai2⋅A‾+∑i=1nA‾2)=1n(∑i=1nAi2−2⋅A‾⋅∑i=1nAi+nA‾2)\\large\n\\begin{aligned}\ns^2 &amp;= \\frac{1}{n} \\sum_{i = 1}^{n} (A_i - \\overline A)^2 \\\\\n\t&amp;= \\frac{1}{n} \\sum_{i = 1}^{n} (A_i^2 - 2 \\cdot A_i^2 \\cdot \\overline A + \\overline A^2) \\\\\n\t&amp;= \\frac{1}{n} (\\sum_{i = 1}^{n} A_i^2 - \\sum_{i = 1}^{n} 2 \\cdot A_i^2 \\cdot \\overline A + \\sum_{i = 1}^{n} \\overline A^2) \\\\\n\t&amp;= \\frac{1}{n} (\\sum_{i = 1}^{n} A_i^2 - 2 \\cdot \\overline A \\cdot \\sum_{i = 1}^{n} A_i + n \\overline A^2)\n\\end{aligned}\ns2​=n1​i=1∑n​(Ai​−A)2=n1​i=1∑n​(Ai2​−2⋅Ai2​⋅A+A2)=n1​(i=1∑n​Ai2​−i=1∑n​2⋅Ai2​⋅A+i=1∑n​A2)=n1​(i=1∑n​Ai2​−2⋅A⋅i=1∑n​Ai​+nA2)​\n所以我们只需要维护区间和 sumsumsum，区间平方和 sum_squaresum\\_squaresum_square 就可以了。\n对于区间加的操作，有如下推导（记 sum2sum2sum2 为区间平方和）：\nsum2′=∑i=1n(Ai+val)2=∑i=1n(Ai2+2⋅Ai⋅val+val2)=∑i=1nAi2+∑i=1n2⋅Ai⋅val+∑i=1nval2=sum2+2⋅val⋅∑i=1n+n⋅val2\\large\n\\begin{aligned}\nsum2^{\\prime} &amp;= \\sum_{i = 1}^{n} (A_i + val)^2 \\\\\n\t\t\t  &amp;= \\sum_{i = 1}^{n} (A_i^2 + 2 \\cdot A_i \\cdot val + val^2) \\\\\n\t\t\t  &amp;= \\sum_{i = 1}^{n} A_i^2 + \\sum_{i = 1}^{n} 2 \\cdot A_i \\cdot val + \\sum_{i = 1}^{n} val^2 \\\\\n\t\t\t  &amp;= sum2 + 2 \\cdot val \\cdot \\sum_{i = 1}^{n} + n \\cdot val^2\n\\end{aligned}\nsum2′​=i=1∑n​(Ai​+val)2=i=1∑n​(Ai2​+2⋅Ai​⋅val+val2)=i=1∑n​Ai2​+i=1∑n​2⋅Ai​⋅val+i=1∑n​val2=sum2+2⋅val⋅i=1∑n​+n⋅val2​\n然后我们就做完了。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 1e5 + 5;long double arr[N], k;int n, m, op_type, l, r;struct SegmentTree &#123;  public:  struct Node &#123;    int l, r;    long double sum_square, sum, add;  &#125;;    Node tr[N &lt;&lt; 2];    void lazy(int k, long double value) &#123;    tr[k].sum_square += tr[k].sum * 2 * value + (tr[k].r - tr[k].l + 1) * value * value;    tr[k].sum += (tr[k].r - tr[k].l + 1) * value;    tr[k].add += value;  &#125;    void push_up(int k) &#123;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;    tr[k].sum_square = tr[lc].sum_square + tr[rc].sum_square;    tr[k].sum = tr[lc].sum + tr[rc].sum;  &#125;    void push_down(int k) &#123;    if (tr[k].add == 0) &#123;      return void();    &#125;        int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;    lazy(lc, tr[k].add);    lazy(rc, tr[k].add);        // ! 注意下传懒标记要清空。    tr[k].add = 0;  &#125;    void build_tree(int k, int l, int r) &#123;    tr[k].l = l, tr[k].r = r;    tr[k].sum = tr[k].sum_square = tr[k].add = 0;        if (tr[k].l == tr[k].r) &#123;      tr[k].sum = arr[l];      tr[k].sum_square = arr[l] * arr[l];      return void();    &#125;        int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        build_tree(lc, l, mid);    build_tree(rc, mid + 1, r);        push_up(k);  &#125;    void modify(int k, int l, int r, long double value) &#123;    if (tr[k].l &gt;= l &amp;&amp; tr[k].r &lt;= r) &#123;      lazy(k, value);      return void();    &#125;        push_down(k);        int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        if (r &lt;= mid) &#123;      modify(lc, l, r, value);    &#125; else if (l &gt; mid) &#123;      modify(rc, l, r, value);    &#125; else &#123;      modify(lc, l, mid, value);      modify(rc, mid + 1, r, value);    &#125;        push_up(k);  &#125;    long double __query_sum(int k, int l, int r) &#123;    if (tr[k].l &gt;= l &amp;&amp; tr[k].r &lt;= r) &#123;      return tr[k].sum;    &#125;        push_down(k);        int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        if (r &lt;= mid) &#123;      return __query_sum(lc, l, r);    &#125; else if (l &gt; mid) &#123;      return __query_sum(rc, l, r);    &#125; else &#123;      return __query_sum(lc, l, mid) + __query_sum(rc, mid + 1, r);    &#125;  &#125;    long double __query_sum_square(int k, int l, int r) &#123;    if (tr[k].l &gt;= l &amp;&amp; tr[k].r &lt;= r) &#123;      return tr[k].sum_square;    &#125;        push_down(k);        int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        if (r &lt;= mid) &#123;      return __query_sum_square(lc, l, r);    &#125; else if (l &gt; mid) &#123;      return __query_sum_square(rc, l, r);    &#125; else &#123;      return __query_sum_square(lc, l, mid) + __query_sum_square(rc, mid + 1, r);    &#125;  &#125;    long double query_average(int l, int r) &#123;    long double sum = __query_sum(1, l, r);    return sum / (long double) (r - l + 1);  &#125;    long double query_variance(int l, int r) &#123;    long double average = query_average(l, r);    long double sum = __query_sum(1, l, r);    long double sum_square = __query_sum_square(1, l, r);    int length = r - l + 1;        // cout &lt;&lt; average &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; sum_square &lt;&lt; &#x27;\\n&#x27;;        return (sum_square - 2 * average * sum + length * average * average) / (long double) length;  &#125;&#125; segment_tree;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i ++) &#123;    cin &gt;&gt; arr[i];  &#125;    segment_tree.build_tree(1, 1, n);    while (m --) &#123;    cin &gt;&gt; op_type &gt;&gt; l &gt;&gt; r;        if (op_type == 1) &#123;      cin &gt;&gt; k;      segment_tree.modify(1, l, r, k);    &#125; else if (op_type == 2) &#123;      long double result = segment_tree.query_average(l, r);      result = round(result * 10000) / (long double) 10000;            cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(4) &lt;&lt; result &lt;&lt; &#x27;\\n&#x27;;    &#125; else if (op_type == 3) &#123;      long double result = segment_tree.query_variance(l, r);      result = round(result * 10000) / (long double) 10000;            cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(4) &lt;&lt; result &lt;&lt; &#x27;\\n&#x27;;    &#125;  &#125;    return 0;&#125;","categories":["Solution"],"tags":["Math","SegmentTree","Luogu"]},{"title":"Luogu P3129","url":"/posts/aeca22f/","content":"Luogu\n算法\n\n贪心\n\n\n思路\n由于 Bessie 预先知道了 Elsie 的出牌策略, 所以可以贪心, 考虑每次都出比 Elsie 大一点点的牌, 如果没有就改变规则, 这样可以保证得分最大化.\n记 fif_ifi​ 表示每次都出大一点点的牌最多可以赢几次, gig_igi​ 相反.\n则最后的答案为 maxin{fi+gi+1}max_{i}^{n} \\{f_i + g_{i+1}\\}maxin​{fi​+gi+1​}\n关于重复的证明见 Link\n代码\n#include &lt;bits/stdc++.h&gt;  using namespace std;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);    int n;  cin &gt;&gt; n;    vector&lt;int&gt; Elsie(n);  set&lt;int, greater&lt;int&gt;&gt; BessieG;  set&lt;int, less&lt;int&gt;&gt; BessieL;  vector&lt;bool&gt; used(2 * n + 1, false);    for (int i = 0; i &lt; n; i++) &#123;    cin &gt;&gt; Elsie[i];      used[Elsie[i]] = true;  &#125;    for (int i = 1; i &lt;= 2 * n; i++) &#123;    if (used[i] == false) &#123;      BessieG.insert(i);      BessieL.insert(i);    &#125;  &#125;    vector&lt;int&gt; f(n + 2), g(n + 2);    for (int i = 1; i &lt;= n; i++) &#123;    set&lt;int&gt;::iterator found = BessieL.lower_bound(Elsie[i - 1]);      // * 如果 found != BessieG.end(), 则 Bessie 可以在这一轮出比 Elsie 大的    if (found != BessieL.end()) &#123;      BessieL.erase(found);      f[i] = f[i - 1] + 1;    &#125; else &#123;      f[i] = f[i - 1];    &#125;  &#125;    // ! 注意这里要逆序循环 (40 pts)  for (int i = n; i &gt;= 1; i--) &#123;    set&lt;int&gt;::iterator found = BessieG.lower_bound(Elsie[i - 1]);      // * 如果 found != BessieL.end(), 则 Bessie 可以在这一轮出比 Elsie 小的    if (found != BessieG.end()) &#123;      BessieG.erase(found);      g[i] = g[i + 1] + 1;    &#125; else &#123;      g[i] = g[i + 1];    &#125;  &#125;    int answer = 0;    // ! 这里统计答案的范围为 [0, n] (47 pts)  for (int i = 0; i &lt;= n; i++) &#123;    answer = max(answer, f[i] + g[i + 1]);  &#125;    cout &lt;&lt; answer &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;","categories":["Solution"],"tags":["Luogu","贪心"]},{"title":"斐波那契数列与黄金分割比的关系","url":"/posts/3a2599d0/","content":"斐波那契数列与黄金分割比的关系\n\n前言\n众所周知，斐波那契数列的递推公式为：\nfi={0i=01i=1fi−1+fi−2i≥2f_i = \\begin{cases}\n0 &amp; i=0 \\\\\n1 &amp; i = 1 \\\\\nf_{i-1}+f_{i-2} &amp; i \\ge 2\n\\end{cases}\nfi​=⎩⎨⎧​01fi−1​+fi−2​​i=0i=1i≥2​\n为什么会把斐波那契数列与黄金分割比联系再一起呢？其实和斐波那契的通项公式有关。\n斐波那契数列的通项公式\n我们考虑使用生成函数推导斐波那契数列的通项公式（别问我为什么，问就是博客正好写了，搬运一下）。\n关于生成函数\n生成函数是指以某个序列为系数的多项式，其形式为：\nF(x)=∑i=0aixiF(x) = \\sum_{i=0} a_i x^i\nF(x)=i=0∑​ai​xi\n其中 xxx 的存在并没有什么意义，所以又被称为形式幂级函数\n\n我们定义斐波那契数列的生成函数 F(x)F(x)F(x) 为：\nF(x)=∑i≥0fixiF(x) = \\sum_{i \\ge 0} f_i x^i\nF(x)=i≥0∑​fi​xi\n我们对这个式子进行变换\nF(x)=∑i≥0fixi=f0+xf1+∑i≥2fixi\\begin{aligned}\nF(x) &amp;= \\sum_{i \\ge 0} f_i x^i \\\\\n&amp;= f_0 + x f_1 + \\sum_{i \\ge 2} f_i x^i \\\\\n\\end{aligned}\nF(x)​=i≥0∑​fi​xi=f0​+xf1​+i≥2∑​fi​xi​\n当 i≥2i \\ge 2i≥2 时，fi=fi−1+fi−2f_i = f_{i-1} + f_{i - 2}fi​=fi−1​+fi−2​，所以：\nF(x)=f0+xf1+∑i≥2(fi−1+fi−2)xi=f0+xf1+∑i≥2fi−1xi+∑i≥2fi−2xi=f0+xf1+∑i≥2fi−1xi+∑i≥2fi−2xi=f0+xf1+x∑i≥2fi−1xi−1+x2∑i≥2fi−2xi−2=f0+xf1+x∑i≥1fixi+x2∑i≥1fixi\\begin{aligned}\nF(x) &amp;= f_0 + x f_1 + \\sum_{i \\ge 2} (f_{i-1} + f_{i-2}) x^i \\\\\n&amp;= f_0 + x f_1 + \\sum_{i \\ge 2} f_{i-1} x^i + \\sum_{i \\ge 2} f_{i-2} x^i \\\\\n&amp;= f_0 + x f_1 + \\sum_{i \\ge 2} f_{i-1} x^i + \\sum_{i \\ge 2} f_{i-2} x^i \\\\\n&amp;= f_0 + x f_1 + x \\sum_{i \\ge 2} f_{i-1} x^{i-1} + x^2 \\sum_{i \\ge 2} f_{i-2} x^{i-2} \\\\\n&amp;= f_0 + x f_1 + x \\sum_{i \\ge 1} f_{i} x^{i} + x^2 \\sum_{i \\ge 1} f_{i} x^i\n\\end{aligned}\nF(x)​=f0​+xf1​+i≥2∑​(fi−1​+fi−2​)xi=f0​+xf1​+i≥2∑​fi−1​xi+i≥2∑​fi−2​xi=f0​+xf1​+i≥2∑​fi−1​xi+i≥2∑​fi−2​xi=f0​+xf1​+xi≥2∑​fi−1​xi−1+x2i≥2∑​fi−2​xi−2=f0​+xf1​+xi≥1∑​fi​xi+x2i≥1∑​fi​xi​\n然后由 F(x)=∑i≥0fixi\\displaystyle F(x) = \\sum_{i \\ge 0} f_i x^iF(x)=i≥0∑​fi​xi 且当 i=0i=0i=0 时，f0x0=0f_0 x^0 = 0f0​x0=0 可得：\nF(x)=f0+xf1+x∑i≥1fixi+x2∑i≥1fxiF(x)=f0+xf1+xF(x)+x2F(x)∵ f0=0,f1=1∴ F(x)=x+xF(x)+x2F(x)\\begin{aligned}\n&amp; F(x) = f_0 + x f_1 + x \\sum_{i \\ge 1} f_{i} x^i + x^2 \\sum_{i \\ge 1} f_{} x^i \\\\\n&amp; F(x) = f_0 + x f_1 + x F(x) + x^2 F(x) \\\\\n\\because \\ &amp; f_0 = 0, f_1 = 1 \\\\\n\\therefore \\ &amp; F(x) = x + x F(x) + x^2 F(x) \\\\\n\\end{aligned}\n∵ ∴ ​F(x)=f0​+xf1​+xi≥1∑​fi​xi+x2i≥1∑​f​xiF(x)=f0​+xf1​+xF(x)+x2F(x)f0​=0,f1​=1F(x)=x+xF(x)+x2F(x)​\n合并同类项，系数化为一，得：\n(1−x−x2)F(x)=x∴ F(x)=x1−x−x2\\begin{aligned}\n&amp; (1 - x - x^2) F(x) = x \\\\\n\\therefore \\ &amp; F(x) = \\frac{x}{1 - x - x^2}\n\\end{aligned}\n∴ ​(1−x−x2)F(x)=xF(x)=1−x−x2x​​\n这样，我们就得到了 F(x)F(x)F(x) 的封闭形式。\n对于这个式子，我们考虑使用待定系数法将其部分分式分解：\nA1−ax+B1−bx=x1−x−x2A−Abx+B−aBx1−(a+b)x+abx2=x1−x−x2(A+B)−(Ab+aB)x1−(a+b)x+abx2=x1−x−x2\\begin{aligned}\n\\frac{A}{1-ax} + \\frac{B}{1-bx} &amp;= \\frac{x}{1 - x - x^2} \\\\\n\\\\\n\\frac{A - Abx + B - aBx}{1 - (a + b)x + abx^2} &amp;= \\frac{x}{1 - x - x^2} \\\\\n\\\\\n\\frac{(A+B) - (Ab + aB)x}{1 - (a + b)x + abx^2} &amp;= \\frac{x}{1 - x - x^2} \\\\\n\\end{aligned}\n1−axA​+1−bxB​1−(a+b)x+abx2A−Abx+B−aBx​1−(a+b)x+abx2(A+B)−(Ab+aB)x​​=1−x−x2x​=1−x−x2x​=1−x−x2x​​\n观察两边的系数，得到一个方程组：\n{A+B=0Ab+aB=−1a+b=1ab=−1⇒{A=15B=−15a=1+52b=1−52\\begin{cases}\nA + B = 0 \\\\\nAb + aB = -1 \\\\\na + b = 1 \\\\\nab = -1 \\\\\n\\end{cases}\n\\Rightarrow\n\\begin{cases}\nA = \\frac{1}{\\sqrt{5}} \\\\\nB = - \\frac{1}{\\sqrt{5}} \\\\\na = \\frac{1 + \\sqrt{5}}{2} \\\\\nb = \\frac{1 - \\sqrt{5}}{2} \\\\\n\\end{cases}\n⎩⎨⎧​A+B=0Ab+aB=−1a+b=1ab=−1​⇒⎩⎨⎧​A=5​1​B=−5​1​a=21+5​​b=21−5​​​\n接下来我们要介绍一个前置知识——几何级数（等比数列求和）。\n关于几何级数\n几何级数是指形式为\n∑n=0∞rn\\sum_{n=0}^{\\infty} r^n\nn=0∑∞​rn\n的级数。其中 rrr 称为公比（其实就是等比数列）。当 ∣r∣&lt;1|r| &lt; 1∣r∣&lt;1 时，级数收敛，其和为：\n∑n=1∞rn=11−r\\sum_{n=1}^{\\infty} r^n = \\frac{1}{1 - r}\nn=1∑∞​rn=1−r1​\n这个就是我们接下来展开要用到的公式。\n\n我们运用几何级数将上面最初的表达式展开：\nA1−ax=A∑i=0∞(ax)i=A∑i=0∞aixiB1−bx=B∑i=0∞(bx)i=B∑i=0∞bixi\\begin{aligned}\n&amp; \\frac{A}{1-ax} = A\\sum_{i=0}^{\\infty} (ax)^i = A\\sum_{i=0}^{\\infty} a^i x^i \\\\\n&amp; \\frac{B}{1-bx} = B\\sum_{i=0}^{\\infty} (bx)^i = B\\sum_{i=0}^{\\infty} b^i x^i \\\\\n\\end{aligned}\n​1−axA​=Ai=0∑∞​(ax)i=Ai=0∑∞​aixi1−bxB​=Bi=0∑∞​(bx)i=Bi=0∑∞​bixi​\n收敛性证明\n用几何级数展开公式时有一个前提：∣r∣&lt;1|r| &lt; 1∣r∣&lt;1，而上面两个式子的 rrr 分别为 axaxax 和 bxbxbx。\n其中 a=1+52,b=1−52a = \\frac{1 + \\sqrt{5}}{2}, b = \\frac{1 - \\sqrt{5}}{2}a=21+5​​,b=21−5​​，所以：\nax=1+52xbx=1−52x\\begin{aligned}\n&amp; ax = \\frac{1 + \\sqrt{5}}{2} x \\\\\n&amp; bx = \\frac{1 - \\sqrt{5}}{2} x\n\\end{aligned}\n​ax=21+5​​xbx=21−5​​x​\n对于 a,b,xa,b,xa,b,x 存在限制：\n{∣1+52x∣&lt;1∣1−52x∣&lt;1⇒{∣1+52∣∣x∣&lt;1∣1−52∣∣x∣&lt;1\\begin{cases}\n|\\frac{1 + \\sqrt{5}}{2} x| &lt; 1 \\\\\n\\\\\n|\\frac{1 - \\sqrt{5}}{2} x| &lt; 1\n\\end{cases}\n\\Rightarrow\n\\begin{cases}\n|\\frac{1 + \\sqrt{5}}{2}| |x| &lt; 1 \\\\\n\\\\\n|\\frac{1 - \\sqrt{5}}{2}| |x| &lt; 1 \n\\end{cases}\n⎩⎨⎧​∣21+5​​x∣&lt;1∣21−5​​x∣&lt;1​⇒⎩⎨⎧​∣21+5​​∣∣x∣&lt;1∣21−5​​∣∣x∣&lt;1​\n所以\n{∣x∣&lt;∣5−12∣∣x∣&lt;∣−5+12∣\\begin{cases}\n|x| &lt; |\\frac{\\sqrt{5} - 1}{2}| \\\\\n\\\\\n|x| &lt; |-\\frac{\\sqrt{5} + 1}{2}|\n\\end{cases}\n⎩⎨⎧​∣x∣&lt;∣25​−1​∣∣x∣&lt;∣−25​+1​∣​\n即\n∣x∣&lt;min⁡(∣5−12∣,∣−5+12∣)=5−12|x| &lt; \\min\\Big(|\\frac{\\sqrt{5} - 1}{2}|, |-\\frac{\\sqrt{5} + 1}{2}|\\Big) = \\frac{\\sqrt{5} - 1}{2}\n∣x∣&lt;min(∣25​−1​∣,∣−25​+1​∣)=25​−1​\n因为 F(x)F(x)F(x) 定义为形式幂级数，所以我们仅关注 xix^ixi 的系数，而不关注 xxx 的具体的值，只要由满足条件的 xxx 存在，就可以用上面的方式对原式展开。\n\n用上面两个式子等量代换，得：\nF(x)=A(∑i=0∞aixi)+B(∑i=0∞bixi)=15(∑i=0∞(1+52)ixi)−15(∑i=0∞(1−52)xi)=15(∑i=0∞(1+52)ixi−∑i=0∞(1−52)ixi)=15∑i=0∞((1+52)ixi−(1−52)ixi)=15∑i=0∞xi((1+52)i−(1−52)i)=∑i=0∞(1+52)i−(1−52)i5xi\\begin{aligned}\nF(x) &amp;= A \\Bigg(\\sum_{i=0}^{\\infty} a^i x^i \\Bigg) + B \\Bigg( \\sum_{i=0}^{\\infty} b^i x^i \\Bigg) \\\\\n&amp;= \\textcolor{red}{\\frac{1}{\\sqrt{5}}} \\Bigg( \\sum_{i=0}^{\\infty} \\bigg( \\frac{1 + \\sqrt{5}}{2} \\bigg)^i x^i \\Bigg) - \\textcolor{red}{\\frac{1}{\\sqrt{5}}} \\Bigg( \\sum_{i=0}^{\\infty} \\bigg( \\frac{1 - \\sqrt{5}}{2} \\bigg) x^i \\Bigg) \\\\\n&amp;= \\frac{1}{\\sqrt{5}} \\Bigg( \\sum_{\\textcolor{blue}{i=0}}^{\\infty} \\bigg( \\frac{1 + \\sqrt{5}}{2} \\bigg)^i x^i - \\sum_{\\textcolor{blue}{i=0}}^{\\infty} \\bigg( \\frac{1 - \\sqrt{5}}{2} \\bigg)^i x^i \\Bigg) \\\\\n&amp;= \\frac{1}{\\sqrt{5}} \\sum_{i=0}^{\\infty} \\bigg( \\Big(\\frac{1 + \\sqrt{5}}{2} \\Big)^i x^i - \\Big( \\frac{1-\\sqrt{5}}{2} \\Big)^i x^i \\bigg)\\\\\n&amp;= \\frac{1}{\\sqrt{5}} \\sum_{i=0}^{\\infty} \\textcolor{green}{x^i} \\bigg( \\Big(\\frac{1 + \\sqrt{5}}{2} \\Big)^i - \\Big( \\frac{1-\\sqrt{5}}{2} \\Big)^i \\bigg) \\\\\n&amp;= \\sum_{i=0}^{\\infty} \\frac{\\big(\\frac{1 + \\sqrt{5}}{2} \\big)^i - \\big( \\frac{1-\\sqrt{5}}{2} \\big)^i}{\\sqrt{5}} x^i \\\\\n\\end{aligned}\nF(x)​=A(i=0∑∞​aixi)+B(i=0∑∞​bixi)=5​1​(i=0∑∞​(21+5​​)ixi)−5​1​(i=0∑∞​(21−5​​)xi)=5​1​(i=0∑∞​(21+5​​)ixi−i=0∑∞​(21−5​​)ixi)=5​1​i=0∑∞​((21+5​​)ixi−(21−5​​)ixi)=5​1​i=0∑∞​xi((21+5​​)i−(21−5​​)i)=i=0∑∞​5​(21+5​​)i−(21−5​​)i​xi​\n对比 F(x)F(x)F(x) 最初的的定义：\nF(x)=∑i=0∞fixiF(x) = \\sum_{i=0}^{\\infty} f_i x^i\nF(x)=i=0∑∞​fi​xi\n得斐波那契数列的通项公式为：\nfi=(1+52)i−(1−52)i5f_i = \\frac{\\big(\\frac{1 + \\sqrt{5}}{2} \\big)^i - \\big(\\frac{1 - \\sqrt{5}}{2} \\big)^i}{\\sqrt{5}}\nfi​=5​(21+5​​)i−(21−5​​)i​\n其中就有黄金分割比 ϕ=5−12\\phi = \\frac{\\sqrt{5} - 1}{2}ϕ=25​−1​ 的相反数。\n更直观的体现\n我们已经发现了斐波那契数列的通项公式中的黄金分割比，其实黄金分割比在斐波那契数列中还有更直观的体现。\n我们取斐波那契数列相邻两项的比值：\nfifi+1=(1+52)i−(1−52)i(1+52)i+1−(1−52)i+1=21+5(1+52)i+1−21−5(1−52)i+1(1+52)i+1−(1−52)i+1=5−12(1+52)i+1−(5−12−5)(1−52)i+1(1+52)i+1−(1−52)i+1=5−12(1+52)i+1−5−12(1−52)i+1−5(1−52)i+1(1+52)i+1−(1−52)i+1=5−12−5(1−52)i+1(1+52)i+1−(1−52)i+1=5−12−5(−3+52)i+1−1\\begin{aligned}\n\\frac{f_i}{f_{i+1}} &amp;= \\frac{\\big ( \\frac{1+\\sqrt{5}}{2} \\big)^i - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^i}{\\big ( \\frac{1+\\sqrt{5}}{2} \\big)^{i+1} - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}} \\\\\n&amp;= \\frac{ \\frac{2}{1+\\sqrt{5}} \\big( \\frac{1 + \\sqrt{5}}{2} \\big)^{\\textcolor{red}{i+1}} - \\frac{2}{1-\\sqrt{5}} \\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{\\textcolor{red}{i+1}} }{ \\big(\\frac{1+\\sqrt{5}}{2} \\big)^{i+1} - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}} \\\\\n&amp;= \\frac{ \\frac{\\sqrt{5} - 1}{2} \\big( \\frac{1 + \\sqrt{5}}{2} \\big)^{i+1} - \\big(\\frac{\\sqrt{5} - 1}{2} - \\sqrt{5}\\big) \\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1} }{ \\big(\\frac{1+\\sqrt{5}}{2} \\big)^{i+1} - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}} \\\\\n&amp;= \\frac{ \\frac{\\sqrt{5} - 1}{2} \\textcolor{red}{\\big( \\frac{1 + \\sqrt{5}}{2} \\big)^{i+1}} - \\frac{\\sqrt{5} - 1}{2} \\textcolor{red}{\\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}} - \\sqrt{5}\\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}}{ \\textcolor{red}{\\big(\\frac{1+\\sqrt{5}}{2} \\big)^{i+1}} - \\textcolor{red}{\\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}}} \\\\\n&amp;= \\frac{\\sqrt{5} - 1}{2} - \\frac{\\sqrt{5}\\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}}{\\big(\\frac{1+\\sqrt{5}}{2} \\big)^{i+1} - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1} } \\\\\n&amp;= \\frac{\\sqrt{5} - 1}{2} - \\textcolor{red}{\\frac{\\sqrt{5}}{ \\big( - \\frac{3 + \\sqrt{5}}{2} \\big)^{i+1} - 1 }} \\\\\n\\end{aligned}\nfi+1​fi​​​=(21+5​​)i+1−(21−5​​)i+1(21+5​​)i−(21−5​​)i​=(21+5​​)i+1−(21−5​​)i+11+5​2​(21+5​​)i+1−1−5​2​(21−5​​)i+1​=(21+5​​)i+1−(21−5​​)i+125​−1​(21+5​​)i+1−(25​−1​−5​)(21−5​​)i+1​=(21+5​​)i+1−(21−5​​)i+125​−1​(21+5​​)i+1−25​−1​(21−5​​)i+1−5​(21−5​​)i+1​=25​−1​−(21+5​​)i+1−(21−5​​)i+15​(21−5​​)i+1​=25​−1​−(−23+5​​)i+1−15​​​\n当 i→∞i \\to \\inftyi→∞ 时，后面的分式的值趋向于 000，即：\nlim⁡i→∞fifi+1=5−12\\lim_{i \\to \\infty} \\frac{f_i}{f_{i+1}} = \\frac{\\sqrt{5} - 1}{2}\ni→∞lim​fi+1​fi​​=25​−1​\n所以，斐波那契数列相邻两项的比值趋向于黄金分割比 ϕ\\phiϕ。\n","categories":["Others"],"tags":["Math","Others"]},{"title":"Hello World!","url":"/posts/1c291ca3/","content":"New Beginning, New Future\n\n也是用 Github Page 搭建了一个新的博客。\n最近应该会把博客园的文章搬运过来（搬完了喵~），继续加油吧。\n","categories":["Others"],"tags":["Others"]},{"title":"SPOJ GSS3","url":"/posts/63ce06a9/","content":"洛谷   VJudge\n算法\n\n线段树\n\n\n思路\n题目要求维护支持单点修改和查询区间最大子段和的数据结构。\n考虑使用线段树维护。对于区间 [l1,r1],[l2,r2][l_1,r_1], [l_2,r_2][l1​,r1​],[l2​,r2​] ，合并后的最大子段和有一下三种情况：\n\n区间 [l1,r1][l_1,r_1][l1​,r1​] 的最大子段和。\n区间 [l2,r2][l_2,r_2][l2​,r2​] 的最大子段和。\n跨过中间，区间 [l1,r1][l_1,r_1][l1​,r1​] 的右边部分和区间 [l2,r2][l_2,r_2][l2​,r2​] 的左边部分合并后的最大子段和。\n\n所以线段树要维护的信息有四个：\n\n区间和\n区间最大子段和\n区间左侧最大子段和。\n区间右侧最大子段和。\n\n对以上四个信息分别维护即可。\n代码\n#include &lt;bits/stdc++.h&gt;constexpr int N = 5e4 + 5;int n, m, op, l, r, arr[N];class SegmentTree &#123; protected:  class Values &#123;   public:    int sum = 0, max = 0, left_max = 0, right_max = 0;    Values() = default;    Values(int x) &#123;      sum = x;      max = x;      left_max = x;      right_max = x;    &#125;  &#125;;  class Node &#123;   public:    int l, r;    Values val;  &#125;;  Node tr[N &lt;&lt; 2]; public:  Values merge(Values a, Values b) &#123;    Values retval;    retval.sum = a.sum + b.sum;    retval.max = std::max(&#123;a.max, b.max, a.right_max + b.left_max&#125;);    retval.left_max = std::max(a.left_max, a.sum + b.left_max);    retval.right_max = std::max(b.right_max, b.sum + a.right_max);    return retval;  &#125;  void push_up(int k) &#123;    Values lc = tr[k &lt;&lt; 1].val, rc = tr[k &lt;&lt; 1 | 1].val;    tr[k].val = merge(lc, rc);  &#125;  void build_tree(int k, int l, int r) &#123;    tr[k].l = l, tr[k].r = r;    tr[k].val = Values(0);    if (tr[k].l == tr[k].r) &#123;      tr[k].val = Values(arr[l]);      return void();    &#125;    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;    build_tree(lc, l, mid);    build_tree(rc, mid + 1, r);    push_up(k);  &#125;  void modify(int k, int pos, int value) &#123;    if (tr[k].l == tr[k].r &amp;&amp; tr[k].r == pos) &#123;      tr[k].val = Values(value);      return void();    &#125;    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;    if (pos &lt;= mid) &#123;      modify(lc, pos, value);    &#125; else &#123;      modify(rc, pos, value);    &#125;    push_up(k);  &#125;  Values query(int k, int l, int r) &#123;    if (tr[k].l &gt;= l &amp;&amp; tr[k].r &lt;= r) &#123;      return tr[k].val;    &#125;    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;    if (r &lt;= mid) &#123;      return query(lc, l, r);    &#125; else if (l &gt; mid) &#123;      return query(rc, l, r);    &#125; else &#123;      return merge(query(lc, l, mid), query(rc, mid + 1, r));    &#125;  &#125;&#125; segment_tree;int main() &#123;  std::ios::sync_with_stdio(false);  std::cin.tie(nullptr);  std::cout.tie(nullptr);  std::cin &gt;&gt; n;  for (int i = 1; i &lt;= n; i++) &#123;    std::cin &gt;&gt; arr[i];  &#125;  segment_tree.build_tree(1, 1, n);    std::cin &gt;&gt; m;  while (m--) &#123;    std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;        if (op == 0) &#123;      segment_tree.modify(1, l, r);    &#125; else if (op == 1) &#123;      std::cout &lt;&lt; segment_tree.query(1, l, r).max &lt;&lt; &#x27;\\n&#x27;;    &#125;  &#125;  return 0;&#125;","categories":["Solution"],"tags":["SegmentTree","SPOJ"]},{"title":"OI集训 Day1","url":"/posts/999d0faf/","content":"Content：Data Structs\nDate：2025.7.17\n\n内容\n\n并查集\nST表\n线段树\n\n关于树状数组\n一维树状数组\n单点修改，区间查询\n对于这一类最普通的树状数组，没有什么好说的，直接维护前缀和即可。\nstruct BIT &#123;  long long tr[N];    static int lowbit(int x) &#123;    return x &amp; (-x);  &#125;    void add(int pos, long long value) &#123;    for (int i = pos; i &lt;= n; i += lowbit(i))      tr[i] += value;  &#125;    long long query(int pos) &#123;    long long retval = 0;    for (int i = pos; i &gt; 0; i -= lowbit(i))      retval += tr[i];    return retval;  &#125;&#125; tr;\n区间修改，单点查询\n这里就需要使用到差分了。\n记 d[i]=arr[i]−arr[i−1]d[i] = arr[i] - arr[i - 1]d[i]=arr[i]−arr[i−1]，则我们有：\narr[i]=∑i=0nd[i]arr[i] = \\sum_{i=0}^{n} d[i]\narr[i]=i=0∑n​d[i]\n后面的求和可以用树状数组维护。\nstruct BIT &#123;  long long tr[N];    static int lowbit(int x) &#123;    return x &amp; (-x);  &#125;    void add(int pos, int value) &#123;    for (int i = pos; i &lt;= n; i += lowbit(i))      tr[i] += value;  &#125;    long long query(int pos) &#123;    long long retval = 0;    for (int i = pos; i &gt; 0; i -= lowbit(i))      retval += tr[i];    return retval;  &#125;&#125; tr;\n这一部分的代码和上面的没什么区别，区别只有 main()main()main() 函数中的输入和修改。\n对于输入：\nfor (int i = 1; i &lt;= n; i++) &#123;  cin &gt;&gt; a[i];  // 这里存储的是差分后的结果，而不是 a[i]  tr.add(i, a[i] - a[i - 1]);&#125;\n对于修改：\nint l, r, x;cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;// 差分数组上的区间价相当于 d[l] += v, d[r + 1] -= v;tr.add(l, x);tr.add(r + 1, -x);\n区间修改，区间查询\n对于区间修改，我们沿用上面的思路，接下来我们看如何区间查询。\n差分有如下性质：\narr[i]=∑i=0nd[i]arr[i] = \\sum_{i = 0}^{n} d[i]\narr[i]=i=0∑n​d[i]\n而我们要求的区间和可以转化为：\n∑i=lrarr[i]=∑i=0rarr[i]−∑i=0l−1arr[i]\\begin{aligned}\n\\sum_{i = l}^{r} arr[i] = \\sum_{i = 0}^{r} arr[i] - \\sum_{i = 0}^{l - 1} arr[i]\n\\end{aligned}\ni=l∑r​arr[i]=i=0∑r​arr[i]−i=0∑l−1​arr[i]​\n所以我们的问题重新转化为了如何求解前缀和。\n∑i=0rarr[i]=∑i=0r∑j=0id[j]=∑i=0r(r−i+1)⋅d[i]=∑i=0r(r+1)⋅d[i]−i⋅d[i]=(r+1)⋅∑i=0rd[i]−∑i=0rd[i]⋅i\\begin{aligned}\n\\sum_{i = 0}^{r} arr[i] &amp;= \\sum_{i = 0}^{r} \\sum_{j = 0}^{i} d[j] \\\\\n&amp;= \\sum_{i = 0}^{r} (r - i + 1) \\cdot d[i] \\\\\n&amp;= \\sum_{i = 0}^{r} (r + 1) \\cdot d[i] - i \\cdot d[i] \\\\\n&amp;= (r + 1) \\cdot \\sum_{i = 0}^{r} d[i] - \\sum_{i = 0}^{r} d[i] \\cdot i \\\\\n\\end{aligned}\ni=0∑r​arr[i]​=i=0∑r​j=0∑i​d[j]=i=0∑r​(r−i+1)⋅d[i]=i=0∑r​(r+1)⋅d[i]−i⋅d[i]=(r+1)⋅i=0∑r​d[i]−i=0∑r​d[i]⋅i​\n所以我们用两个树状数组 tr1,tr2tr1, tr2tr1,tr2 来分别维护两个和式，就解决了区间求和的问题。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;int n, q, op, a[N];int lowbit(int x) &#123; return x &amp; (-x); &#125;struct BIT &#123;  long long tr[N];  void add(int pos, long long value) &#123;    for (int i = pos; i &lt;= n; i += lowbit(i)) tr[i] += value;  &#125;  long long query(int pos) &#123;    long long retval = 0;    for (int i = pos; i &gt; 0; i -= lowbit(i)) retval += tr[i];    return retval;  &#125;&#125; tr1, tr2;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);  cin &gt;&gt; n &gt;&gt; q;  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];    tr1.add(i, a[i] - a[i - 1]);    tr2.add(i, 1ll * (a[i] - a[i - 1]) * i);  &#125;  for (int i = 1; i &lt;= q; i++) &#123;    cin &gt;&gt; op;    if (op == 1) &#123;      int l, r, value;      cin &gt;&gt; l &gt;&gt; r &gt;&gt; value;      tr1.add(l, value);      tr1.add(r + 1, -value);      tr2.add(l, 1ll * value * l);      tr2.add(r + 1, -1ll * value * (r + 1));    &#125; else if (op == 2) &#123;      int l, r;      cin &gt;&gt; l &gt;&gt; r;            long long ans = (tr1.query(r) * (r + 1) - tr2.query(r)) - (tr1.query(l - 1) * l - tr2.query(l - 1));            cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;    &#125;  &#125;  return 0;&#125;\n二维树状数组\nPre：二维前缀和\n对于二维数组的前缀和有如下公式：\nsum[i][j]=sum[i−1][j]+sum[i][j−1]−sum[i−1][j−1]+arr[i][j]sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + arr[i][j]\nsum[i][j]=sum[i−1][j]+sum[i][j−1]−sum[i−1][j−1]+arr[i][j]\n对于左上角坐标为 (a,b)(a, b)(a,b)，右下角坐标为 (c,d)(c, d)(c,d) 的子矩阵，其和为：\nsum[c][d]−sum[a−1][d]−sum[c][b−1]+sum[a−1][b−1]sum[c][d] - sum[a - 1][d] - sum[c][b - 1] + sum[a - 1][b - 1]\nsum[c][d]−sum[a−1][d]−sum[c][b−1]+sum[a−1][b−1]\n单点修改，区间查询\n和一维树状数组类似，直接记 tr[i][j]tr[i][j]tr[i][j] 为左上角坐标为 (0,0)(0, 0)(0,0)，右下角坐标为 (i,j)(i, j)(i,j) 的矩阵的和。\n修改和查询直接套公式。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1 &lt;&lt; 12 + 5;int n, m, op;struct BIT &#123;  vector&lt;vector&lt;long long&gt;&gt; tr;    BIT() = default;    BIT(int n, int m) &#123;    tr.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));  &#125;    static int lowbit(int x) &#123;    return x &amp; (-x);  &#125;    void add(int x, int y, long long value) &#123;    for (int i = x; i &lt;= n; i += lowbit(i))      for (int j = y; j &lt;= m; j += lowbit(j))        tr[i][j] += value;  &#125;    long long query(int x, int y) &#123;    long long retval = 0;    for (int i = x; i &gt; 0; i -= lowbit(i))      for (int j = y; j &gt; 0; j -= lowbit(j))        retval += tr[i][j];    return retval;  &#125;&#125; tr;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);    cin &gt;&gt; n &gt;&gt; m;    tr = BIT(n, m);    while (cin &gt;&gt; op) &#123;    if (op == 1) &#123;      int x, y, value;      cin &gt;&gt; x &gt;&gt; y &gt;&gt; value;            tr.add(x, y, value);    &#125; else if (op == 2) &#123;      int a, b, c, d;            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;            long long ans = tr.query(c, d) - tr.query(a - 1, d) - tr.query(c, b - 1) + tr.query(a - 1, b - 1);            cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;    &#125;  &#125;    return 0;&#125;\n区间修改，单点查询\n我们由一维树状数组的区间修改，单点查询启发，可以考虑定义二维差分。\n定义二维差分数组（为避免名字冲突，这里定义为 c[i][j]c[i][j]c[i][j]）c[i][j]=a[i][j]−a[i−1][j]−a[i][j−1]−a[i−1][j−1]c[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] - a[i - 1][j - 1]c[i][j]=a[i][j]−a[i−1][j]−a[i][j−1]−a[i−1][j−1]。\n证明\n观察到：\narr[i][j]=sum[i][j]−sum[i−1][j]−sum[i][j−1]+sum[i−1][j−1]arr[i][j] = sum[i][j] - sum[i - 1][j] - sum[i][j - 1] + sum[i - 1][j - 1]\narr[i][j]=sum[i][j]−sum[i−1][j]−sum[i][j−1]+sum[i−1][j−1]\n所以二维差分数组 d[i][j]d[i][j]d[i][j] 满足：\na[i][j]=a[i−1][j]+a[i][j−1]−a[i−1][j−1]+c[i][j]a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + c[i][j]\na[i][j]=a[i−1][j]+a[i][j−1]−a[i−1][j−1]+c[i][j]\n即：\nc[i][j]=a[i][j]−a[i−1][j]−a[i][j−1]+a[i−1][j−1]c[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]\nc[i][j]=a[i][j]−a[i−1][j]−a[i][j−1]+a[i−1][j−1]\n\n所以我们得到了二维差分数组 c[i][j]c[i][j]c[i][j] 的表达式。\n跟一维差分类似地，我们可以得到子矩阵 (a,b)(a, b)(a,b)，(c,d)(c, d)(c,d) 加法在差分数组中的等效替代：\nsum(a,b,c,d,v)  ⟺  c[a][b]+v,c[c+1][b]−v,c[a][d+1]−v,c[c+1][d+1]+v\\begin{aligned}\nsum(a, b, c, d, v) \\iff &amp; c[a][b] + v, c[c + 1][b] - v, \\\\\n&amp; c[a][d + 1] - v, c[c + 1][d + 1] + v\n\\end{aligned}\nsum(a,b,c,d,v)⟺​c[a][b]+v,c[c+1][b]−v,c[a][d+1]−v,c[c+1][d+1]+v​\n代码如下：\n#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, op;struct BIT &#123;  vector&lt;vector&lt;long long&gt;&gt; tr;    BIT() = default;    BIT(int n, int m) &#123;    tr.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));  &#125;    static int lowbit(int x) &#123;    return x &amp; (-x);  &#125;    void add(int x, int y, int value) &#123;    for (int i = x; i &lt;= n; i += lowbit(i))      for (int j = y; j &lt;= m; j += lowbit(j))        tr[i][j] += value;  &#125;    long long query(int x, int y) &#123;    long long retval = 0;    for (int i = x; i &gt; 0; i -= lowbit(i))      for (int j = y; j &gt; 0; j -= lowbit(j))        retval += tr[i][j];    return retval;  &#125;&#125; tr;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);    cin &gt;&gt; n &gt;&gt; m;    tr = BIT(n, m);    while (cin &gt;&gt; op) &#123;    if (op == 1) &#123;      int a, b, c, d, value;      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; value;            tr.add(a, b, value);      tr.add(a, d + 1, -value);      tr.add(c + 1, b, -value);      tr.add(c + 1, d + 1, value);    &#125; else if (op == 2) &#123;      int x, y;      cin &gt;&gt; x &gt;&gt; y;            cout &lt;&lt; tr.query(x, y) &lt;&lt; &#x27;\\n&#x27;;    &#125;  &#125;    return 0;&#125;\n区间修改，区间查询\n保留上面二维树状数组上区间加的操作，接下来看看如何实现区间查询。\n对于二维差分，我们有：\na[x][y]=∑i=0x∑j=0yd[i][j]a[x][y] = \\sum_{i = 0}^{x} \\sum_{j = 0}^{y} d[i][j]\na[x][y]=i=0∑x​j=0∑y​d[i][j]\n对于区间查询，我们用前缀和的思路转化为：\n∑i=ab∑j=cda[i][j]=sum[c][d]−sum[a−1][d]−sum[b−1][c]+sum[a−1][b−1];\\sum_{i = a}^b \\sum_{j = c}^d a[i][j] = sum[c][d] - sum[a - 1][d] - sum[b - 1][c] + sum[a - 1][b - 1];\ni=a∑b​j=c∑d​a[i][j]=sum[c][d]−sum[a−1][d]−sum[b−1][c]+sum[a−1][b−1];\n而对于二维前缀和，我们有：\nsum[a][b]=∑i=0a∑j=0b∑k=0i∑l=0jc[k][l]=∑i=0a∑j=0b(a−i+1)⋅(b−j+1)⋅c[i][j]=∑I=0a∑j=0b(ab−a−b+1)⋅c[i][j]−(b+1)⋅i⋅c[i][j]−(a+1)⋅j⋅c[i][j]+i⋅j⋅c[i][j]\\begin{aligned}\nsum[a][b] &amp;= \\sum_{i = 0}^{a} \\sum_{j = 0}^{b} \\sum_{k = 0}^{i} \\sum_{l = 0}^{j} c[k][l] \\\\\n&amp;= \\sum_{i = 0}^{a} \\sum_{j = 0}^b (a - i + 1) \\cdot (b - j + 1) \\cdot c[i][j] \\\\\n&amp;= \\sum_{I = 0}^{a} \\sum_{j = 0}^b (ab - a - b + 1) \\cdot c[i][j] - \n(b + 1) \\cdot i \\cdot c[i][j] - (a + 1) \\cdot j \\cdot c[i][j] + i \\cdot j \\cdot c[i][j]\n\\end{aligned}\nsum[a][b]​=i=0∑a​j=0∑b​k=0∑i​l=0∑j​c[k][l]=i=0∑a​j=0∑b​(a−i+1)⋅(b−j+1)⋅c[i][j]=I=0∑a​j=0∑b​(ab−a−b+1)⋅c[i][j]−(b+1)⋅i⋅c[i][j]−(a+1)⋅j⋅c[i][j]+i⋅j⋅c[i][j]​\n所以用四个二维树状数组分别维护 c[i][j]c[i][j]c[i][j]，i⋅c[i][ji \\cdot c[i][ji⋅c[i][j，j⋅c[i][j]j \\cdot c[i][j]j⋅c[i][j]，i⋅j⋅c[i][j]i \\cdot j \\cdot c[i][j]i⋅j⋅c[i][j] 就可以了。\n#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, op;struct BIT &#123;  vector&lt;vector&lt;long long&gt;&gt; t1, t2, t3, t4;    BIT() = default;  BIT(int n, int m) &#123;    t1.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));    t2.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));    t3.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));    t4.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));  &#125;    static int lowbit(int x) &#123;    return x &amp; (-x);  &#125;    void add(int x, int y, long long value) &#123;    for (int i = x; i &lt;= n; i += lowbit(i)) &#123;      for (int j = y; j &lt;= m; j += lowbit(j)) &#123;        t1[i][j] += value;        t2[i][j] += value * x;        t3[i][j] += value * y;        t4[i][j] += value * x * y;      &#125;    &#125;  &#125;    long long query(int x, int y) &#123;    long long retval = 0;    for (int i = x; i &gt; 0; i -= lowbit(i)) &#123;      for (int j = y; j &gt; 0; j -= lowbit(j)) &#123;        retval += (x + 1) * (y + 1) * t1[i][j] - (y + 1) * t2[i][j] - (x + 1) * t3[i][j] + t4[i][j];      &#125;    &#125;    return retval;  &#125;&#125; tr;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);    cin &gt;&gt; n &gt;&gt; m;    tr = BIT(n, m);    while (cin &gt;&gt; op) &#123;    if (op == 1) &#123;      int a, b, c, d;      long long value;      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; value;            tr.add(a, b, value);      tr.add(c + 1, b, -value);      tr.add(a, d + 1, -value);      tr.add(c + 1, d + 1, value);    &#125; else if (op == 2) &#123;      int a, b, c, d;      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;            long long ans = tr.query(c, d) - tr.query(a - 1, d) - tr.query(c, b - 1) + tr.query(a - 1, b - 1);            cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;    &#125;  &#125;    return 0;&#125;","categories":["集训总结（2025暑）"],"tags":["集训","数据结构"]},{"title":"OI集训 Day12","url":"/posts/5c259d7b/","content":"Content：模拟赛\nDate：2025.7.28\n\nProblem-A 排序\n题目大意\n优化程序：\n#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;const int N = 3e7 + 5;int n, seed;double a[N];void gen_input(const int n, const int seed) &#123;  double x = (double)(seed);  unsigned int iseed = seed;  for (int i = 0; i &lt; n; ++i) &#123;    iseed = iseed * 1664525 + 1013904223;    x = (std::sin(iseed % 4096) + 1) / 2;    a[i] = std::fabs(x * (iseed &gt;&gt; (iseed % 30))) + 1e-9;  &#125;&#125;int main() &#123;  std::cin &gt;&gt; n &gt;&gt; seed;  gen_input(n, seed);  // 你需要优化这行代码  std::sort(a, a + n);  double ans = 0;  for (int i = 0; i &lt; n; i++) &#123;    ans += a[i] * (i % 9);  &#125;  std::cout.precision(10);  std::cout &lt;&lt; std::fixed &lt;&lt; ans &lt;&lt; std::endl;  return 0;&#125;\n思路\n赛场上看到这道题目一脸懵，到底是哪个出题人出的题啊。\n赛后发现这道题其实考察的是浮点数。浮点数由于其特殊的存储特性，比较的常数是特别大的，但是将 double 类型转换为 long long 类型是不影响比较的，所以只需要添加一行代码：\nlong long *p = (long long *) (void *) a;sort(p, p + n);\n这里就是直接把 aaa 数组转换为 long long 类型进行比较。\nProblem-B 北京折叠\n赛时过了，就是一个模拟。\nProblem-C Git\n思路\n赛场上的贪心策略有问题，当时想的是将子树大小大的接到小的上面，这样做的操作次数会比把小的接到大的上面的操作次数少 (就是重链剖分的思路)。\n但是这道题要求是变成一条链，所以其答案一定和深度有关，不难发现将这棵树变为一条链的最小操作次数为 n−max⁡udep⁡(u)n - \\max_{u} \\operatorname{dep}(u)n−maxu​dep(u)。所以不应该以重链剖分的思路解这道题，而是长链剖分。其他的思路就和上面一样了。就是不断的把 uuu 的长链剖分意义下的重儿子接到任意一个轻儿子上 (选择的轻儿子变为下一次的重儿子)，不断重复这个操作，直到 uuu 不存在轻儿子。\nProblem-D 哈利波特魔法觉醒\n思路\n赛时考虑将每个区间的信息拆开来，即对于每个区间的每个端点维护信息，然后将其按位置排序，然后 O(n)O(n)O(n) 计算每个时间点的 kkk 连胜的概率。但是显然不是很好维护。赛时也想到了要 DP，但是状态定义为：dpidp_idpi​ 表示到第 iii 个时间的 kkk 连胜的概率，转移不好考虑。\n其实对于区间的信息可以 ==差分== 维护，再在 DP 的时候进行累加还原，即可获得获胜的概率 ppp。\n所以我们逆向思维，定义 dpidp_idpi​ 表示以 iii 结尾没有 kkk 连胜的概率。而这个转移比较好考虑。\ndpi={dpi−1−dpi−k−1×(1−pi−k)×∏j=0k−1pi−ji≥k1otherwisedp_i =\n\\begin{cases}\ndp_{i-1} - dp_{i-k-1} \\times (1-p_{i-k}) \\times \\prod_{j=0}^{k-1} p_{i-j} &amp; i \\ge k \\\\\n1 &amp; otherwise \\\\\n\\end{cases} \ndpi​={dpi−1​−dpi−k−1​×(1−pi−k​)×∏j=0k−1​pi−j​1​i≥kotherwise​\n即以时间 iii 结尾的没有 kkk 连胜的概率为前 i−k−1i-k-1i−k−1 个时刻里没有 kkk 连胜的概率乘上 111 减去区间 [i−k+1,i][i-k+1,i][i−k+1,i] 内恰好 kkk 连胜的概率。\n","categories":["集训总结（2025暑）"],"tags":["集训","模拟赛"]},{"title":"OI集训 Day10","url":"/posts/b22bfc57/","content":"Content：dp优化\nDate：2025.7.26\n\n例题\n洛谷-P1886 滑动窗口\n思路\n直接单调队列维护即可，具体操作如下：\n\n每次查看队尾的元素，维护单调性。\n对于队头不在当前滑动窗口的元素，弹出。\n\n提交记录：link\n洛谷-P2365 任务安排\n思路\n定义 dpidp_{i}dpi​ 表示第 iii 个任务完成所花费的最小代价。转移如下：\ndpi=min⁡1≤j≤idpj+(s+Ti−Tj−1)×(Fn−Fj−1)dp_{i} = \\min_{1 \\le j \\le i} dp_{j} + (s + T_i - T_{j-1}) \\times (F_{n} - F{j - 1})\ndpi​=1≤j≤imin​dpj​+(s+Ti​−Tj−1​)×(Fn​−Fj−1)\n对于本题数据范围 n≤3000n \\le 3000n≤3000，O(n2)O(n^2)O(n2) 可过。\n提交记录：link\n洛谷-P10979 任务安排 2\n思路\ndpdpdp 的方式和定义与前面相同，但是 O(n2)O(n^2)O(n2) 的复杂度无法接受，所以考虑优化。\n将 dpdpdp 的式子拆开，发现：\ndpi=min⁡1≤j≤idpj+FiTi−FjTi+Fns−Fjsdp_{i} = \\min_{1 \\le j \\le i} dp_{j} + F_{i}T_{i} - F_{j}T_{i} + F_{n}s - F_{j}s\ndpi​=1≤j≤imin​dpj​+Fi​Ti​−Fj​Ti​+Fn​s−Fj​s\n移项，得：\ndpj=(Ti+s)Fj+(dpi−FiTi−Fns)    dp_{j} = (T_{i} + s)F_{j} + (dp_{i} - F_{i}T_{i} - F_{n}s)\ndpj​=(Ti​+s)Fj​+(dpi​−Fi​Ti​−Fn​s)\n很明显可以用斜率优化，单调队列维护下凸壳即可。\n提交记录：link\n洛谷-P5785 [SDOI2012] 任务安排\n思路\n注意数据范围，∣Ti∣≤28\\lvert T_i \\rvert \\le 2^8∣Ti​∣≤28，所以 Ti+sT_{i}+sTi​+s 不具有单调性，所以上面面直接维护的方法不可做。于是我们考虑直接维护整个下凸壳，对于转移时，二分查找就可以了。\n提交记录：link\n洛谷-P4072 [SDOI2016] 征途\n思路\n我们定义 dpi,jdp_{i,j}dpi,j​ 表示到第 iii 天走到了第 jjj 个城市的最小平方和。之所以这样定义，是因为：\ns2×m2=∑i(si−s‾)2m×m2=(∑isim)2−2×∑isim×∑isi+∑isi2m×m2=−(∑isi)2+m×∑isi2\\begin{aligned}\ns^2 \\times m^2 &amp;= \\frac{\\sum_{i} (s_i - \\overline{s})^2}{m} \\times m^2 \\\\\n&amp;= \\frac{(\\frac{\\sum_i s_i}{m})^2 - 2 \\times \\frac{\\sum_i s_i}{m} \\times \\sum_i si + \\sum_i s_i^2}{m} \\times m^2 \\\\\n&amp;= -(\\sum_i s_i)^2 + m \\times \\sum_i s_i^2\n\\end{aligned}\ns2×m2​=m∑i​(si​−s)2​×m2=m(m∑i​si​​)2−2×m∑i​si​​×∑i​si+∑i​si2​​×m2=−(i∑​si​)2+m×i∑​si2​​\n所以最后的答案只和后面的平方和有关。\n转移还是单调队列维护下凸壳即可。\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训","DP","DP 优化"]},{"title":"OI集训 Day13","url":"/posts/2b22aded/","content":"Content：平衡树\nDate：2025.7.29\n\n具体内容\nLeafy Tree 和 Un-leafy Tree\nLeafy Tree：表示将所有的数据存放在叶子节点的树形数据结构，类似 线段树 和 WBLT 平衡树。\nUn-leafy Tree：与 Leafy Tree 相反，将数据存放在每个树节点的数据结构。\n替罪羊树\n替罪羊树是最简单的平衡树，也是 Un-leafy 的，其核心思想是定义一个常数 α\\alphaα，对于树上任意节点 uuu，若 max⁡(sizlsu,sizrsu)≥α×sizu\\max(siz_{ls_{u}}, siz_{rs_{u}}) \\ge \\alpha \\times siz_umax(sizlsu​​,sizrsu​​)≥α×sizu​，则将整棵树拍平成数组，对整棵树重构，使其保持平衡性。\n替罪羊树的复杂度是 O(nlog⁡n)O(n \\log n)O(nlogn) （均摊）的，同时 α\\alphaα 的取值对复杂度的影响是直接的，当 α\\alphaα 在区间 [0.5,1][0.5,1][0.5,1] 之间时，复杂度时最优的，一般取 α=0.7\\alpha = 0.7α=0.7。\nTreap\n旋转 Treap\n旋转 Treap 主要通过旋转来调整树的平衡。我们为每一个节点新加入一个键值 priorityprioritypriority。Treap 除了在维护平衡树的性质外，还要维护对于 priorityprioritypriority 的堆的性质。而这一部分的维护靠的就是旋转操作。\n复杂度：O(nlog⁡n)O(n \\log n)O(nlogn) （期望）\n无旋 Treap （FHQ-Treap）\n无旋 Treap （又称 FHQ-Treap）通过分裂和合并的方式来维护树的平衡性。每次按照一个阈值将树分为两个部分，然后对树进行操作后，将两个部分合并。由于其基本操作为分裂和合并，所以可以较为简单的处理区间问题，而且码量较小，但常数较大。\n复杂度：O(nlog⁡n)O(n \\log n)O(nlogn) （期望）\nSplay\nSplay 的基本操作为旋转 （双旋）每次将操作的节点旋转至根节点，所以每操作一次，树的形态都会发生改变。复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn) （均摊）\nWBLT (Weight Balanced Leafy Tree)\nWBLT 是一种 Leafy 的平衡树，将所有信息存储在叶子节点上。同替罪羊树，WBLT 也是依靠设立常数 α\\alphaα 来保证其平衡性，复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn) （严格）\n可持久化平衡树\n路径复制，肥节点。\n","categories":["集训总结（2025暑）"],"tags":["集训","平衡树","可持久化数据结构"]},{"title":"OI集训 Day14","url":"/posts/b546384e/","content":"Content：数论\nDate：2025.7.30\n\n课堂内容\n莫比乌斯函数\n定义如下：\nμ(n)={1n=1(−1)kn=p1p2p3…pk,∀pi∈P0otherwise\\mu(n) = \\begin{cases}\n1 &amp; n=1 \\\\\n(-1)^k &amp; n = p_1 p_2 p_3 \\dots p_k, \\forall p_i \\in P \\\\\n0 &amp; otherwise \\\\\n\\end{cases} \nμ(n)=⎩⎨⎧​1(−1)k0​n=1n=p1​p2​p3​…pk​,∀pi​∈Potherwise​\n其中莫比乌斯函数有如下性质：\n∑d∣nμ(d)=[n=1]\\sum_{d|n} \\mu(d) = [n=1]\nd∣n∑​μ(d)=[n=1]\n欧拉函数\n定义如下：\nφ(n)=∑i=1n[gcd(n,i)=1]\\varphi(n) = \\sum_{i=1}^n [gcd(n,i)=1]\nφ(n)=i=1∑n​[gcd(n,i)=1]\n其中欧拉函数具有如下性质：\n∑d∣nφ(d)=n\\sum_{d|n} \\varphi(d) = n\nd∣n∑​φ(d)=n\n莫比乌斯反演\n对于任意两个数论函数 f(n)f(n)f(n)，g(n)g(n)g(n)，有如下推导：\nf(n)=∑d∣ng(d)⇔g(n)=∑d∣nμ(d)f(nd)f(n) = \\sum_{d|n} g(d) \\Leftrightarrow g(n) = \\sum_{d|n} \\mu(d) f(\\frac{n}{d})\nf(n)=d∣n∑​g(d)⇔g(n)=d∣n∑​μ(d)f(dn​)\n例题\nLuogu-P2257 YY的GCD\n题意\n给定 nnn，mmm，求：\n∑i=1n∑j=1m[gcd(i,j)∈Prime]\\sum_{i=1}^n \\sum_{j=1}^m [gcd(i,j) \\in Prime]\ni=1∑n​j=1∑m​[gcd(i,j)∈Prime]\n思路\n课上没怎么听懂，自己推了下竟然推出来了。\n我们看到 [gcd(i,j)∈Prime][gcd(i,j) \\in Prime][gcd(i,j)∈Prime]，考虑从质数入手，可以枚举质数，这样式子化为：\n∑i=1n∑j=1m∑p∈Prime[gcd(ip,jp)=1]\\sum_{i=1}^n \\sum_{j=1}^m \\sum_{p \\in Prime} [gcd(\\frac{i}{p},\\frac{j}{p})=1]\ni=1∑n​j=1∑m​p∈Prime∑​[gcd(pi​,pj​)=1]\n把质数枚举提到前面去，得到：\n∑p∈Prime∑i=1n∑j=1m[gcd(ip,jp)=1]=∑p∈Prime∑i=1⌊np⌋∑j=1⌊mp⌋[gcd(i,j)=1]\\begin{aligned}\n&amp; \\sum_{p \\in Prime} \\sum_{i=1}^n \\sum_{j=1}^m [gcd(\\frac{i}{p}, \\frac{j}{p}) = 1] \\\\ \n=&amp; \\sum_{p \\in Prime} \\sum_{i=1}^{\\lfloor \\frac{n}{p} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{p} \\rfloor} [gcd(i,j) = 1]\n\\end{aligned}\n=​p∈Prime∑​i=1∑n​j=1∑m​[gcd(pi​,pj​)=1]p∈Prime∑​i=1∑⌊pn​⌋​j=1∑⌊pm​⌋​[gcd(i,j)=1]​\n对于后面一个埃德森括号，发现可以使用莫比乌斯函数的 ∑d∣nμ(d)=[n=1]\\displaystyle \\sum_{d|n} \\mu(d) = [n = 1]d∣n∑​μ(d)=[n=1] 这个性质，于是式子化为（这里钦定 n&lt;mn &lt; mn&lt;m）：\n∑p∈Prime∑i=1⌊np⌋∑j=1⌊mp⌋∑d∣gcd(i,j)μ(d)=∑p∈Prime∑d=1nμ(d)⌊npd⌋⌊mpd⌋\\begin{aligned}\n&amp; \\sum_{p \\in Prime} \\sum_{i=1}^{\\lfloor \\frac{n}{p} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{p} \\rfloor} \\sum_{d | gcd(i,j)} \\mu(d) \\\\\n=&amp; \\sum_{p \\in Prime} \\sum_{d=1}^{n} \\mu(d) \\lfloor \\frac{n}{pd} \\rfloor \\lfloor \\frac{m}{pd} \\rfloor\n\\end{aligned}\n=​p∈Prime∑​i=1∑⌊pn​⌋​j=1∑⌊pm​⌋​d∣gcd(i,j)∑​μ(d)p∈Prime∑​d=1∑n​μ(d)⌊pdn​⌋⌊pdm​⌋​\n令 pd=tpd = tpd=t，则：\n∑p∈Prime∑d=1nμ(d)⌊nt⌋⌊mt⌋\\begin{aligned}\n&amp; \\sum_{p \\in Prime} \\sum_{d=1}^n \\mu(d) \\lfloor \\frac{n}{t} \\rfloor \\lfloor \\frac{m}{t} \\rfloor \\\\\n\\end{aligned}\n​p∈Prime∑​d=1∑n​μ(d)⌊tn​⌋⌊tm​⌋​\n这时候这个和式就可以划分为两个互相独立的部分，所以：\n∑t=1n⌊nt⌋⌊mt⌋∑p∣t,p∈Primeμ(tp)\\begin{aligned}\n&amp; \\sum_{t=1}^n \\lfloor \\frac{n}{t} \\rfloor \\lfloor \\frac{m}{t} \\rfloor \\sum_{p | t, p \\in Prime} \\mu(\\frac{t}{p})\n\\end{aligned}\n​t=1∑n​⌊tn​⌋⌊tm​⌋p∣t,p∈Prime∑​μ(pt​)​\n前面一个和式可以整除分块，后面的可以前缀和，这样我们就做完啦~~~\n提交记录：link\nLuogu-P3455 ZAP-Queries\n题目大意\n给定 aaa，bbb 和 ddd，求：\n∑i=1a∑j=1b[gcd(i,j)=d]\\sum_{i=1}^{a} \\sum_{j=1}^b [gcd(i,j) = d]\ni=1∑a​j=1∑b​[gcd(i,j)=d]\n思路\n对于给定的式子，我们和第一题一样做如下变换：\n令 n=ad,m=bdn = \\frac{a}{d}, m = \\frac{b}{d}n=da​,m=db​，则\n∑i=1n∑j=1m[gcd(i,j)=1]=∑i=1n∑j=1m∑k∣gcd(i,j)μ(k)=∑k=1n∑i=1⌊nk⌋∑j=1⌊mk⌋μ(k)=∑k=1nμ(k)⌊nk⌋⌊mk⌋\\begin{aligned}\n&amp; \\sum_{i=1}^n \\sum_{j=1}^m [gcd(i,j) = 1] \\\\\n=&amp; \\sum_{i=1}^n \\sum_{j=1}^m \\sum_{k | gcd(i,j)} \\mu(k) \\\\\n=&amp; \\sum_{k=1}^n \\sum_{i=1}^{\\lfloor \\frac{n}{k} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{k} \\rfloor} \\mu(k) \\\\\n=&amp; \\sum_{k=1}^n \\mu(k) \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor\n\\end{aligned}\n===​i=1∑n​j=1∑m​[gcd(i,j)=1]i=1∑n​j=1∑m​k∣gcd(i,j)∑​μ(k)k=1∑n​i=1∑⌊kn​⌋​j=1∑⌊km​⌋​μ(k)k=1∑n​μ(k)⌊kn​⌋⌊km​⌋​\n所以又变回了第一题的整除分块加前缀和了。\n提交记录：link\nLuogu-P3327 约数个数和\n题目大意\n已知函数 d(n)d(n)d(n) 表示整数 nnn 的约数个数，给定 n,mn,mn,m 求：\n∑i=1n∑j=1md(ij)\\sum_{i=1}^n \\sum_{j=1}^m d(ij)\ni=1∑n​j=1∑m​d(ij)\n思路\n对于函数 d(n)d(n)d(n)，可以发现这是一个积性函数，但是不是一个完全积性函数，所以不能把 d(ij)d(ij)d(ij) 拆成 d(i)×d(j)d(i) \\times d(j)d(i)×d(j)。\n但是对于这个形式的函数 d(n)d(n)d(n)，我们可以根据定义发现另一个更优秀的性质：\nd(ij)=∑x∣i∑y∣j[gcd(x,y)=1]d(ij) = \\sum_{x|i} \\sum_{y|j} [gcd(x,y) = 1]\nd(ij)=x∣i∑​y∣j∑​[gcd(x,y)=1]\n通过枚举原来的 i,ji,ji,j，加上容斥，我们就可以把 d(ij)d(ij)d(ij) 写开来，这样有利于后面的变换。\n∑i=1n∑j=1md(ij)=∑i=1n∑j=1m∑x∣i∑y∣j[gcd(x,y)=1]=∑i=1n∑j=1m∑x∣i∑y∣j∑d∣gcd(x,y)μ(d)=∑x=1n∑y=1m⌊nx⌋⌊my⌋∑d∣gcd(x,y)μ(d)=∑d=1nμ(d)∑x=1⌊nd⌋∑y=1⌊md⌋⌊nx⌋⌊my⌋=∑d=1nμ(d)(∑x=1⌊nd⌋⌊nxd⌋)(∑y=1⌊md⌋⌊myd⌋)\\begin{aligned}\n    &amp; \\sum_{i=1}^n \\sum_{j=1}^m d(ij) \\\\\n    =&amp; \\sum_{i=1}^n \\sum_{j=1}^m \\sum_{x|i} \\sum_{y|j} [gcd(x,y) = 1] \\\\\n    =&amp; \\sum_{i=1}^n \\sum_{j=1}^m \\sum_{x|i} \\sum_{y|j} \\sum_{d|gcd(x,y)} \\mu(d) \\\\\n    =&amp; \\sum_{x=1}^n \\sum_{y=1}^m \\lfloor \\frac{n}{x} \\rfloor \\lfloor \\frac{m}{y} \\rfloor \\sum_{d|gcd(x,y)} \\mu(d) \\\\\n    =&amp; \\sum_{d=1}^n \\mu(d) \\sum_{x=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{y=1}^{\\lfloor \\frac{m}{d} \\rfloor} \\lfloor \\frac{n}{x} \\rfloor \\lfloor \\frac{m}{y} \\rfloor \\\\\n    =&amp; \\sum_{d=1}^n \\mu(d) (\\sum_{x=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\lfloor \\frac{n}{xd} \\rfloor) (\\sum_{y=1}^{\\lfloor \\frac{m}{d} \\rfloor} \\lfloor \\frac{m}{yd} \\rfloor )\n\\end{aligned}\n=====​i=1∑n​j=1∑m​d(ij)i=1∑n​j=1∑m​x∣i∑​y∣j∑​[gcd(x,y)=1]i=1∑n​j=1∑m​x∣i∑​y∣j∑​d∣gcd(x,y)∑​μ(d)x=1∑n​y=1∑m​⌊xn​⌋⌊ym​⌋d∣gcd(x,y)∑​μ(d)d=1∑n​μ(d)x=1∑⌊dn​⌋​y=1∑⌊dm​⌋​⌊xn​⌋⌊ym​⌋d=1∑n​μ(d)(x=1∑⌊dn​⌋​⌊xdn​⌋)(y=1∑⌊dm​⌋​⌊ydm​⌋)​\n令 f(x)=∑i=1n⌊ni⌋f(x) = \\displaystyle \\sum_{i=1}^n \\lfloor \\frac{n}{i} \\rfloorf(x)=i=1∑n​⌊in​⌋，则原式可以表达为：\n∑d=1nμ(d)f(⌊nd⌋)f(⌊md⌋)\\begin{aligned}\n\\sum_{d=1}^n \\mu(d) f(\\lfloor \\frac{n}{d} \\rfloor) f(\\lfloor \\frac{m}{d} \\rfloor)\n\\end{aligned}\nd=1∑n​μ(d)f(⌊dn​⌋)f(⌊dm​⌋)​\n对于 μ(d),f(n)\\mu(d), f(n)μ(d),f(n) 均可以预处理得到，剩下的就是整除分块了。\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训","数学"]},{"title":"OI集训 Day17","url":"/posts/2c4f69f4/","content":"Content：博弈论\nDate：2025.8.2\n\n课堂内容\nSG 函数\n表示当前游戏局面的函数，后手必胜当且仅当 SG 函数为 0。\n多个游戏的组合的 SG 函数为每个游戏的 SG 函数的 异或和。\n经典模型\n取石子游戏\n题目描述\n有 nnn 堆石子，A、B 轮流取，每次从任意一堆中取出至少一个石子，不能取的输，问谁赢。\n解法\n一堆大小为 nnn 的 SG 函数为 nnn，根据 SG 函数的性质，可以发现整个游戏的 SG 函数为 ⨂i=1nSGi\\displaystyle \\bigotimes_{i=1}^n SG_ii=1⨂n​SGi​。\n阶梯取石子游戏\n题目描述\n有 nnn 堆石子放在台阶上，A、B 轮流取，每次从任意一堆中取出至少一个石子，放到下一个台阶上（如果在第 1 个台阶，则扔掉），不能取的输，问谁赢。\n思路\n可以发现最后的答案之和奇数层的石子有关，所以整个游戏的 SG 函数为所有奇数层 SG 函数的异或和。\n树状取石子游戏\n题目描述\n在一颗大小为 nnn 的树上有 nnn 堆石子，A、B 轮流取，每次从任意一堆中取出至少一个石子，移动到他的父亲节点（如果在 1 号节点，则扔掉），不能取的输，问谁赢。\n思路\n跟上面的其实是一样的，只不过这里的答案只跟奇数层的节点的 SG 函数的异或和有关。\nBash 博弈\n题目描述\n有 nnn 堆石子，A、B 轮流取，每次从任意一堆中取出至少一个石子，至多取 mmm 个，不能取的输，问谁赢。\n思路\n每个石子堆的 SG 函数为 n mod (m+1)n \\bmod (m+1)nmod(m+1)，异或起来即可。\n1-动态减法游戏\n题目描述\n有一个正整数 nnn，A、B 轮流在上面减去一个数，第一个人至多减 n−1n-1n−1，后面每个人减的数不超过上一次的，最先吧这个数减到 0 的人获胜。问最后谁赢。\n思路\n先手每次都可以取原数的 lowbitlowbitlowbit（人类智慧），所以后手必胜当且仅当 n=2kn = 2^kn=2k。\n2-动态减法游戏\n题目描述\n有一个正整数 nnn，A、B 轮流在上面减去一个数，第一个人至多减 n−1n-1n−1，后面每个人减的数不超过上一次的 两倍 ，最先吧这个数减到 0 的人获胜。问最后谁赢。\n思路\n对原数进行斐波那契分解，先手每次取最低位的 1 （人类智慧 ×\\times× 2)，所以后手必胜当且仅当 nnn 为斐波那契数。\nk-动态减法游戏\n题目描述\n有一个正整数 nnn，A、B 轮流在上面减去一个数，第一个人至多减 n−1n-1n−1，后面每个人减的数不超过上一次的 kkk 倍，最先吧这个数减到 0 的人获胜。问最后谁赢。\n思路\n只需要一种满足任何表示方法中最低非零位的值的 kkk 倍小于次低非\n零位。\n每次将新加入的数设为前面的数能表示的最大值 +1+1+1 即可 （人类智慧 ×\\times× 3）。\nNimK 游戏\n题目大意\n有 nnn 堆石头，A、B 轮流取，每次从至多 kkk 堆中取出至少一个石头，不能取的输，问最后谁赢。\n思路\n求 SG 函数在 k+1k+1k+1 进制下的不进位加法。\nAnti-Nim 游戏\n题目大意\n同 普通取石子游戏规则，但是不能操作的人胜利。\n思路\n先手必胜的条件为：\n\nSG 函数的和为 0 且所有游戏的 SG 函数的值均不大于 1；\nSG 函数的和不等于 0 且至少一个游戏的 SG 函数值大于 1。\n\n例题\nAGC017-D Game On Tree\n思路\n对于每一个子树，其 SG 函数为所有子节点的 SG 函数加上一条边的状态，即 SGu=⨂v∈son(u)(SGv+1)\\displaystyle SG_u = \\bigotimes_{v \\in son(u)} (SG_v + 1)SGu​=v∈son(u)⨂​(SGv​+1)。\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训","博弈论"]},{"title":"OI集训 Day11","url":"/posts/c52cccc1/","content":"Content：矩阵 DP\nDate：2025.7.27\n\nReview\n矩阵基本操作：link\nExample1 - 洛谷-P1962 斐波那契数列\n题目描述\n给定 nnn，求斐波那契数列的第 nnn 项 fnf_nfn​。\nfn={1n=0,1fn−1+fn−2oterwisef_n = \n \\begin{cases}\n 1 &amp; n = 0,1 \\\\\n f_{n-1} + f_{n-2} &amp; oterwise\n \\end{cases}\nfn​={1fn−1​+fn−2​​n=0,1oterwise​\n数据范围：n&lt;263n &lt; 2^{63}n&lt;263。\n\n思路\n首先显然 O(n)O(n)O(n) 的递推是不行的了，我们考虑将递推式转化为矩阵乘法的形式：\n[fn−1fn−2]×[1101]=[fnfn−1][fn−2fn−3]×[1101]2=[fnfn−1]…[f0f1]×[1101]n−2=[fnfn−1]\\begin{aligned}\n\\begin{bmatrix}\nf_{n - 1} \\\\\nf_{n - 2}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n1 &amp; 1 \\\\\n0 &amp; 1 \\\\\n\\end{bmatrix}\n&amp;=\n\\begin{bmatrix}\nf_{n} \\\\\nf_{n - 1}\n\\end{bmatrix} \\\\\n\\\\\n\\begin{bmatrix}\nf_{n - 2} \\\\\nf_{n - 3}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n1 &amp; 1 \\\\\n0 &amp; 1 \\\\\n\\end{bmatrix}^2\n&amp;=\n\\begin{bmatrix}\nf_{n} \\\\\nf_{n - 1}\n\\end{bmatrix} \\\\\n\n&amp;\\dots \\\\\n\n\\begin{bmatrix}\nf_{0} \\\\\nf_{1} \\\\\n\\end{bmatrix}\n\n\\times \n\n\\begin{bmatrix}\n1 &amp; 1 \\\\\n0 &amp; 1\n\\end{bmatrix}^{n-2}\n\n&amp;=\n\n\\begin{bmatrix}\nf_{n}\nf_{n - 1}\n\\end{bmatrix}\n\n\\end{aligned}\n[fn−1​fn−2​​]×[10​11​][fn−2​fn−3​​]×[10​11​]2[f0​f1​​]×[10​11​]n−2​=[fn​fn−1​​]=[fn​fn−1​​]…=[fn​fn−1​​]​\n这里只需要矩阵快速幂即可。复杂度 O(logn)O(log n)O(logn)。\n提交记录：link\nExample2 - UVA11270 Tiling Dominoes\n\n题目描述\n给定一个 n×mn \\times mn×m 的网格，求用 1×21 \\times 21×2 的方块覆盖网格的方案数。\n数据范围：n×m≤100n \\times m \\le 100n×m≤100。\n\n思路\n我们考虑轮廓线 DP，定义 dpi,j,sdp_{i,j,s}dpi,j,s​ 表示当前修改的点是 (i,j)(i,j)(i,j)，其状态为 sss。这里的 sss 和之前题目里的不同，它表示的是第 iii 行的前 j−1j-1j−1 列的覆盖情况和第 i−1i - 1i−1 行的后 m−j+1m - j + 1m−j+1 列的覆盖情况，其中 000 表示还未被覆盖，111 表示已经被覆盖。\ndpdpdp 的第一维可以省略，所以转化为 dpi,sdp_{i,s}dpi,s​ 表示考虑到第 jjj 列，其状态为 sss 的方案数。\n接下来考虑转移，设上一行的状态为 sss，转移有三种。\n\n当前位置不放，留空 (前提条件：s&gt;&gt;j &amp; 1s &gt;&gt; j \\ \\&amp; \\ 1s&gt;&gt;j &amp; 1)：dpi−1,s→dpi,s⊕(1&lt;&lt;j)dp_{i-1,s} \\to dp_{i,s \\oplus (1 &lt;&lt; j)}dpi−1,s​→dpi,s⊕(1&lt;&lt;j)​\n当前位置横着放 (前提条件：j&gt;0j &gt; 0j&gt;0 且 s&gt;&gt;j &amp; 1s &gt;&gt; j \\ \\&amp; \\ 1s&gt;&gt;j &amp; 1)：dpi−1,s→dpi,s∣(1&lt;&lt;(j−1))dp_{i-1,s} \\to dp_{i,s | (1 &lt;&lt; (j - 1))}dpi−1,s​→dpi,s∣(1&lt;&lt;(j−1))​\n当前位置竖着放 (前提条件：i&gt;0i &gt; 0i&gt;0 且 !(s&gt;&gt;j&amp;1)!(s &gt;&gt; j \\&amp; 1)!(s&gt;&gt;j&amp;1))：dpi−1,s⊕(1&lt;&lt;j)→dpi,sdp_{i-1,s \\oplus (1 &lt;&lt; j)} \\to dp_{i, s}dpi−1,s⊕(1&lt;&lt;j)​→dpi,s​。\n\n这样就写完了。\nCode\n#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;constexpr int N = 105;int n, m;long long dp[2][1 &lt;&lt; 11];int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);        while (cin &gt;&gt; n &gt;&gt; m) &#123;        if (n &lt; m) std::swap(n, m);                int line = 0, max_status = 1 &lt;&lt; m;        std::memset(dp, 0, sizeof(dp));        dp[line][max_status - 1] = 1;                for (int i = 1; i &lt;= n; i++) &#123;            for (int j = 0; j &lt; m; j++) &#123;                line = !line;                std::memset(dp[line], 0, sizeof(dp[line]));                                for (int status = 0; status &lt; max_status; status++) &#123;                    if (status &gt;&gt; j &amp; 1) &#123;                        dp[line][status ^ (1 &lt;&lt; j)] += dp[!line][status];                    &#125;                    if (j &gt; 0 &amp;&amp; (status &gt;&gt; (j - 1) &amp; 1) == 0 &amp;&amp; (status &gt;&gt; j &amp; 1)) &#123;                        dp[line][status | (1 &lt;&lt; (j - 1))] += dp[!line][status];                    &#125;                    if (i &gt; 0 &amp;&amp; (status &gt;&gt; j &amp; 1) == 0) &#123;                        dp[line][status | (1 &lt;&lt; j)] += dp[!line][status];                    &#125;                &#125;            &#125;        &#125;                cout &lt;&lt; dp[line][max_status - 1] &lt;&lt; &#x27;\\n&#x27;;    &#125;        return 0;&#125;\nExample3 - 洛谷-P5678 河神\n思路\n我们一样考虑将递推式转化成矩阵乘法的形式。\n但是这里我们注意到地推中的操作是 ∣|∣ 和 &amp;\\&amp;&amp;，所以哦我们要做 (∣,&amp;)(|,\\&amp;)(∣,&amp;) 矩阵乘法 (这个需要证明 ∣|∣ 操作对 &amp;\\&amp;&amp; 操作具有分配律，这里就不证明了)。\n[an−1an−2an−3…an−k]×[bn−1bn−2bn−3…b1b0−100…000−10…00⋮⋮⋮⋱⋮⋮000…−10]=[anan−1an−2…an−k+1]\\begin{bmatrix}\na_{n - 1} &amp; a_{n-2} &amp; a_{n-3} &amp; \\dots &amp; a_{n-k}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nb_{n-1} &amp; b_{n - 2} &amp; b_{n - 3} &amp; \\dots &amp; b_1 &amp; b_0 \\\\\n-1 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 \\\\\n0 &amp; -1 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 \\\\\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\\n0 &amp; 0 &amp; 0 &amp; \\dots &amp; -1 &amp; 0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_n &amp; a_{n - 1} &amp; a_{n - 2} &amp; \\dots &amp; a_{n - k + 1}\n\\end{bmatrix}\n[an−1​​an−2​​an−3​​…​an−k​​]×​bn−1​−10⋮0​bn−2​0−1⋮0​bn−3​00⋮0​………⋱…​b1​00⋮−1​b0​00⋮0​​=[an​​an−1​​an−2​​…​an−k+1​​]\n所以就可以使用矩阵快速幂了。\n提交记录：link。\n","categories":["集训总结（2025暑）"],"tags":["集训","DP","数学","矩阵"]},{"title":"OI集训 Day18","url":"/posts/bcf07465/","content":"Content：构造\nDate：2025.8.3\n\n课堂内容\n完全图匹配构造\n描述\n对于一个 nnn （n∣2n \\mid 2n∣2） 个顶点的完全图，将其分为 n−1n-1n−1 个匹配。\n思路\n我们将其中一个点提出来，剩下的 n−1n-1n−1 个点形成一个正多边形，然后将提出的那个点放在中心。\n对于每一条 “斜率” 相同的边，我们把他们放在一个方案中，然后对这个方案进行旋转，就构造了 n−1n-1n−1 个匹配。\n\n完全图曼哈顿路构造\n描述\n对于一个包含 nnn 个点的完全图，要求将其分成 ⌊n/2⌋\\lfloor n / 2 \\rfloor⌊n/2⌋ 条曼哈顿路。\n思路\n\n\n当 n∣2n \\mid 2n∣2 时\n我们将这些点排成一个正 nnn 边形，然后做如下构造：\n\n还是通过第一个构造方案的旋转得出其他的方案。\n\n\n当 n∤2n \\nmid 2n∤2 时\n我们考虑通过上面的构造延伸，构造一个 正 (n−1)(n-1)(n−1) 边形，然后在中间加入一个点，把每一条曼哈顿路的起点和中点和这个点相连，就得到了 nnn 为奇数时的构造。下面是其中一条曼哈顿回路。\n\n\n\n后记\n今天晚上听了演唱会，所以别问我为什么现在才写。不过演唱会还挺好听的喵~\n","categories":["集训总结（2025暑）"],"tags":["集训","构造"]},{"title":"OI集训 Day19","url":"/posts/cbf744f3/","content":"Content：欢乐 ACM\nDate：2025.8.4\n\n内容\n休息一天喵o(〃＾▽＾〃)o~\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day16","url":"/posts/5b485962/","content":"Content：生成函数，多项式，期望\nDate：2025.8.1\n\n课堂内容\n生成函数\n定义\n\n普通生成函数（OGF）：普通生成函数的定义为形式幂级数：F(x)=∑iaixi\\displaystyle F(x) = \\sum_{i} a_i x^iF(x)=i∑​ai​xi\n指数生成函数（EGF）：指数生成函数的定义为形式幂级数：F(x)=∑iaixii!\\displaystyle F(x) = \\sum_{i} a_i \\frac{x^i}{i!}F(x)=i∑​ai​i!xi​\n\n普通生成函数的基本运算\n\nF(x)±G(x)=∑i(ai±bi)xi\\displaystyle F(x) \\pm G(x) = \\sum_{i} (a_i \\pm b_i) x^iF(x)±G(x)=i∑​(ai​±bi​)xi\nF(x)G(x)=∑nxn∑i=0naibn−i\\displaystyle F(x)G(x) = \\sum_{n} x^n \\sum_{i=0}^n a_i b_{n-i}F(x)G(x)=n∑​xni=0∑n​ai​bn−i​\n封闭形式。e.g.\n\nF(x)=∑n≥0xn=11−x\\displaystyle F(x) = \\sum_{n \\ge 0} x^n = \\frac{1}{1-x}F(x)=n≥0∑​xn=1−x1​\n证明：F(x)=1+x+x2+x3+⋯+xnxF(x)=x+x2+x3+x4+⋯+x(n+1)∴F(x)−xF(x)=1→F(x)=11−x\\begin{aligned}\n&amp; F(x) = 1 + x + x^2 + x^3 + \\dots + x^n \\\\\n&amp; xF(x) = x + x^2 + x^3 + x^4 + \\dots + x^(n+1) \\\\\n&amp; \\therefore F(x) - xF(x) = 1 \\to F(x) = \\frac{1}{1-x}\n\\end{aligned}\n​F(x)=1+x+x2+x3+⋯+xnxF(x)=x+x2+x3+x4+⋯+x(n+1)∴F(x)−xF(x)=1→F(x)=1−x1​​\n其他的普通生成函数也可以由这样的变换得到其封闭形式。\n\n\n\n指数生成函数的基本运算\nF(x)G(x)=∑i≥0aixii!∑j≥0bjxjj!=∑n≥0xn∑i=0n(ni)aibn−i1i!(n−i)!=∑n≥0xnn!∑i=0n(ni)aibn−i  \\begin{aligned}\n  F(x)G(x) &amp;= \\sum_{i \\ge 0} a_i \\frac{x^i}{i!} \\sum_{j \\ge 0} b_j \\frac{x^j}{j!} \\\\\n  &amp;= \\sum_{n \\ge 0} x^n \\sum_{i=0}^n \\binom{n}{i} a_i b_{n-i} \\frac{1}{i!(n-i)!} \\\\\n  &amp;= \\sum_{n \\ge 0} \\frac{x^n}{n!} \\sum_{i=0}^n \\binom{n}{i} a_i b_{n-i}\n  \\end{aligned}\nF(x)G(x)​=i≥0∑​ai​i!xi​j≥0∑​bj​j!xj​=n≥0∑​xni=0∑n​(in​)ai​bn−i​i!(n−i)!1​=n≥0∑​n!xn​i=0∑n​(in​)ai​bn−i​​\n即 F(x)G(x)F(x)G(x)F(x)G(x) 的结果是序列 ∑i=0n(ni)aibn−i\\displaystyle \\sum_{i=0}^n \\binom{n}{i} a_i b_{n-i}i=0∑n​(in​)ai​bn−i​ 的指数生成函数。\n例题\nLuogu-P10780 BZOJ3028 食物\n思路\n我们把每个食物的生成函数学出来再相乘，得到：\n(11−x2)(x+1)(x2+x+1)(x1−x2)(11−x4)(x3+x2+x+1)(x+1)(11−x3)=xx4−4x3+6x2−4x+1=x(x−1)4\\begin{aligned}\n&amp; (\\frac{1}{1-x^2})(x+1)(x^2+x+1)(\\frac{x}{1-x^2})(\\frac{1}{1-x^4})(x^3+x^2+x+1)(x+1)(\\frac{1}{1-x^3}) \\\\\n=&amp; \\frac{x}{x^4-4x^3+6x^2-4x+1} \\\\\n=&amp; \\frac{x}{(x-1)^4}\n\\end{aligned}\n==​(1−x21​)(x+1)(x2+x+1)(1−x2x​)(1−x41​)(x3+x2+x+1)(x+1)(1−x31​)x4−4x3+6x2−4x+1x​(x−1)4x​​\n展开后得到：\n∑n≥1n(n+1)(n+2)xn6\\sum_{n \\ge 1} \\frac{n(n+1)(n+2)x^n}{6}\nn≥1∑​6n(n+1)(n+2)xn​\n所以答案就为：n(n+1)(n+2)6\\displaystyle \\frac{n(n+1)(n+2)}{6}6n(n+1)(n+2)​.最后，注意取模。\n提交记录：link\nCodeForces-280C Game On Tree\n思路\n由于期望具有线性性：\nE(x+y)=E(x)+E(y)E(x+y) = E(x) + E(y)\nE(x+y)=E(x)+E(y)\n所以答案就是每个点被选中的概率之和。\n因为每个点被选中的概率只和这个点到根节点的长度为 dep(u)dep(u)dep(u) 的链有关（即 uuu 的祖先）。所以这个点被选中的概率即为 1dep(u)\\displaystyle \\frac{1}{dep(u)}dep(u)1​。答案即为：\n∑u1dep(u)\\sum_{u} \\frac{1}{dep(u)}\nu∑​dep(u)1​\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训","数学","生成函数","多项式","期望"]},{"title":"OI集训 Day21","url":"/posts/ee019f02/","content":"Content：字符串算法进阶\nDate：2025.8.6\n\nLuogu-P13270 最小表示法\n题意\n给定一个长度为 nnn 的字符串 sss，求 sss 的最小表示法。\n思路\n首先如果暴力的话，复杂度是 O(n2)O(n^2)O(n2) 的，但是我们发现如果我们当前已经发现了一个最小表示法，我们想要找到一个比这个还小的表示法，那么一定存在一个位置，使得这个位置上的字符不相等，根据这个就可以把复杂度优化到 O(n)O(n)O(n)。\n提交记录：Link。\nLuogu-P5357 AC自动机\n题意\n给定一个字符串 sss 和 nnn 个模式串 tit_iti​，求每个模式串在字符串 sss 中的出现次数。\n思路\n首先我们可以对 sss 建一个 AC 自动机，然后统计每个模式串在这个 AC 自动机的字典树上经过了那些节点，然后打标记。再建出 Fail 树，然后在 Fail 树上对标记求和。\n提交记录：Link。\n模拟题 - 嗑瓜子\n题意\n有一个人在嗑 nnn 个瓜子，每次在瓜子中等概率拿出一个，有以下两种情况：\n\n如果拿出的是瓜子，则吃掉，并把壳扔回瓜子中。\n如果拿出的是壳，则将其丢弃。\n求他吃掉所有瓜子的期望。\n\n思路\n定义 dpi,jdp_{i,j}dpi,j​ 表示有 iii 个瓜子和 jjj 个壳的期望。根据题意写出转移即可。\nImportant：注意空间，因为 jmaxj_{max}jmax​ 可以达到 2×n2 \\times n2×n，所以第二维要开到两倍。\nCode\n#include &lt;iostream&gt;#define OnlineJudgeusing std::cin;using std::cout;constexpr int MOD = 998244353;constexpr int N = 4005;    // ! 注意两倍空间long long dp[N][N];long long QuickPow(long long base, long long pow) &#123;    long long result = 1;    while (pow) &#123;        if (pow &amp; 1) result = result * base % MOD;        base = base * base % MOD;        pow &gt;&gt;= 1;    &#125;    return result;&#125;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);        int n;    cin &gt;&gt; n;        dp[n][0] = 1;        for (int i = n - 1; i &gt;= 0; i--) &#123;        for (int j = (n - i) * 2; j &gt;= (i == 0 ? 2 : 0); j--) &#123;            if (i == 0) &#123;                dp[i][j] = QuickPow(j - 1, MOD - 2) * dp[i + 1][j - 2] % MOD;            &#125; else &#123;                if (j &lt; 2) &#123;                    dp[i][j] = (j + 1) * QuickPow(i + j + 1, MOD - 2) % MOD * dp[i][j + 1] % MOD;                &#125; else if (j == (n - i) * 2) &#123;                    dp[i][j] = (i + 1) * QuickPow(i + j - 1, MOD - 2) % MOD * dp[i + 1][j - 2] % MOD;                &#125; else &#123;                    dp[i][j] = ((i + 1) * QuickPow(i + j - 1, MOD - 2) % MOD * dp[i + 1][j - 2] % MOD + (j + 1) * QuickPow(i + j + 1, MOD - 2) % MOD * dp[i][j + 1] % MOD) % MOD;                &#125;            &#125;        &#125;    &#125;        #ifndef OnlineJudge    for (int i = 0; i &lt;= n; i++) &#123;        for (int j = 0; j &lt;= 2 * (n - i); j++) &#123;            cout &lt;&lt; dp[i][j] &lt;&lt; &#x27; &#x27;;        &#125;        cout &lt;&lt; &#x27;\\n&#x27;;    &#125;    #endif        long long answer = 0;    for (int i = 1; i &lt;= n * 2; i++) &#123;        answer = (answer + (3 * n - i) * dp[0][i] % MOD) % MOD;    &#125;        cout &lt;&lt; answer &lt;&lt; &#x27;\\n&#x27;;        return 0;&#125;\n","categories":["集训总结（2025暑）"],"tags":["集训","字符串"]},{"title":"OI集训 Day15","url":"/posts/c24108d8/","content":"Content：组合数学\nDate：2025.7.31\n\n课堂内容\n容斥原理\n其主要思想为：把禁止违反哪些规则改为钦定违反了哪几条规则，并赋予 (−1)k(-1)^k(−1)k （即违反 kkk 条规则）的容斥系数。\n二项式反演\ng(n)=∑i=0n(ni)f(i)⇔f(n)=∑i=0n(−1)n−i(ni)g(i)g(n)=∑i=nN(in)f(i)⇔f(n)=∑i=nN(−1)i−n(in)g(i)\\begin{aligned}\ng(n) &amp;= \\sum_{i=0}^n \\binom{n}{i} f(i) \\Leftrightarrow f(n) = \\sum_{i=0}^n (-1)^{n-i} \\binom{n}{i} g(i) \\\\\ng(n) &amp;= \\sum_{i=n}^N \\binom{i}{n} f(i) \\Leftrightarrow f(n) = \\sum_{i=n}^N (-1)^{i-n} \\binom{i}{n} g(i)\n\\end{aligned}\ng(n)g(n)​=i=0∑n​(in​)f(i)⇔f(n)=i=0∑n​(−1)n−i(in​)g(i)=i=n∑N​(ni​)f(i)⇔f(n)=i=n∑N​(−1)i−n(ni​)g(i)​\n例题\nLuogu-P1450 [HAOI2018] 硬币购物\n题目大意\n给定硬币面值 c1,c2,c3,c4c_1, c_2, c_3, c_4c1​,c2​,c3​,c4​ 和硬币个数 d1,d2,d3,d4d_1, d_2, d_3, d_4d1​,d2​,d3​,d4​，求恰好凑齐 sss 元的方案数。TTT 组询问。\n思路\n首先我们可以对硬币做完全背包，这样我们就知道了用这些硬币可以凑出那些。\n然后带上限制条件，做容斥即可。\n提交记录：link\nAGC005D ~K Perm Counting\n题目大意\n给定 N,KN,KN,K，求所有满足 ∣ai−i∣≠k|a_i - i| \\ne k∣ai​−i∣=k 的长度为 NNN 的排列的个数。\n思路\n参考 Dreamunk 大佬的题解。将所有的不合法的情况之间连边，我们就得到了若干条不合法的链，对这些链进行 DP 后，就可以容斥了。\n提交记录：link\n最后的最后，还是要说一句 我恨计数\n","categories":["集训总结（2025暑）"],"tags":["集训","数学","组合数","容斥"]},{"title":"OI集训 Day20","url":"/posts/9906af94/","content":"Content：字符串\nDate：2025.8.5\n\n课堂内容\n字符串哈希\n定义哈希函数 H(s)H(s)H(s):\nH(s)=∑i=1nbasen−isi mod PH(s) = \\sum_{i=1}^n base^{n-i} s_i \\bmod P\nH(s)=i=1∑n​basen−isi​modP\n其中 basebasebase 大于字符集大小。这个哈希函数的冲突概率为 1P\\frac{1}{P}P1​。\n通过这个定义，我们可以通过前缀和处理，得到这个字符串上每个区间的哈希值。\n树哈希 （重点）\n定义哈希函数 H(u)H(u)H(u)，表示以 uuu 为根节点的子树的哈希值。\nH(u)=∑iH(son(u,i))1+∑j&lt;i2×size(son(u,j))+1+2×base2×size(u)−1H(u) = \\sum_{i} H(son(u, i))^{1 + \\sum_{j&lt;i} 2 \\times size(son(u, j))} + 1 + 2 \\times base^{2 \\times size(u) - 1}\nH(u)=i∑​H(son(u,i))1+∑j&lt;i​2×size(son(u,j))+1+2×base2×size(u)−1\n其中 son(u,i)son(u, i)son(u,i) 表示 uuu 的第 iii 个儿子，size(u)size(u)size(u) 表示以 uuu 为根节点的子树的大小。\n字典树\n字典树就没什么好讲的了，注意一下 0/1 字典树就行。\n","categories":["集训总结（2025暑）"],"tags":["集训","字符串","哈希","字典树"]},{"title":"OI集训 Day22","url":"/posts/7708ceb8/","content":"Content：字符串进阶-2\nDate：2025.8.7\n\n课堂内容\n后缀数组\n后缀数组主要指两个数组 sasasa 和 rankrankrank：\n\nsaisa_isai​ 表示所有后缀中按字典序大小从小到大排序后排名为 iii 的后缀的起始位置。\nrankirank_iranki​ 表示以 iii 为起始位置的后缀的排名。\n\n其中这两个数组有如下性质：\nsaranki=ranksai=isa_{rank_i} = rank_{sa_i} = i\nsaranki​​=ranksai​​=i\n可以使用倍增 + 基数排序的方式求解 sasasa 和 rankrankrank 数组，复杂度 O(nlog⁡n)O(n \\log n)O(nlogn)。\n除此之外，还有一个 heightheightheight 数组表示 saisa_isai​ 和 sai−1sa_{i-1}sai−1​ 两个后缀的 LCP (Longest Common Prefix) 的长度。\n模版题：Luogu-P10469 后缀数组\n提交记录：Link\n例题\nLuogu-P3809 后缀排序\n题目大意\n给定一个长度为 nnn 的仅由小写字母组成的字符串，将其所有后缀按字典序从小到大排序后，求排名为 iii 的后缀的起始位置。\n思路\n就是后缀数组的简单应用，求出 sasasa 数组后输出即可。注意下标的问题。\n提交记录：Link\n","categories":["集训总结（2025暑）"],"tags":["集训","字符串","后缀数组（SA）"]},{"title":"OI集训 Day2","url":"/posts/945e15/","content":"Content：Segment Tree\nDate：2025.7.18\n\n主题\n\n线段树进阶\n\n关于线段树\n区间操作\n\n对于区间开根号我们可以记录最大值和最小值，然后维护极差，由此将区间开根号转化为区间加和区间覆盖问题，减小修改操作的复杂(度，均摊后复杂度为 Θ(nlog⁡nlog⁡2V)\\Theta(n \\log n \\log^2 V)Θ(nlognlog2V)。（题目：HDU 5828）\n对于区间取模的操作，我们依然记录最大值，对于 max&lt;Pmax &lt; Pmax&lt;P 的区间不做修改，从而降低复杂度。（题目：CodeForces 438D）\n对于区间 gcdgcdgcd 操作，我们可以对原数组进行差分，得到差分数组 ddd，而区间 [l,r][l, r][l,r] 的 gcdgcdgcd 即为 gcd(al,dl+1,dl+2,…,dr)gcd(a_l, d_{l + 1}, d_{l + 2}, \\dots, d_{r})gcd(al​,dl+1​,dl+2​,…,dr​)。（题目：洛谷 P10463）\n\n二维数点问题\n\n二维数点问题是在一个平面中，有若干个点 (xi,yi)(x_i, y_i)(xi​,yi​)，询问你在矩形 (a,b)(a, b)(a,b)，(c,d)(c, d)(c,d) 中包括了多少个点。\n离线后的二维数点问题可以用线段树扫描线解决，相当于在线的主席树。\n题目：CodeForces 1221F。\nCode:\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5, M = 1e6 + 5;int n;vector&lt;int&gt; pos;vector&lt;pair&lt;int, int&gt;&gt; a[M];class Point &#123; public:  int x, y, w;&#125; points[N];class SegmentTree &#123;  class Values &#123;   public:    long long max, add;    int index;  &#125;;    class Node &#123;   public:    int left, right;    Values val;        Node() = default;    Node(int l, int r) : left(l), right(r), val() &#123;&#125;  &#125;;    Node tr[M &lt;&lt; 2];    static int get_lc(int k) &#123; return k &lt;&lt; 1; &#125;  static int get_rc(int k) &#123; return k &lt;&lt; 1 | 1; &#125;  int get_mid(int k) &#123; return (tr[k].left + tr[k].right) &gt;&gt; 1; &#125;    void make_lazy_add(int k, long long val) &#123;    tr[k].val.add += val;    tr[k].val.max += val;  &#125;    void push_up(int k) &#123;    int lc = get_lc(k), rc = get_rc(k);        if (tr[lc].val.max &gt; tr[rc].val.max) &#123;      tr[k].val.max = tr[lc].val.max;      tr[k].val.index = tr[lc].val.index;    &#125; else &#123;      tr[k].val.max = tr[rc].val.max;      tr[k].val.index = tr[rc].val.index;    &#125;  &#125;    void push_down(int k) &#123;    if (tr[k].val.add == 0)      return void();        int lc = get_lc(k), rc = get_rc(k);        make_lazy_add(lc, tr[k].val.add);    make_lazy_add(rc, tr[k].val.add);        tr[k].val.add = 0;  &#125;   public:  void build_tree(int k, int l, int r) &#123;    tr[k] = Node(l, r);        if (tr[k].left == tr[k].right) &#123;      tr[k].val.max = -pos[l - 1];      tr[k].val.index = l;      return void();    &#125;        int mid = get_mid(k);    int lc = get_lc(k), rc = get_rc(k);        build_tree(lc, l, mid);    build_tree(rc, mid + 1, r);        push_up(k);  &#125;    void modify(int k, int l, int r, int val) &#123;    if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;      make_lazy_add(k, val);      return void();    &#125;        push_down(k);        int mid = get_mid(k);    int lc = get_lc(k), rc = get_rc(k);        if (r &lt;= mid) &#123;      modify(lc, l, r, val);    &#125; else if (l &gt; mid) &#123;      modify(rc, l, r, val);    &#125; else &#123;      modify(lc, l, mid, val);      modify(rc, mid + 1, r, val);    &#125;        push_up(k);  &#125;    pair&lt;long long, long long&gt; query(int k, int l, int r) &#123;    if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;      return make_pair(tr[k].val.max, tr[k].val.index);    &#125;        push_down(k);        int mid = get_mid(k);    int lc = get_lc(k), rc = get_rc(k);        if (r &lt;= mid) &#123;      return query(lc, l, r);    &#125; else if (l &gt; mid) &#123;      return query(rc, l, r);    &#125; else &#123;      return max(query(lc, l, mid), query(rc, mid + 1, r));    &#125;  &#125;&#125; seg;int get_index(int val) &#123;  return lower_bound(pos.begin(), pos.end(), val) - pos.begin() + 1;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++) &#123;    cin &gt;&gt; points[i].x &gt;&gt; points[i].y &gt;&gt; points[i].w;        pos.emplace_back(points[i].x);    pos.emplace_back(points[i].y);        if (points[i].x &gt; points[i].y) &#123;      swap(points[i].x, points[i].y);    &#125;  &#125;    sort(pos.begin(), pos.end());  pos.erase(unique(pos.begin(), pos.end()), pos.end());    int limit = 0;  for (int i = 1; i &lt;= n; i ++) &#123;    points[i].x = get_index(points[i].x);    points[i].y = get_index(points[i].y);        limit = max(limit, points[i].y);        a[points[i].x].emplace_back(points[i].y, points[i].w);  &#125;    seg.build_tree(1, 1, limit);    long long answer = -1ll &lt;&lt; 60, left = 0, right = 0;  for (int line = limit; line &gt;= 1; line --) &#123;    for (auto p : a[line]) &#123;      seg.modify(1, p.first, limit, p.second);    &#125;        pair&lt;long long, long long&gt; result = seg.query(1, line, limit);    result.first += pos[line - 1];        if (result.first &gt; answer) &#123;      answer = result.first;      left = pos[line - 1];      right = pos[result.second - 1];    &#125;  &#125;    if (answer &lt; 0) &#123;    answer = 0;    left = 1e9 + 1, right = 1e9 + 1;  &#125;    cout &lt;&lt; answer &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n线段树分治\n\n线段树分治问题，即在线段树上进行递归，依据线段树的结构性质完成的一类问题。\n这类问题的特点是：具有明显的前后/时间关系，且删除操作不易实现，但插入操作可以较容易的实现。\n题目：洛谷 P5787\nCode:\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;bool satisfied[N];int n, m, k, u, v, l, r;class DSU &#123;  int fa[N &lt;&lt; 1], size[N &lt;&lt; 1];  stack&lt;pair&lt;int *, int&gt;&gt; stk; public:  void init(int limit) &#123;    for (int i = 1; i &lt;= limit; i++) fa[i] = i, size[i] = 1;  &#125;  int find(int x) &#123;    if (fa[x] != x) return find(fa[x]);    return x;  &#125;  void merge(int u, int v) &#123;    u = find(u);    v = find(v);    if (u == v) return void();    if (size[u] &gt; size[v]) swap(u, v);    stk.emplace(fa + u, fa[u]);    stk.emplace(size + v, size[v]);    fa[u] = v;    size[v] += size[u];  &#125;  bool check(int x, int y) &#123; return find(x) == find(y); &#125;  int get_version() &#123; return stk.size(); &#125;  void undo(int version) &#123;    while (stk.size() &gt; version) &#123;      *stk.top().first = stk.top().second;      stk.pop();    &#125;  &#125;&#125; d;class SegmentTree &#123;  class Node &#123;   public:    int left, right;    vector&lt;pair&lt;int, int&gt;&gt; edges;    Node() = default;    Node(int l, int r) : left(l), right(r) &#123; edges.clear(); &#125;  &#125;;  Node tr[N &lt;&lt; 2];  static int get_lc(int k) &#123; return k &lt;&lt; 1; &#125;  static int get_rc(int k) &#123; return k &lt;&lt; 1 | 1; &#125;  int get_mid(int k) &#123; return (tr[k].left + tr[k].right) &gt;&gt; 1; &#125; public:  void build_tree(int k, int l, int r) &#123;    tr[k] = Node(l, r);    if (tr[k].left == tr[k].right) &#123;      return void();    &#125;    int mid = get_mid(k);    int lc = get_lc(k), rc = get_rc(k);    build_tree(lc, l, mid);    build_tree(rc, mid + 1, r);  &#125;  void add_edge(int k, int l, int r, pair&lt;int, int&gt; edge) &#123;    if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;      tr[k].edges.emplace_back(edge);      return void();    &#125;    int mid = get_mid(k);    int lc = get_lc(k), rc = get_rc(k);    if (r &lt;= mid) &#123;      add_edge(lc, l, r, edge);    &#125; else if (l &gt; mid) &#123;      add_edge(rc, l, r, edge);    &#125; else &#123;      add_edge(lc, l, mid, edge);      add_edge(rc, mid + 1, r, edge);    &#125;  &#125;  void dfs(int k) &#123;    bool flag = true;    int version = d.get_version();    for (auto edge : tr[k].edges) &#123;      if (d.check(edge.first, edge.second)) &#123;        flag = false;        break;      &#125; else &#123;        d.merge(edge.first, edge.second + n);        d.merge(edge.first + n, edge.second);      &#125;    &#125;    if (flag == false) &#123;      for (int i = 1; i &lt;= tr[k].right - tr[k].left + 1; i++) &#123;        cout &lt;&lt; &quot;No\\n&quot;;      &#125;    &#125; else &#123;      if (tr[k].left == tr[k].right) &#123;        cout &lt;&lt; &quot;Yes\\n&quot;;      &#125; else &#123;        int lc = get_lc(k), rc = get_rc(k);        dfs(lc);        dfs(rc);      &#125;    &#125;    d.undo(version);  &#125;&#125; seg;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout.tie(nullptr);  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;  d.init(n &lt;&lt; 1);  seg.build_tree(1, 1, k);  for (int i = 1; i &lt;= m; i++) &#123;    cin &gt;&gt; u &gt;&gt; v &gt;&gt; l &gt;&gt; r;    if (l == r) continue;    seg.add_edge(1, l + 1, r, make_pair(u, v));  &#125;  seg.dfs(1);  return 0;&#125;\n","categories":["集训总结（2025暑）"],"tags":["集训","线段树"]},{"title":"OI集训 Day23","url":"/posts/7708ceb8/","content":"Content：交互、通信、提交答案题\nDate：2025.8.8\n\n题目\nCodeForces-P1672E notepad.exe\n题目大意\n交互题。\n有 nnn 个长度分别为 lil_ili​ 的单词，要求将这些单词排放在一个记事本当中，每两个单词之间需要空格（换行不需要）。你最多可以询问 n+30n+30n+30 次，每次可以询问一个宽度 www，裁判会告诉你至少需要高度为 hhh 的记事本才可以放下所有的单词，求 min⁡{hw}\\min\\{ hw \\}min{hw}。\n思路\n考虑先用 30 次找出将所有单词放在一行所需的最少宽度 w0w_0w0​，然后对于每一个 1≤i≤n1 \\le i \\le n1≤i≤n，询问排列成 iii 行需要的最少行数，询问次数正好 n+30n + 30n+30 次。\n提交记录：Link\nCodeForces-1010B Rocket\n题目大意\n交互题。\n你可以问裁判 60 次问题，裁判会根据一个循环节长度为 nnn 的数组回答你的问题：如果 ai=0a_i = 0ai​=0，则第 iii 次回答的是假话；如果 ai=1a_i = 1ai​=1，则第 iii 次回答的是真话。你并不知道这个数组 aaa。你需要猜一个数 x(1≤x≤m)x (1 \\le x \\le m)x(1≤x≤m)。每次询问你可以问裁判一个数，他会回答你这个数是 大于(1)、等于(0)、小于(-1)（遵守之前的规则）。\n思路\n首先范围 m≤109&lt;230m \\le 10^9 &lt; 2^{30}m≤109&lt;230，所以我们可以先用 30 次机会，每次询问 1，就可以得到数组 aaa。然后二分答案 xxx 就可以了，总询问次数为 60 次。\n提交记录：Link\nLuogu-P1337 平衡点 / 吊打 XXX\n题目大意\n求 nnn 个点的带权费马点。\n思路\n考虑使用模拟退火，随机检查，剩下的就交给阳寿吧（WA ×\\times× 6）。\n提交记录：Link\nLuogu-P5285 [十二省联考] 骗分过样例\n写这道题上来只是小小的心灵受到了大大的震撼。怎么做到再 202020 组数据中找规律的啊！\n","categories":["集训总结（2025暑）"],"tags":["集训","交互题","通信题","提交答案"]},{"title":"OI集训 Day24","url":"/posts/9e6b6b8d/","content":"Content：模拟赛\nDate：2025.8.9\n\nProblem-A IEEE 754\n题目描述\n题目背景告诉你浮点数表示法(IEEE 754 标准)，要求你求 5n5^n5n，其中 n&lt;1024n &lt; 1024n&lt;1024。\n思路\n赛场上是直接写的高精度，但是赛后看过题解发现有更简单的做法。\n首先用 Python 计算发现，510235^102351023 大约有 800 位，而 double 类型的存储精度有 308 位，所以可以用 double 类型计算，但是要计算的是 5(−n)5^(-n)5(−n)，因为是浮点数。\n提交记录：Link\nProblem-B 探险\n题目描述\n给定一个数组 aaa，有两个人轮流操作，每次交换一对 i,ji,ji,j，谁进行操作后数组 aaa 有序（从小到大），则这个人获胜。同时有 qqq 个修改操作，分为两类：\n\n111 iii jjj：将 aia_iai​ 与 aja_jaj​ 交换。\n222 kkk：将 aaa 循环位移 kkk 次。\n你需要对于初始状态和每一个修改后的状态，判断是先手获胜还是后手获胜。\n\n思路\n赛场上想到了逆序对，但是时间比较少，只剩 151515 分钟了，而且最后开的这道题，所以脑子不太好使，就没有想出来。\n赛后发现赛时的思路大致是对的，但是没有继续思考下去。容易发现答案和逆序对个数的奇偶性有关，具体来说：\n\n当逆序对个数为 奇数 时，先手获胜；\n当逆序对个数为 偶数 时，后手获胜\n所以问题落在了如何处理修改后的逆序对变化。\n\n对于第一个操作是好求的，因为交换两个数，逆序对个数的奇偶性就会变化。而对于第二个操作，可以发现每一个跨过 kkk 的两个数的逆序对都会反过来，所以对答案的影响就是 k(n−k) mod 2k(n-k) \\bmod 2k(n−k)mod2（赛时就是这里没有想出来）。\n提交记录：Link\nProblem-C 帕奇欧\n题目描述\n初始时，你手上有 1 张 A 类牌和 1 张 B 类牌。每一回合你都可以从拥有的牌中等概率选取一张，然后获得一张与抽取出来的牌同类型的牌，问你经过无限轮操作后，拥有 xxx 张 A 类牌和 yyy 张 B 类牌的概率，对 109+710^9 + 7109+7 取模。\n思路\n手玩一下样例可以发现，答案为 (x+y−3)!∗(x+y−2)(x+y−1)\\frac{(x + y - 3)! * (x + y - 2)}{(x + y - 1)}(x+y−1)(x+y−3)!∗(x+y−2)​ (这是赛时没化简得结果)。\n化简后是 1x+y−1\\frac{1}{x + y - 1}x+y−11​。\n提交记录：Link\nProblem-D 比赛\n题目描述\n有一种比赛，每一次比赛有若干个小节，率先得到 MMM 分得人赢下这个小节。给定 x,y,Mx,y,Mx,y,M，求最后总分为 x,yx,yx,y 时不同得小节数。\n思路\n赛时推了下式子，没推出来 TAT。\n首先可以发现的是，满足题目要求得小节数是一段连续的区间。\n所以我们可以分别找到这个区间的上界和下界。容易发现上界为 ⌊xM⌋+⌊yM⌋\\lfloor \\frac{x}{M} \\rfloor + \\lfloor \\frac{y}{M} \\rfloor⌊Mx​⌋+⌊My​⌋。而下界通过分析可以发现是 max⁡(⌈x−txM⌉,⌈y−tyM⌉,⌈x+yM−1⌉)\\max(\\lceil \\frac{x - tx}{M} \\rceil, \\lceil \\frac{y - ty}{M} \\rceil, \\lceil \\frac{x + y}{M - 1} \\rceil)max(⌈Mx−tx​⌉,⌈My−ty​⌉,⌈M−1x+y​⌉)，其中 tx=⌊xM⌋,ty=⌊yM⌋tx = \\lfloor \\frac{x}{M} \\rfloor, ty = \\lfloor \\frac{y}{M} \\rfloortx=⌊Mx​⌋,ty=⌊My​⌋。\n提交记录：Link\nProblem-E 三目运算符\n题目描述\n给定一个只包含 0,1,x,?,:0,1,x,?,:0,1,x,?,: 的合法三目运算符表达式，你可以将其中的 xxx 替换为 0/1，求所有表达式的值的和对 109+710^9 + 7109+7 取模的结果。\n思路\n赛时直接枚举 xxx 的取值，竟然有 80pts 的暴力分，出题人还是太良心了。\n正解是考虑和表达式树一样的结果，即对于每个节点，都有走向 0/1 的两条路，问题转化为了走向值为 1 的叶子节点的概率。\n提交记录：Link\nProblem-F 卡牌游戏\n题目描述\n你有三种不同类型的卡牌，其中每种卡牌的数量由给定的字符串决定。同时你拥有两个数组 A,BA,BA,B，你需要从卡牌中选取恰好 kkk 张，设你选择的三种卡牌的数量分别为 x,y,zx,y,zx,y,z，则你的得分为 Ax×By×2zA_x \\times B_y \\times 2^zAx​×By​×2z。求最大得分。\n思路\n赛时直接枚举前两种卡牌的个数，得了 20 分。\n可以发现第三种卡牌的贡献最大。设最多能选 ttt 张第三种卡牌，则所有 z&lt;t−60z &lt; t-60z&lt;t−60 的方案均更差。即使 Ax,ByA_x,B_yAx​,By​ 的值从 109×10910^9 \\times 10^9109×109 变为了 1×11 \\times 11×1，即变为原来的 11018\\frac{1}{10^{18}}10181​，而 260&gt;10182^60 &gt; 10^{18}260&gt;1018，所以变化后的结果依然更优，所以只要考虑 t−60≤z≤tt - 60 \\le z \\le tt−60≤z≤t 的方案即可。\n提交记录：先欠着吧。\n","categories":["集训总结（2025暑）"],"tags":["集训","模拟赛"]},{"title":"OI集训 Day26","url":"/posts/70650aa1/","content":"Content：图论\nDate：2025.8.11\n\n课堂内容\n差分约束\nProblem\n给定一个包含 nnn 个不等式的不等式组，要求求出这个不等式组的任意一组解，或者判断不等式组无解。\nSolution\n对于给定的这个问题，整理一下，发现要求解：\n{x1−x2&gt;c1x2−x3&gt;c2x3−x4&gt;c3…xn−x1&gt;cn⇒{x1&gt;x2+c1x2&gt;x3+c2x3&gt;x4+c3…xn&gt;x1+cn\\begin{cases}\nx_1 - x_{2} &gt; c_{1} \\\\\nx_{2} - x_{3} &gt; c_{2} \\\\\nx_{3} - x_{4} &gt; c_{3} \\\\\n\\dots \\\\\nx_{n} - x_{1} &gt; c_{n}\n\\end{cases} \\Rightarrow \\begin{cases}\nx_1 &gt; x_{2} + c_{1} \\\\\nx_{2} &gt; x_{3} + c_{2} \\\\\nx_{3} &gt; x_{4} + c_{3} \\\\\n\\dots \\\\\nx_{n} &gt; x_{1} + c_{n}\n\\end{cases}\n⎩⎨⎧​x1​−x2​&gt;c1​x2​−x3​&gt;c2​x3​−x4​&gt;c3​…xn​−x1​&gt;cn​​⇒⎩⎨⎧​x1​&gt;x2​+c1​x2​&gt;x3​+c2​x3​&gt;x4​+c3​…xn​&gt;x1​+cn​​\n容易发现这些不等式的形式和 Dijkstra 中三角不等式 disu&gt;disv+wdis_{u} &gt; dis_{v} + wdisu​&gt;disv​+w 类似。更进一步地，我们发现如果将不等式组中的不等式转化成边 (xi,xi+1,ci)(x_{i},x_{i+1},c_{i})(xi​,xi+1​,ci​) 的话，其实的解就是 disidis_idisi​。如果原问题无解的话，相当于在图上存在负环。至此，问题解决。\n需要注意的是，因为要判断是否存在负环，所以不能使用 Dijkstra，而是要使用 SPFA 解决此问题。\nLCA（最近公共祖先）\nProblem\n给点一棵树，每次询问  (u,v)(u,v)(u,v) 的最近公共祖先 LCA(u,v)LCA(u,v)LCA(u,v)。\nSolution\n倍增\n首先我们处理出所有点的直接父亲是谁，然后利用倍增的思路，处理出这个点向上跳一条长度为 2k2^k2k 的链后它的父亲是谁。\n具体地，我们需要得到一个数组 jump[u][k]jump[u][k]jump[u][k] 表示节点 uuu 向上跳 2k2^k2k 步后他的父亲是谁，即 jump[u][k]=jump[jump[u][k−1]][k−1]\\displaystyle jump[u][k] = jump[jump[u][k - 1]][k-1]jump[u][k]=jump[jump[u][k−1]][k−1]，先向上跳 2k−12^{k-1}2k−1 步，再跳 2k−12^{k-1}2k−1 步，就得到了我们想要的答案。\n查询的时候只需要暴力向上跳即可，复杂度 O(mlog⁡n)O(m \\log n)O(mlogn)。\n树剖\n我们先对原树做重链剖分，然后查询的时候每次跳一条重链，直到两条重链的链头的父亲相同。复杂度 O(mlog⁡n)O(m \\log n)O(mlogn)。\nST 表\n我们在原树上处理出欧拉序，由于原树上的任意一颗子树在欧拉序上对应了一个连续的区间，所以问题就转化为了查询这个区间内深度最小的节点的 RMQ 问题，可以用 ST 表解决，复杂度为预处理 O(nlog⁡n)O(n \\log n)O(nlogn)，查询 O(1)O(1)O(1)。\nTarjan（离线）\n我们将所有询问离线下来，然后在 Tarjan 的时候判断与当前这个点有关的所有查询中，是否存在另一个点已经被访问了的查询，如果存在，就更新即可。期间用并查集维护 LCA，复杂度 O(α(m+n,n)+n)O(\\alpha(m + n,n) + n)O(α(m+n,n)+n)。\n例题\nARC084B Small Multiple\nProblem\n给定一个数字 kkk，要求找到最小的 kkk 的倍数，使得所有数位上的数字和最小。\nSolution\n我们不难发现，一个数 x∣kx \\mid kx∣k 等价于如果我们用 cic_{i}ci​ 表示 xxx 的每一个数位上的数，则 ∀i,ci×10i mod k=0\\forall i,c_{i} \\times 10^i \\bmod k = 0∀i,ci​×10imodk=0。所以我们可以对于每一个数位考虑。不难发现，每一次操作就是 ×10\\times 10×10 或者 +1+1+1，所以我们可以 0/1 BFS。\n提交记录：Link\nLuogu-P1993 小 K 的农场\nProblem\n给定共 mmm 个以下形式的不等式组：\n\na−b≥ca-b \\ge ca−b≥c；\na−b≤ca-b \\le ca−b≤c；\na=ba = ba=b；\n\n求其中任意一组解。\nSolution\n我们将题目中的不等式组变换一下：\n\na−b≥c→b≤a+ca-b \\ge c \\to b \\le a + ca−b≥c→b≤a+c；\na−b≤c→a≤b+ca-b \\le c \\to a \\le b + ca−b≤c→a≤b+c；\na=b→a≤ba = b \\to a \\le ba=b→a≤b 和 b≤ab \\le ab≤a；\n\n所以我们按照差分约束的方式建图即可。\n提交记录：Link\nCodeForces-776D The Door Problem\nProblem\n给你 nnn 扇门和 mmm 个开关，每个开关控制 kkk 扇不同的门，一扇门最多被两个开关控制。初始时每扇门要么打开，要么关闭。变换一个开关的状态会使门的状态也发生变化，问你存不存在一种方案，使得所有门均开启。\nSolution\n不难发现，最初打开的门所对应的开关要么同时打开，要么同时关闭，所以我们可以用并查集维护每个开关的状态。若果这个门最初是关闭的，则将 (x,y)(x,y)(x,y) 和 (x+m,y+m)(x+m,y+m)(x+m,y+m) 合并，否则将 (x+m,y)(x+m,y)(x+m,y) 和 (y+m,x)(y + m,x)(y+m,x) 合并。最后检查每个开关的状态是否合法即可。\n提交记录：Link\n模拟题-5.2 第 K 大查询\nProblem\n给定一个 1∽n1 \\backsim n1∽n 的排列 aaa，想知道所有满足 r−l+1≥kr-l+1\\ge kr−l+1≥k 的区间 [l,r][l,r][l,r] 内第 K 大的数的和是多少。\nSolution\n我们将原来的排列按照从小到大排序，发现一个数在区间 [l,r][l,r][l,r] 是第 kkk 大当且仅当区间中包含 k−1k-1k−1 个比它大的数。所以我们可以用双向链表维护这个思路。每次暴力像两边扩展，然后计算贡献，最后在双向链表中删除这个数。时间复杂度 O(nk)O(nk)O(nk)。\nCode\n#include &lt;algorithm&gt;#include &lt;iostream&gt;using std::cin;using std::cout;constexpr int N = 5e5 + 5;int n, k, arr[N], index[N];long long answer = 0;struct Node &#123;    int left, right;&#125; link[N];int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);        cin &gt;&gt; n &gt;&gt; k;        for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; arr[i];        index[i] = i;        link[i] = (Node) &#123;i - 1, i + 1&#125;;    &#125;        std::sort(index + 1, index + n + 1, [&amp;] (int a, int b) &#123; return arr[a] &lt; arr[b]; &#125;);        for (int i = 1; i &lt;= n; i++) &#123;        int _index = index[i];        int left = _index, right = _index;        int rank = 1;                while (link[left].left != 0 &amp;&amp; rank &lt; k) &#123;            rank++;            left = link[left].left;        &#125;                while (link[right].right != n + 1 &amp;&amp; rank &lt; k) &#123;            rank++;            right = link[right].right;        &#125;                // cout &lt;&lt; left &lt;&lt; &#x27; &#x27; &lt;&lt; right &lt;&lt; &quot;\\n&quot;;                if (rank == k) &#123;            while (left != link[_index].right &amp;&amp; right != n + 1) &#123;                answer += 1ll * (left - link[left].left) * (link[right].right - right) * arr[_index];                left = link[left].right;                right = link[right].right;            &#125;        &#125;                link[link[_index].left].right = link[_index].right;        link[link[_index].right].left = link[_index].left;    &#125;        cout &lt;&lt; answer &lt;&lt; &#x27;\\n&#x27;;        return 0;&#125;\n","categories":["集训总结（2025暑）"],"tags":["集训","图论"]},{"title":"OI集训 Day25","url":"/posts/e96c5b1b/","content":"Content：图论基础\nDate：2025.8.10\n\n课堂内容\n图论基础知识\n\n图的定义：由点集 VVV 和边集 EEE 组成，记作图 G(V,E)G (V, E)G(V,E)。\n阶：图的点数，记作 ∣G∣|G|∣G∣。\n相邻：称图中的两个点 相邻，当且仅当 (i,v)∈E(i,v) \\in E(i,v)∈E。\n连通：无向图中若存在 v0=u,vk=vv_0 = u, v_k = vv0​=u,vk​=v 的路径则称 u,vu, vu,v 连通。\n弱连通：若有向图变为无向图后 u,vu, vu,v 连通，则称 u,vu, vu,v 弱连通。\n连通图：无向图中任意两点连通的图称作连通图。\n弱连通图：有向图中任意两点弱连通的图称作弱连通图。\n简单图：不存在重边和自环的图。\n稀疏图/稠密图：∣E∣≪∣V∣2|E| \\ll |V|^2∣E∣≪∣V∣2 的图称作稀疏图，∣E∣|E|∣E∣ 接近 ∣V∣2|V|^2∣V∣2 的图称作稠密图。\n\n拓扑排序\nProblem\n给定一个有向无环图（DAG），要求求出一个序列 ppp，其中 uuu 在排列 ppp 中的位置记作 quq_uqu​，则这个序列满足满足：\n\n∀ u→v∈E\\forall \\ u \\to v \\in E∀ u→v∈E，qu&lt;qvq_u &lt; q_vqu​&lt;qv​。\n\nSolution\n每次从 DAG 中选择一个入度为 0 的点，将这个点加入序列 ppp 中，然后删掉这个点和这个点在图中的所有出边，重复这个过程。\nProof\n显然对于任意的 u→v∈Eu \\to v \\in Eu→v∈E，点 uuu 总是在 vvv 之前被加入序列 ppp，所以最后得到的学列一定是合法的。复杂度为 O(n+m)O (n+m)O(n+m)。\nExtend\n可以用拓扑排序判断一个有向图是否存在环。\n最短路算法\nProblem 1\n给定一张图和一个源点 sss，求图上所有点到源点 sss 的最短距离 DuD_uDu​。\nSolution\nBellman-Ford\n松弛操作：称一次松弛操作为对于每一条边 (u,v,w)(u, v, w)(u,v,w)，用 disu+w→disudis_u + w \\to dis_udisu​+w→disu​。\n这样进行松弛操作 n−1n-1n−1 轮就可以得到 DuD_uDu​。复杂度为 O(nm)O (nm)O(nm)。\nExtend: Bellman-Ford 算法也可以用来判断图中是否存在负环。如果进行了 n−1n-1n−1 轮松弛操作后依然存在可以被更新的 disudis_udisu​，则图中一定存在负环。因为在这个操作中负环被视为无穷小而被无限更新下去。\nSPFA\n关于 SPFA，它死了。\n松弛点 uuu 时若存在可以用 (u,v,w)(u, v, w)(u,v,w) 更新的 disvdis_vdisv​ 且 vvv 不在队列中，则将 vvv 压入队列，重复这个过程知道队列为空。复杂度 O(nm)O(nm)O(nm)。\nExtend：和 bellman-ford 一样，如果存在点被压入队列超过 n−1n-1n−1 次，则图中存在负环。\nDijkstra\n扩展：对于一个点 uuu，称扩展点 uuu 表示用 uuu 的所有出边 (u,v,w)(u, v, w)(u,v,w) 更新 disvdis_vdisv​。\n每次选择未被扩展的 disudis_udisu​ 最小的点 uuu 进行扩展，可以用 优先队列 将复杂度优化到 O(mlog⁡m)O(m \\log m)O(mlogm)，但只能处理 非负权图。\nProblem 2\n对于一个给定的图，求图中任意两点的最短距离。\nSolution\nJohnson\n从超级源点向所有点连一条 (S,u,0)(S, u, 0)(S,u,0) 的边，跑一边 Bellman-Ford/SPFA 得到最短路 huh_uhu​。然后改造边为 (u,v,w+hu−hv)(u, v, w + h_u - h_{v})(u,v,w+hu​−hv​)。然后再在新图上跑一边 Dijkstra（新图为非负权图），复杂度为 O(nmlog⁡m)O (nm \\log m)O(nmlogm)。\nFloyd\n初始化所有 disu,u=0;∀(u,v,w)∈E,disu,v=min⁡{w}dis_{u, u} = 0;\\forall (u,v,w) \\in E,dis_{u,v} = \\min\\{w\\}disu,u​=0;∀(u,v,w)∈E,disu,v​=min{w}，然后在这个数组上进行如下更新：\ndisi,j=min⁡k(disi,k+disk,j)dis_{i,j} = \\min_{k} (dis_{i,k} + dis{k,j})\ndisi,j​=kmin​(disi,k​+disk,j)\n实际上就是一个动态规划，复杂度为 O(n3)O (n^3)O(n3)。\n最短路树\n在单源最短路中，记录每个点最后被更新的前驱 preupre_upreu​，以这个建边得到的树就是最短路树。\n删边最短路\nProblem\n给定一个正权无向图，求删除每一条边后从 111 到 nnn 的最短路。\nSolution\n我们建立一个从 111 出发的最短路树 T1T_1T1​，和一个到达 nnn 的最短路树 T2T_2T2​。容易发现若删除的边 (u,v)(u, v)(u,v) 不在原最短路上，则删除 (u,v)(u,v)(u,v) 不会影响答案。\n所以我们不妨设原最短路为 1⇝i→j⇝n1 \\leadsto i \\to j \\leadsto n1⇝i→j⇝n，找到所有满足 uuu 不在 T2T_2T2​ 的 iii 的子树内，vvv 不在 T1T_1T1​ 的 jjj 的子树内的所有边 (u,v,w)(u, v, w)(u,v,w)。用 dis(u,LCA(T1,u,n))+w(u,v)+dis(v,LCA(T2,v,1))dis(u,LCA(T_1,u,n)) + w(u,v) + dis(v,LCA(T_2,v,1))dis(u,LCA(T1​,u,n))+w(u,v)+dis(v,LCA(T2​,v,1)) 更新答案。复杂度可以用数据结构优化到 O(mlog⁡m)O(m \\log m)O(mlogm)。\n无向图连通性\n定义\n\n割边：删去后使得连通分量增加的边。\n割点：删去后使得连通分量增加的点\n点双连通图：不存在割点的无向连通图。\n边双连通图：不存在割边的无向连通图。\n点双连通分量：极大点双连通子图，即 V-BCC。\n边双连通分量：极大边双连通子图，即 E-BCC。\n\n性质\n点双连通分量\n\n若两个点双连通分量有交点，则这个交点有且仅有一个，且为割点。\n一个点是割点当且仅当它属于超过一个边双连通分量。\n一条边仅属于一个点双连通分量。\n由一条边直接连接的两个点 点双连通。\n点双内任意一个点 uuu 均存在经过这个点的简单环。\n点双内任意一个点对 (u,v)(u,v)(u,v)，均存在包含这个点对的简单环。\n\n边双连通分量\n\n两个点之间任意一条 迹 上的所有割边就是这两个点的必经边。\n若 xxx 和 yyy 边双连通，yyy 和 zzz 边双连通，则 xxx 和 zzz 边双连通（传递性）。\nuuu 和 vvv 之间边双连通当且仅当这两个点之间的必经边集合为空。\n对于一个边双连通分量中的任意一条边 (u,v)(u,v)(u,v)，均存在经过这条边的回路。\n边双内任意一点均存在经过这个点的回路。\n边双内任意一组点对 (u,v)(u,v)(u,v) 均存在包含这个点对的回路。\n\n求解\n\n点双连通分量：Link\n边双连通分量：Link\n\n有向图连通性\n定义\n\n强连通：一个点对 (u,v)(u,v)(u,v) 互相可达。\n强连通图：图中任意两点互相可达的有向连通图。\n强连通分量：极大的强连通子图，即 SCC。\n\n性质\n\n若 dfnv&lt;dfnudfn_v &lt; dfn_udfnv​&lt;dfnu​，则 uuu 可达 vvv 当且仅当 vvv 可达 uuu。\n若 u,vu,vu,v 强连通，则 u,vu,vu,v 在 dfs 树上路径的所有点弱连通。\n强连通分量在 dfs 树上弱连通。\n\n求解\n\n强连通分量（Tarjan）：Link\n\n最小生成树\n定义\n\n生成树：对于连通图而言，生成树是原图一个树形结构的生成子图。\n生成森林：每一个连通分量的生成树组成的子图。\n\n求解最小生成树\nKruskal\n首先对原图的边按照边的权值从小到大排序，然后枚举每一条边，如果这条边连接的两个点现在并不连通，则将这一条边加入最小生成树。连通性可以用并查集维护，复杂度为 O(mlog⁡m)O(m \\log m)O(mlogm)。\n实现：Link\nPrim\n类似 Dijkstra，每次选择一个现在在最小生成树上的点 u∈Su \\in Su∈S（SSS 为当前已经加入最小生成树的点集），将满足 (u,v,w)∈E,v∉S(u,v,w) \\in E,v \\not\\in S(u,v,w)∈E,v∈S 且 www 最小的边加入最小生成树。用优先队列可以把复杂度优化到 O((n+m)log⁡n)O((n+m) \\log n)O((n+m)logn)。\n实现：Link\n例题\nLuogu-P1967 [NOIP 2013 提高组] 货车运输\n题目大意\n给定一张由 nnn 个点 mmm 条双向边组成的无向带权图，有 qqq 次询问，每次询问 u,vu, vu,v 之间的最大瓶颈路。\n思路\n首先如果对于每次询问都单独跑一边 Dijkstra 的复杂度是 O(nmlog⁡m)O (n m \\log m)O(nmlogm) 的，显然不可接受。\n我们发现由于题目要求的是瓶颈路，所以很多边都是用不到的。更进一步的，我们发现只有原图中 最大生成树 上的边才是有用的。所以我们可以对于原图的最大生成树重新建边，然后这个问题就转化为了树上问题。\n转化为树上问题后，u,vu, vu,v 的路径很显然可以分为 u→LCA(u,v)u \\to LCA (u, v)u→LCA(u,v) 和 v→LCA(u,v)v \\to LCA (u, v)v→LCA(u,v)，所以就转化为了求树上两个点之间路径上的最小权值。可以用倍增求 LCALCALCA，复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。\n提交记录：Link\n","categories":["集训总结（2025暑）"],"tags":["集训","图论","最短路"]},{"title":"OI集训 Day28","url":"/posts/97dd27a6/","content":"Content：网络流进阶\nDate：2025.8.13\n\n昨天太累了，没写，就今天补上吧\n课堂内容\n上下界网络流\nOI Wiki：Link\n很可惜，没学懂，但是大概意思应该是用差分的思想将原来的上下界网络流转换为网络最大流。没学过真的听不懂啊……\n题目\n模拟题-6.2 异或\n题目大意\n给你一个长度为 nnn 的数组 aaa，问你满足 (ai⊕aj)&lt;(aj⊕ak)(a_{i} \\oplus a_{j}) &lt; (a_{j} \\oplus a_{k})(ai​⊕aj​)&lt;(aj​⊕ak​) 的三元组 (i,j,k)(i,j,k)(i,j,k) 有多少个。\n解题思路\n由于异或 相同为 0，不同为 1 的运算规则，可以发现要满足上述的不等式 (ai⊕aj)&lt;(aj⊕ak)(a_{i} \\oplus a_{j}) &lt; (a_{j} \\oplus a_{k})(ai​⊕aj​)&lt;(aj​⊕ak​) 只与这三个数第一个在二进制下不同的位置 ppp 有关。具体来说：\n\n若 ak,p=1a_{k,p} = 1ak,p​=1，则 ai,p=aj,p=0a_{i,p} = a_{j,p} = 0ai,p​=aj,p​=0;\n若 ak,p=0a_{k,p} = 0ak,p​=0，则 ai,p=aj,p=1a_{i,p} = a_{j,p} = 1ai,p​=aj,p​=1。\n\n发现其实和二进制串的匹配有关，可以用 0/1 字典树解决，在字典树上计算贡献。\nCode\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 5e5 + 5;constexpr int Z = 2;long long ans = 0;int n, arr[N], mark[50][2];struct Trie &#123;    int tr[N * 32][Z], cnt = 1;    long long pass[N * 32][2];        Trie() &#123;        // memset(tr, -1, sizeof(tr));        // memset(pass, 0, sizeof(pass));        tr[0][0] = tr[0][1] = -1;        cnt = 1;    &#125;        void Insert(int number) &#123;        int pos = 0;        pass[pos][1]++;                for (int i = 30; i &gt;= 0; i--) &#123;            int ch = (number &gt;&gt; i) &amp; 1;                        if (tr[pos][ch] == -1) &#123;                tr[cnt][0] = tr[cnt][1] = -1;                pass[cnt][0] = pass[cnt][1] = 0;                tr[pos][ch] = cnt++;            &#125;                        pos = tr[pos][ch];            pass[pos][0] += mark[i][ch];            pass[pos][1]++;            mark[i][ch]++;                        // cout &lt;&lt; &quot;Insert: &quot; &lt;&lt; pos &lt;&lt; &#x27; &#x27; &lt;&lt; pass[pos][0] &lt;&lt; &#x27; &#x27; &lt;&lt; pass[pos][1] &lt;&lt; &#x27; &#x27; &lt;&lt; mark[i][ch] &lt;&lt; &#x27;\\n&#x27;;        &#125;    &#125;        long long Query(int number) &#123;        int pos = 0;        long long retval = 0;                for (int i = 30; i &gt;= 0; i--) &#123;            int ch = (number &gt;&gt; i) &amp; 1;            int rev = 1 - ch;                        // !             if (tr[pos][rev] != -1) &#123;                // cout &lt;&lt; pass[tr[pos][rev]][0] &lt;&lt; &#x27; &#x27; &lt;&lt; pass[tr[pos][rev]][1] &lt;&lt; &quot; &quot; &lt;&lt; mark[i][rev] &lt;&lt; &quot;\\n&quot;;                                retval += 1ll * pass[tr[pos][rev]][1] * mark[i][rev] - pass[tr[pos][rev]][1] - pass[tr[pos][rev]][0];            &#125;                            pos = tr[pos][ch];            if (pos == -1) &#123;                break;            &#125;        &#125;                return retval;    &#125;&#125; t;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);        memset(mark, 0, sizeof(mark));        cin &gt;&gt; n;        for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; arr[i];    &#125;        for (int i = 1; i &lt;= n; i++) &#123;        ans += t.Query(arr[i]);                // cout &lt;&lt; &quot;\\n&quot;;                t.Insert(arr[i]);    &#125;        cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;        return 0;&#125;\n","categories":["集训总结（2025暑）"],"tags":["集训","网络流"]},{"title":"OI集训 Day29","url":"/posts/e0da1730/","content":"Content：杂题\nDate：2025.8.14\n\nCodeForces-1870E Another MEX Problem\n题目大意\n给你一个数组 aaa，你可以选择任意互不相交的子数组，先计算每一个子数组的 MEX 值，然后将这些 MEX 值的异或和作为这个方案的价值，求你可以获得的最大价值。\n解题思路\n首先我们肯定可以暴力 DP，定义 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个数能否凑出价值为 jjj 的方案，转移显然是 O(n3)O(n^3)O(n3) 的。\n考虑如何优化。由于 MEX 的性质，可以发现从 iii 往后的一段区间内 MEX 值是单调不降的，所以其中一定有大量相等的段。这些段本质是一样的，所以我们只需要考虑那些前后不同的位置即可，这些符合条件的转移区间至多有 2n2n2n 个，所以我们就得到了复杂度为 O(n2)O(n^2)O(n2) 得做法。\n提交记录：Link\nLuogu-P12426 BOI acroym\n题目大意\n已知一个由 B, O, I 组成得字符串每个区间得众数得出现次数，且 B 为全局众数，求原串种 B 出现的位置。\n解题思路\n首先我们可以找到第一个和最后一个出现的 B 的位置。\n\n左侧最后一个满足 m1,n=ml,nm_{1,n} = m_{l,n}m1,n​=ml,n​ 的位置 lll。\n右侧最后一个满足 m1,n=m1,rm_{1,n} = m_{1,r}m1,n​=m1,r​ 的位置 rrr。\n\n然后我们考虑根据已知信息推出区间 (l,r)(l,r)(l,r) 内的 B 的位置。主要有以下三种情况 (curcurcur 表示当前已知的 B 的数量)：\n\n若 ml,i−1=curm_{l,i - 1} = curml,i−1​=cur 且 ml+1,i−1=cur−1m_{l + 1, i - 1} = cur - 1ml+1,i−1​=cur−1 且 ml,i=ml,i−1+1m_{l,i} = m_{l,i - 1} + 1ml,i​=ml,i−1​+1，则位置 iii 为 B。\n若 mi,r=ml,r−curm_{i,r} = m_{l,r} - curmi,r​=ml,r​−cur 且 mi,r−1=ml,r−cur−1m_{i, r - 1} = m_{l,r} - cur - 1mi,r−1​=ml,r​−cur−1 且 mi,r=mi+1,r+1m_{i,r} = m_{i + 1,r} + 1mi,r​=mi+1,r​+1，则位置 iii 为 B。\n若 ml+1,i=ml,i−1m_{l + 1,i} = m_{l,i-1}ml+1,i​=ml,i−1​ 且 mi,r=mi+1,r−1m_{i,r} = m_{i + 1,r - 1}mi,r​=mi+1,r−1​，则位置 iii 为 B。\n\n提交记录：Link\nLuogu-P8386 [PA 2021] Od deski do deski\n题目描述\n给定 nnn，mmm，求满足以下限制的长度为 nnn 的序列数目：\n\n每个元素在 [1,m][1,m][1,m] 之间；\n一次操作定义为删除一个长度至少为 222 且区间两端相等的区间，该序列需要在若干次操作内被删空。\n\n答案对 109+710^9+7109+7 取模。\n解题思路\n可以发现最后的答案一定是由 a………aa \\dots\\dots\\dots aa………a 这样的字符串拼接成的。所以我们定义 fi,j,0/1f_{i,j,0 / 1}fi,j,0/1​ 表示前 iii 个位置包含 jjj 个不同的数且符合/不符合条件的方案数，转移显然。\nfi,j,1×j→fi+1,j,1fi,j,1×(m−j)→fi+1,j+1,0fi,j,0×j→fi+1,j,1fi,j,0×(m−j)→fi+1,j,0\\begin{align}\nf_{i,j,1} \\times j &amp;\\to f_{i+1,j,1} \\\\\nf_{i,j,1} \\times (m - j) &amp;\\to f_{i+1,j + 1,0} \\\\\nf_{i,j,0} \\times j &amp;\\to f_{i+1,j,1} \\\\\nf_{i,j,0} \\times (m - j) &amp;\\to f_{i+1,j,0}\n\\end{align}\nfi,j,1​×jfi,j,1​×(m−j)fi,j,0​×jfi,j,0​×(m−j)​→fi+1,j,1​→fi+1,j+1,0​→fi+1,j,1​→fi+1,j,0​​​\n答案即为 ∑i=0nfn,i,1\\displaystyle \\sum_{i=0}^{n} f_{n,i,1}i=0∑n​fn,i,1​，注意取模。\n提交记录：Link\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day3","url":"/posts/77936e83/","content":"Content： Data structs\nDate：2025.7.19\n\n内容\n\n三维偏序问题\nCDQ分治\n整体二分\n分块\n莫队算法\n\n具体内容\n三维偏序问题\n问题描述\n\n给定一些三元组 (ai,bi,ci)(a_i, b_i, c_i)(ai​,bi​,ci​)，询问对于三元组 (aj,bj,cj)(a_j, b_j, c_j)(aj​,bj​,cj​)，有多少个三元组满足 ai≤aja_i \\le a_jai​≤aj​ 且 bi≤bjb_i \\le b_jbi​≤bj​ 且 ci≤cjc_i \\le c_jci​≤cj​。\n\n\n首先对于这个问题，我们考虑先去重，然后排序。排序规则如下：\n\n如果 ai≠aja_i \\ne a_jai​=aj​，则返回 ai&lt;aja_i &lt; a_jai​&lt;aj​\n如果 bi≠bjb_i \\ne b_jbi​=bj​，则返回 bi&lt;bjb_i &lt; b_jbi​&lt;bj​\n否则返回 ci&lt;cjc_i &lt; c_jci​&lt;cj​\n\n这样我们就把 ai&lt;aja_i &lt; a_jai​&lt;aj​ 的条件去掉了。\n接下来我们考虑分治，定义函数 solve(l,r)solve(l, r)solve(l,r) 表示当前解决到了区间 [l,r][l, r][l,r]，取其中点 midmidmid，将原序列的问题转化为三个部分：\n\nj&lt;i≤midj &lt; i \\le midj&lt;i≤mid，由 solve(l,mid)solve(l, mid)solve(l,mid) 解决。\nmid&lt;j&lt;imid &lt; j &lt; imid&lt;j&lt;i，由 solve(mid+1,r)solve(mid + 1, r)solve(mid+1,r) 解决。\nj≤mid&lt;ij \\le mid &lt; ij≤mid&lt;i，即被 midmidmid 分成了两个部分。\n\n对于第三种情况，我们需要解决的是如下问题：\n问题描述\n\n在区间 [l,r][l,r][l,r] 中，有多少对二元组 (i,j)(i, j)(i,j) （其中 i≠ji \\ne ji=j）满足 bi&lt;bjb_i &lt; b_jbi​&lt;bj​ 且 ci&lt;cjc_i &lt; c_jci​&lt;cj​。\n\n\n可见问题转化为了二维偏序问题，用线段树解决就可以。\n整体二分\n普通的二分操作是直接对于每个询问二分答案，判断答案是否合法。\n整体二分的思路是将所有询问一起二分，根据二分的答案对询问进行分类，再逐步求解。\n例题：\n","categories":["集训总结（2025暑）"],"tags":["集训","数据结构","分治"]},{"title":"OI集训 Day27","url":"/posts/7623a37/","content":"昨天忘记传了喵~\nContent：网络流\nDate：2025.8.12\n\n课堂内容\n二分图匹配\nHall 定理\n\n假设 G=(X,Y,E)G = (X,Y,E)G=(X,Y,E) 是一个二分图，且 ∣X∣≤∣Y∣|X| \\le |Y|∣X∣≤∣Y∣。对于 W⊆XW \\subseteq XW⊆X，记 NG(W)N_{G}(W)NG​(W) 表示在图 GGG 中所有与集合 WWW 中的点相邻的点的集合。那么 XXX 的完美匹配存在，当且仅当 ∣W∣≤∣NG(W)∣|W| \\le |N_G(W)|∣W∣≤∣NG​(W)∣ 对于所有 W⊆XW \\subseteq XW⊆X 存在。\n\n匈牙利算法\n不断搜索增广路，每次考虑一条增广路，看看把一个匹配拆了能否增加一个新的匹配。\n模板代码：Link\n网络最大流算法\nDinic\nDinic 是求解网络最大流的其中一个算法，也是最常用的算法。其核心思想为：每次用 BFS 寻找增广路，然后用 DFS 统计增广路上的最大流量。但是这样会有一些问题，如果给定的网络是如下情况的话：\n\n如果直接按照上面说的方法走，第一次增广路可能是 1→2→3→41 \\to 2 \\to 3 \\to 41→2→3→4，但实际上最优的是 1→2→41 \\to 2 \\to 41→2→4 和 1→3→41 \\to 3 \\to 41→3→4。所以为了解决这个问题，我们需要对原图的所有边建立反向边 (v,u,0)(v,u,0)(v,u,0)。如果我们选择了这条路，则将其反向边的流量减去我们现在流过这条边的流量，这样可以做到类似反悔贪心的效果。\n模版代码：Link\n费用流\n最小费用最大流 (Min Cost Max Flow, MCMF)\n和原来的网络图相比，每一条边新加了一个限制 ccc 表示流过 111 个单位的流量需要花费 ccc 的代价。\n我们在原来的 Dinic 算法的基础上进行修改，每次沿着最短路径进行增广。由于有带负权的反向边存在，我们不能使用 Dijkstra，而是要使用 SPFA。\n模板代码：Link\n题目\nLuogu-P3254 圆桌问题\n题目描述\n一共有 mmm 个不同国家的代表团来参加国际会议，第 iii 个代表团共有 rir_iri​ 个代表参加会议，会议场地内共有 nnn 张桌子，每张桌子最多可以做 cic_{i}ci​ 个人。规定一张桌子上不能坐超过一个相同代表团的人。问是否存在一种合法的分配方案。\n解题思路\n因为一张桌子最多可以做一个同一个代表团的代表，所以我们将每个代表团向每个桌子建一条流量为 1 的边。然后我们把超级源点和每个代表团之间链接一条流量为 rir_{i}ri​ 的边，再把所有桌子和超级汇点连接一条流量为 cic_{i}ci​ 的边，然后跑最大流即可。\n提交记录：Link\n","categories":["集训总结（2025暑）"],"tags":["集训","网络流","二分图匹配"]},{"title":"OI集训 Day4","url":"/posts/e9f7fb20/","content":"Content：Math\nDate：2025.7.20\n\n内容\n\n矩阵\n线性方程组\n行列式\n矩阵树定理\n线性基\n\n具体内容\n矩阵\n矩阵定义\n定义\n将一些元素排列成若干行，每行放上相同数量的元素，就是一个矩阵 (Matrix)。\n对于矩阵 AAA 的第 iii 行，第 jjj 列，我们记作 ai,ja_{i,j}ai,j​ 或 aija_{ij}aij​。\n对于举证 Am×nA_{m \\times n}Am×n​，如果 m=nm = nm=n，则我们称矩阵 AAA 为方阵。\n\n矩阵基本操作\n\n矩阵加法：对于矩阵 Am×nA_{m \\times n}Am×n​, Bm×nB_{m \\times n}Bm×n​, 我们定义矩阵加法为：Ci,j=Ai,j+Bi,j   \t C_{i,j} = A_{i, j} + B_{i, j}\nCi,j​=Ai,j​+Bi,j​\n即矩阵对应位置上的元素之和。   注意\n只有当两个矩阵的大小相同时，才可以进行矩阵加法。\n\n\n标量乘法：对于矩阵 Am×nA_{m \\times n}Am×n​ 和标量 xxx, 我们定义矩阵的标量乘法为：\n\nCi,j=Ai,j×xC_{i, j} = A_{i, j} \\times x\nCi,j​=Ai,j​×x\n\n转置：对于矩阵 Am×nA_{m \\times n}Am×n​，其转置为:\n\nAT=[Aj,i]\tA^{T} = \n\t\\begin{bmatrix}\n\tA_{j, i}\n\t\\end{bmatrix}\nAT=[Aj,i​​]\n\n矩阵的拼接：对于矩阵 Am×n1A_{m \\times n_1}Am×n1​​，Bm×n2B_{m \\times n_2}Bm×n2​​，其拼接为记为 (A ∣ B)(A \\ | \\ B)(A ∣ B)，其大小为 m×(n1+n2)m \\times (n_1 + n_2)m×(n1​+n2​)。\n矩阵的乘法：对于矩阵 Am×nA_{m \\times n}Am×n​ 和矩阵 Bn×kB_{n \\times k}Bn×k​，其矩阵乘法定义为：\n\n对于矩阵乘法，有如下性质：\n\n矩阵乘法具备分配律：(A+B)C=AC+BC(A + B)C = AC + BC(A+B)C=AC+BC；\n矩阵乘法具有结合律：(AB)C=A(BC)(AB)C = A(BC)(AB)C=A(BC);\n\n 注意\n矩阵乘法不具备交换律！\n\n\n矩阵乘法单位元：矩阵乘法单位元\n矩阵的乘法单位元 III 为矩阵主对角线上全部为 111，其余均为 000 的 0/10/10/1 矩阵。\n\n\n矩阵的逆：如果对于矩阵 AAA 存在矩阵 BBB，使得 AB=IAB = IAB=I，则 BBB 称作矩阵 AAA 的逆元，记作 A−1A^{-1}A−1。\n对于逆元我们可以使用高斯消元求解。我们对矩阵 (A ∣ I)(A \\ | \\ I)(A ∣ I) 进行高斯消元，最后会得到 (I ∣ B)(I \\ | \\ B)(I ∣ B) (若无法把左边化为乘法单位元，则矩阵 AAA 不存在逆元)，则 BBB 就为 AAA 的逆元。\n\n矩阵与线性方程组\n对于线性方程组\n{a1,1x1+a1,2x2+⋯+a1,nxn=b1a2,1x1+a2,2x2+⋯+a2,nxn=b2⋮am,1x1+am,2x2+⋯+am,nxn=bm\\begin{cases}\na_{1,1} x_1 + a_{1,2} x_2 + \\dots + a_{1,n} x_n = b_1 \\\\\na_{2,1} x_1 + a_{2,2} x_2 + \\dots + a_{2,n} x_n = b_2 \\\\\n\\vdots \\\\\na_{m,1} x_1 + a_{m,2} x_2 + \\dots + a_{m,n} x_n = b_m\n\\end{cases}\n⎩⎨⎧​a1,1​x1​+a1,2​x2​+⋯+a1,n​xn​=b1​a2,1​x1​+a2,2​x2​+⋯+a2,n​xn​=b2​⋮am,1​x1​+am,2​x2​+⋯+am,n​xn​=bm​​\n将未知数的系数写成矩阵的形式，用系数所在的矩阵的行表示未知数，我们就得到了线性方程组的矩阵 (增广矩阵) 表达形式：\n(a1,1a1,2a1,3…a1,nb1a2,1a2,2a2,3…a2,nb2⋮⋮⋮⋱⋮⋮am,1am,2am,3…am,nbm)\\begin{pmatrix}\n\\begin{array}{ccccc|c}\na_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; \\dots &amp; a_{1,n} &amp; b_1 \\\\\na_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; \\dots &amp; a_{2,n} &amp; b_2 \\\\\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\\na_{m,1} &amp; a_{m,2} &amp; a_{m,3} &amp; \\dots &amp; a_{m,n} &amp; b_m \\\\\n\\end{array}\n\\end{pmatrix}\n​a1,1​a2,1​⋮am,1​​a1,2​a2,2​⋮am,2​​a1,3​a2,3​⋮am,3​​……⋱…​a1,n​a2,n​⋮am,n​​b1​b2​⋮bm​​​​\n对于线性方程组，我们通常会使用消元来求解。在矩阵表示下的线性方程组可以用高斯消元来求解。\n高斯消元是通过对矩阵进行初等变换，以保证在方程的解不变的情况下求出方程的解。一般来说步骤如下 (记增广矩阵为 MMM)：\n\n枚举变量 iii (i∈[1,m]i \\in [1,m]i∈[1,m]) 表示当前要对未知元 xix_ixi​ 进行消元操作。\n寻找最大的 j∈[i,m]j \\in [i,m]j∈[i,m]，使得 aj,i≠0a_{j, i} \\ne 0aj,i​=0，交换 Mi⟷MjM_i \\longleftrightarrow M_jMi​⟷Mj​。\n将交换后的矩阵的第 iii 行的未知元 xix_ixi​ 的系数化为 111，即: ai,j←ai,jai,ia_{i,j} \\leftarrow \\frac{a_{i,j}}{a_{i,i}}ai,j​←ai,i​ai,j​​ (j∈[1,m]j \\in [1,m]j∈[1,m])。\n用矩阵的第 iii 行对矩阵的第 jjj (j∈[i+1,m]j \\in [i + 1,m]j∈[i+1,m]) 行进行消元操作，即：aj,k←aj,k−aj,k×aj,ia_{j,k} \\leftarrow a_{j,k} - a_{j,k} \\times a_{j,i}aj,k​←aj,k​−aj,k​×aj,i​。\n重复上述操作直到 i&gt;ni &gt; ni&gt;n 或者找不到满足条件 222 中的 jjj。\n\n最后的结果可能会有以下三种\n\n如果 i&lt;ni &lt; ni&lt;n，且存在 jjj 使得 aj,n&gt;0a_{j,n} &gt; 0aj,n​&gt;0，则原线性方程组无解。\n如果 i&lt;ni &lt; ni&lt;n，且对于 ∀j\\forall j∀j 满足 aj,n=0a_{j,n} = 0aj,n​=0，则原线性方程组有无数解。\n否则原线性方程组有唯一解。\n\n洛谷 P3389 Code\n  #include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 105;constexpr double eps = 1e-8;class Matrix &#123;    double mat[N][N] = &#123;&#123;0&#125;&#125;;    int size = 0;    public:    Matrix() = default;    void input_matrix() &#123;        cin &gt;&gt; size;        for (int i = 0; i &lt; size; i++)            for (int j = 0; j &lt;= size; j++)                cin &gt;&gt; mat[i][j];    &#125;    int guess() &#123;        int i, j, r = 0;        for (int c = 0; c &lt; size; c++) &#123;            int t = r;            for (i = t + 1; i &lt; size; i++) &#123;                if (abs(mat[i][c]) &gt; abs(mat[t][c])) &#123;                    t = i;                &#125;            &#125;            if (abs(mat[t][c]) &lt; eps) continue;            for (i = c; i &lt;= size; i++) &#123;                swap(mat[t][i], mat[r][i]);            &#125;            for (i = size; i &gt;= c; i--) &#123;                mat[r][i] /= mat[r][c];            &#125;            for (i = r + 1; i &lt; size; i++) &#123;                if (abs(mat[i][c]) &gt; eps) &#123;                    for (j = size; j &gt;= c; j--) &#123;                        mat[i][j] -= mat[r][j] * mat[i][c];                    &#125;                &#125;            &#125;            r++;        &#125;        if (r &lt; size) &#123;            return -1;        &#125;        for (i = size - 1; i &gt;= 0; i--) &#123;            for (j = i + 1; j &lt; size; j++) &#123;                mat[i][size] -= mat[i][j] * mat[j][size];            &#125;        &#125;        return 1;    &#125;    int get_size() const &#123; return size; &#125;    double get_solution(int i) const &#123; return mat[i][size]; &#125;&#125;;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    Matrix matrix;    matrix.input_matrix();    if (matrix.guess() == -1) &#123;        cout &lt;&lt; &quot;No Solution\\n&quot;;    &#125; else &#123;        for (int i = 0; i &lt; matrix.get_size(); i++) &#123;            double answer = matrix.get_solution(i);            if (abs(answer) &lt; eps) &#123;                answer = 0;            &#125; else &#123;                answer = round(answer * 100.00) / 100.00;            &#125;            cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; answer &lt;&lt; &quot;\\n&quot;;        &#125;    &#125;    return 0;&#125;\n洛谷 P2455 Code\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;const double eps = 1e-8;int n;double a[N][N];int gauss() &#123;    int i, j, c, r = 0;        for (c = 0; c &lt; n; c ++) &#123;        int t = r;        for (i = t + 1; i &lt; n; i ++)            if (abs(a[i][c]) &gt; abs(a[t][c])) t = i;                if (abs(a[t][c]) &lt; eps) continue;                for (i = c; i &lt;= n; i ++) swap(a[t][i], a[r][i]);                for (i = n; i &gt;= c; i --) a[r][i] /= a[r][c];                for (i = r + 1; i &lt; n; i ++)            if (abs(a[i][c]) &gt; eps)                for (j = n; j &gt;= c; j --)                    a[i][j] -= a[r][j] * a[i][c];                r ++;    &#125;        if (r &lt; n) &#123;        for (i = r; i &lt; n; i ++)            if (abs(a[i][n]) &gt; eps) return 2;        return 1;    &#125;        for (i = n - 1; i &gt;= 0; i --)        for (j = i + 1; j &lt; n; j ++)            a[i][n] -= a[i][j] * a[j][n];                return 0;&#125;int main() &#123;    scanf(&quot;%d&quot;, &amp;n);        for (int i = 0; i &lt; n; i ++) &#123;        for (int j = 0; j &lt;= n; j ++) &#123;            scanf(&quot;%lf&quot;, &amp;a[i][j]);        &#125;    &#125;        int t = gauss();    if (t == 2) puts(&quot;-1&quot;);    else if (t == 1) puts(&quot;0&quot;);    else &#123;        for (int i = 0; i &lt; n; i ++) &#123;            printf(&quot;x%d=&quot;, i + 1);            if (abs(a[i][n]) &lt; eps) a[i][n] = 0;            printf(&quot;%.2lf\\n&quot;, a[i][n]);        &#125;    &#125;        return 0;&#125;\n除了高斯消元外，我们还有另外一种消元的方式——高斯-约旦消元，下面给出代码。\n洛谷 P3389 Code\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 105;constexpr double eps = 1e-8;class Matrix &#123;    double mat[N][N] = &#123;&#123;0&#125;&#125;;    int size = 0;    public:    Matrix() = default;    void input_matrix() &#123;        cin &gt;size;        for (int i = 0; i &lt; size; i++)            for (int j = 0; j &lt;= size; j++)                cin &gt;mat[i][j];    &#125;    int guess() &#123;        int i, j, r = 0;        for (int c = 0; c &lt; size; c++) &#123;            int t = r;            for (i = t + 1; i &lt; size; i++) &#123;                if (abs(mat[i][c]) abs(mat[t][c])) &#123;                    t = i;                &#125;            &#125;            if (abs(mat[t][c]) &lt; eps) continue;            for (i = c; i &lt;= size; i++) &#123;                swap(mat[t][i], mat[r][i]);            &#125;            for (i = size; i &gt;= c; i--) &#123;                mat[r][i] /= mat[r][c];            &#125;            for (i = r + 1; i &lt; size; i++) &#123;                if (abs(mat[i][c]) eps) &#123;                    for (j = size; j &gt;= c; j--) &#123;                        mat[i][j] -= mat[r][j] * mat[i][c];                    &#125;                &#125;            &#125;            r++;        &#125;        if (r &lt; size) &#123;            return -1;        &#125;        for (i = size - 1; i &gt;= 0; i--) &#123;            for (j = i + 1; j &lt; size; j++) &#123;                mat[i][size] -= mat[i][j] * mat[j][size];            &#125;        &#125;        return 1;    &#125;    int get_size() const &#123; return size; &#125;    double get_solution(int i) const &#123; return mat[i][size]; &#125;&#125;;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    Matrix matrix;    matrix.input_matrix();    if (matrix.guess() == -1) &#123;        cout &lt;&lt; &quot;No Solution\\n&quot;;    &#125; else &#123;        for (int i = 0; i &lt; matrix.get_size(); i++) &#123;            double answer = matrix.get_solution(i);            if (abs(answer) &lt; eps) &#123;                answer = 0;            &#125; else &#123;                answer = round(answer * 100.00) / 100.00;            &#125;            cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; answer &lt;&lt; &quot;\\n&quot;;        &#125;    &#125;    return 0;&#125;\n行列式\n定义\n对于矩阵 (通常为方阵) An×nA_{n \\times n}An×n​，我们定义其行列式为：\ndet⁡(A)=∑p∈Pnsgn⁡(p)∏i=0nAi,pi\\det(A) = \\sum_{p \\in P_n} \\operatorname{sgn}(p) \\prod_{i=0}^{n} A_{i,p_i}\ndet(A)=p∈Pn​∑​sgn(p)i=0∏n​Ai,pi​​\n其中 PnP_nPn​ 表示长度为 nnn 的所有排列的集合，sgn⁡(p)\\operatorname{sgn}(p)sgn(p) 表示 (−1)排列p中的逆序对的个数(-1)^{排列 p 中的逆序对的个数}(−1)排列p中的逆序对的个数。\n这里有一张快速求解行列式的图：\n\n性质\n\n对矩阵做行 (列) 交换，行列式反号。根据排列的奇偶性，我们可以知道交换一个排列中的一对元素，其排列奇偶性也会发生变化，所以 sgn⁡(p)=−sgn⁡(p′)\\operatorname{sgn}(p) = -\\operatorname{sgn}(p^{\\prime})sgn(p)=−sgn(p′)，证毕。\n\n\n对矩阵做行 (列) 数乘，行列式乘上同样的常数我们知道一个排列包含 [1,n][1,n][1,n] 之间的所有整数，所以被修改的元素会在每个连乘中出现且每个连乘中仅出现一次，所以可以提到整个式子的前面，证毕。\n\n\n对矩阵做行 (列) 加法，行列式不变。\n\n求解行列式\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 605;int n;long long p;class Matrix &#123;    long long mat[N][N] = &#123;&#123;&#125;&#125;;    int size = 0;    public:    Matrix() = default;    void get_input(int n) &#123;        size = n;        for (int i = 1; i &lt;= size; i++) &#123;            for (int j = 1; j &lt;= size; j++) &#123;                cin &gt;mat[i][j];            &#125;        &#125;    &#125;    long long det(const long long ModValue) &#123;        long long retval = 1, sgn = 1;        for (int i = 1; i &lt;= size; i++) &#123;            for (int j = i + 1; j &lt;= size; j++) &#123;                while (mat[i][i]) &#123;                    long long divide = mat[j][i] / mat[i][i];                    for (int k = 1; k &lt;= size; k++) &#123;                        mat[j][k] = (mat[j][k] - divide * mat[i][k] % ModValue + ModValue) % ModValue;                    &#125;                    sgn = -sgn;                    swap(mat[i], mat[j]);                &#125;                sgn = -sgn;                swap(mat[i], mat[j]);            &#125;        &#125;        retval = sgn;        for (int i = 1; i &lt;= size; i ++) &#123;            retval = retval * mat[i][i] % ModValue;        &#125;        return (retval + ModValue) % ModValue;    &#125;&#125; matrix;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    cin &gt;n &gt;p;    matrix.get_input(n);    cout &lt;&lt; matrix.det(p) &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n矩阵树定理 (根本听不懂啊)\n矩阵树定理是把图的生成树个数和矩阵行列式联系起来的一个定理。\n矩阵树定理\n对于无自环 (允许重边) 的有向图 G=(V,E)G = (V, E)G=(V,E)。设出度矩阵 D(G)D(G)D(G)，其中 ∀u∈V\\forall u \\in V∀u∈V，Du,uD_{u,u}Du,u​表示点 uuu 的出度，其余位置全部为 000。而 A(G)A(G)A(G) 表示图 GGG 的邻接矩阵，其中 ai,ja_{i,j}ai,j​ 表示 i→ji \\to ji→j 的边的数量 (i,j∈Vi,j \\in Vi,j∈V)。那么可以得到对应的拉普拉斯矩阵 L(G)=D(G)−A(G)L(G) = D(G) - A(G)L(G)=D(G)−A(G)。\nL(G)L(G)L(G) 关于 L(G)k,kL(G)_{k,k}L(G)k,k​ 的余子式是以 kkk 为根节点的内向生成树的个数。\n余子式\n对于矩阵 AAA，Ai,jA_{i,j}Ai,j​ 的余子式定义为 AAA 去掉第 iii 行第 jjj 列的矩阵行列式。\n线性基\n定义\n在 KKK 维异或空间下，一个向量可以用一个 [0,2k)[0,2^k)[0,2k) 内的整数表示 (即该数在二进制意义下的每一位都表示一个向量)。\n对于一组向量 S={v1,v2,v3,…,vn}S = \\{v_1, v_2, v_3, \\dots, v_n\\}S={v1​,v2​,v3​,…,vn​}：\n\nSSS 中数字的异或和称为这些向量的线性组合。\n若不存在非空子集 W⊂SW \\subset SW⊂S 满足 ⨂v∈Wv=0\\bigotimes_{v \\in W} v = 0⨂v∈W​v=0，则称 SSS 线性无关。\nSSS 的所有子集的异或和的集合构成 SSS 的张成，记作 Span⁡(S)\\operatorname{Span}(S)Span(S)。\nSSS 的线性基是一个线性无关的向量集合 WWW，满足 Span⁡(W)=Span⁡(S)\\operatorname{Span}(W) = \\operatorname{Span}(S)Span(W)=Span(S)。\nKKK 维空间的线性基 WWW 满足 ∣W∣=K\\left\\vert W \\right\\vert = K∣W∣=K。\n\n","categories":["集训总结（2025暑）"],"tags":["集训","数学","矩阵","线性代数"]},{"title":"OI集训 Day30","url":"/posts/801d9ed5/","content":"Content：模拟赛\nDate：2025.8.15\n\nProblem-A 图书配对\n题目描述\n给定 nnn 本图书，定义 merge(ai,aj)merge(a_{i},a_{j})merge(ai​,aj​) 表示 aia_iai​, aja_{j}aj​ 直接拼接得到的结果，求满足 merge(ai,aj)∣9merge(a_{i},a_{j}) \\mid 9merge(ai​,aj​)∣9 的个数（一个数只能取一次）。\n解题思路\n我们可以运用小学奥数的知识，如果一个数能被 999 整除，当且仅当这个数的各个数位之和能被 999 整除，知道这个之后就是一个很经典的问题了。\n提交记录：Link\nProblem-B 菜品搭配\n题目描述\n给定数组 aaa，求 ∑i=0n−2∑j=i+1n−1∑k=j+1n(ai⊕aj)×(aj⊕ak)\\displaystyle \\sum_{i=0}^{n-2} \\sum_{j=i+1}^{n-1} \\sum_{k=j+1}^{n} (a_{i} \\oplus a_{j}) \\times (a_{j} \\oplus a_{k})i=0∑n−2​j=i+1∑n−1​k=j+1∑n​(ai​⊕aj​)×(aj​⊕ak​)。\n解题思路\n由于是二进制意义下的异或运算，很容易想到拆位，计算每一位的贡献。而且求的是三元组 (i,j,k)(i,j,k)(i,j,k)，所以我们枚举 jjj 的位置，考虑 jjj 左右两边的贡献。\n对于异或 相同为 0，不同为 1 的运算法则，我们可以发现，i,ki,ki,k 对于 jjj 的贡献是左右两边与 jjj 不相同的位置的个数的乘积，所以我们对于每一个位置计算贡献即可。\n涂胶记录：Link\nProblem-C 课程推荐\n题目大意\n给你一个数组 aaa，其中 aia_iai​ 表示到达 iii 这个位置后你可以到达 [i+1,ai][i+1,a_{i}][i+1,ai​] 中的任何一个位置，求 ∀i,j\\forall i,j∀i,j 互相可达的最小步数之和。\n解题思路\n赛时没有想到是 dpdpdp，直接写了个 Floyd (20pts) + 部分分(10pts)。\n正解是定义 di,jd_{i,j}di,j​ 表示从 iii 到 jjj 需要的最少步数。容易发现：\n\n若 j∈[i+1,ai]j \\in [i + 1, a_{i}]j∈[i+1,ai​]，则 di,j=1d_{i,j}=1di,j​=1。\n若 j&gt;aij &gt; a_{i}j&gt;ai​，则 di,j=dk,j+1d_{i,j} = d_{k,j} + 1di,j​=dk,j​+1，其中 kkk 表示 max⁡t∈[i+1,ai]at\\max_{t\\in[i + 1, a_{i}]} a_tmaxt∈[i+1,ai​]​at​ 所在的位置。\n\n然后记 fi=∑j=indi,j\\displaystyle f_{i} = \\sum_{j=i}^{n} d_{i,j}fi​=j=i∑n​di,j​，则 fi=fp+(n−i)−(ai−p)f_{i} = f_{p} + (n - i) - (a_{i} - p)fi​=fp​+(n−i)−(ai​−p)。答案即为 ∑i=0nfi\\displaystyle \\sum_{i=0}^{n} f_{i}i=0∑n​fi​。\n\n终于结束啦喵~\n","categories":["集训总结（2025暑）"],"tags":["集训","模拟赛"]},{"title":"OI集训 Day7","url":"/posts/70feaa9a/","content":"Content：Competition\nDate：2025.7.23\n\nT1：宝宝巴士之小猫数数\n赛时思路\n开始题意理解错了，以为是倒数第二位开始的连续的 000，后面也没有什么新的思路，就用 python 打了个 n≤5000n \\le 5000n≤5000 的表，拿了 505050 分的部分分。\n正解\n其实就是赛时的思路，根据那个方法打表，但是每次只维护前面几位 (根据样例可以知道答案很小)，然后就没有然后了。\nT2：宝宝巴士之换一换\n赛时思路\n以为时分治，每次合并跨过 midmidmid 的区间，维护一个双指针，每次往结果大的方向移动，同时用不在所选区间内的最大值替换所选区间内的最小值，但其实这个贪心是不对的。\n正解\n其中有一个 Subtask 3 对问题的思考是很有帮助的。\nSolution For Subtask 3\n我们发现问题的答案是 最长的连续的一的个数 和 最长的连续的二的个数 ×\\times× 2 中的最大值。\n\n我们由此受到启发。观察原式 (r−l+1)min⁡{al,al+1,al+2,…,ar}(r-l+1)\\min\\{a_l, a_{l+1}, a_{l+2},\\dots,a_{r}\\}(r−l+1)min{al​,al+1​,al+2​,…,ar​}，我们考虑枚举最小值，将大于最小值的数变为 111，将小于最小值的数变为 000，那么问题转化为如何求序列中连续的 111 的个数。\n将问题抽象出来，可以发现需要维护一个支持如下操作的数据结构：\n\n单点修改\n求连续区间\n\n并查集可以维护。\nT3：宝宝巴士之小猫过河\n赛时思路\n无\n正解\n首先我们考虑 Subtask 3 n≤5000n \\le 5000n≤5000 怎么做，很显然需要一个复杂度为 Θ(n2)\\Theta(n^2)Θ(n2) 的做法。考虑动态规划，定义状态 dpi,j,0/1dp_{i,j,0/1}dpi,j,0/1​，表示左侧走了前 iii 队猫咪🐱，右侧走了前 jjj 队猫咪，0/10/10/1 表示上一次走的是左侧/右侧的猫咪。\n发现状态太多不好优化。其实答案具有单调性 (显然)，我们可以考虑二分答案，对于二分的答案 midmidmid，设当前还剩下 limitlimitlimit 的时间，每一队猫的过桥时间为 ti+ki+m−2t_i + k_i + m - 2ti​+ki​+m−2，我们把这些区间 [ti,ti+ki+m−2][t_i, t_i + k_i + m - 2][ti​,ti​+ki​+m−2] 紧挨着 midmidmid 排，如果发现有一对队伍 (l,r)(l,r)(l,r)，无论如何都会冲突，就返回 falsefalsefalse。\n\n\n总结\n这次比赛时间分配有问题，认为 T2 的复杂度正确，就一直在调试，希望拿到全部分，结果最后不仅没有分，还因为时间不够而没有把暴力的 25pts25pts25pts 的代码提交上去，后面的 T3，T4 的部分分 (50pts+15pts50pts + 15pts50pts+15pts) 没有拿到。\n接下来比赛的时候应该注意：\n\n比赛前浏览题目，确定哪些部分分是可以拿到的 (在草稿纸上做好笔记，赛后复盘)，能拿部分分的题目留 40min 50min40min ~ 50min40min 50min。\n比赛期间不要在同一到题目上花费太长的时间，给自己一个限定的时间范围，如果在范围内没有调出来，要及时放弃。\n\n\n","categories":["集训总结（2025暑）"],"tags":["集训","模拟赛"]},{"title":"OI集训 Day6","url":"/posts/7f99a0c/","content":"Content：Data Structures;\nDate：2025.7.22\n\n概览\n\n可持久化线段树\n虚树\n\n具体内容\n可持久化线段树\n可持久化线段树实现可持久化数组\n我们对每一个版本维护一颗线段树，这样显然空间复杂度是 Θ(nm)\\Theta(nm)Θ(nm) 的，肯定不对。\n接下来我们通过观察可以发现，其实新版本线段树上的很多节点与原线段树\n上的节点是重复的，极大地浪费了空间。\n我们考虑对那些不用修改的节点进行空间上的优化，具体如下：\n\n假设线段树节点 kkk 维护的区间为 [l,r][l,r][l,r]，其中点为 midmidmid。\n我们对新版本新建了一个节点 k′k&#x27;k′，接下来分两种情况讨论：\n\n如果区间 [l,mid][l, mid][l,mid] 包括我们要修改的位置，则 lc(k′)=cnt+1lc(k&#x27;) = cnt + 1lc(k′)=cnt+1，rc(k′)=rc(k)rc(k&#x27;) = rc(k)rc(k′)=rc(k)。即我们继承不用修改的节点。\n对于区间 [mid+1,r][mid + 1, r][mid+1,r] 同理。\n\n\n\n这样我们就极大地降低了空间复杂度。\n放张 OI Wiki 的图在这里方便理解：\n\n\n例题1：洛谷 P3919 可持久化线段树1\n我们直接按题意维护即可。\nCode\n#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;constexpr int N = 1e6 + 5;int n, m, version, op, p, c;int array[N];class SegmentTree &#123;public:    class Node &#123;    public:        int left, right;        int left_child, right_child;        long long value;        explicit Node(const int l = 0, const int r = 0, const int lc = 0, const int rc = 0, const int val = 0) :            left(l), right(r), left_child(lc), right_child(rc), value(val) &#123;&#125;    &#125;;    int count_node = 0, root[N] = &#123;&#125;;    Node node_info[N * 30];    void copy(int&amp; root) &#123;        const int new_root = ++count_node;        node_info[new_root] = node_info[root];        root = new_root;    &#125;    void build_tree(int&amp; k, const int left, const int right) &#123;        k = ++count_node;        node_info[k] = Node(left, right);        if (node_info[k].left == node_info[k].right) &#123;            node_info[k].value = array[left];            return void();        &#125;        const int mid = (node_info[k].left + node_info[k].right) &gt;&gt; 1;        build_tree(node_info[k].left_child, left, mid);        build_tree(node_info[k].right_child, mid + 1, right);    &#125;    void insert_node(int&amp; k, const int position, const int value) &#123;        copy(k);        if (node_info[k].left == node_info[k].right) &#123;            node_info[k].value = value;            return void();        &#125;        const int mid = (node_info[k].left + node_info[k].right) &gt;&gt; 1;        if (position &lt;= mid)            insert_node(node_info[k].left_child, position, value);        else            insert_node(node_info[k].right_child, position, value);    &#125;    long long query(int&amp; k, const int position) &#123;        if (node_info[k].left == node_info[k].right) return node_info[k].value;        const int mid = (node_info[k].left + node_info[k].right) &gt;&gt; 1;        if (position &lt;= mid) return query(node_info[k].left_child, position);        return query(node_info[k].right_child, position);    &#125;&#125; tr;;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; array[i];    tr.root[0] = 1;    tr.build_tree(tr.root[0], 1, n);    for (int i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; version &gt;&gt; op &gt;&gt; p;        if (op == 1) &#123;            cin &gt;&gt; c;            tr.root[i] = tr.root[version];            tr.insert_node(tr.root[i], p, c);        &#125; else &#123;            cout &lt;&lt; tr.query(tr.root[version], p) &lt;&lt; &#x27;\\n&#x27;;            tr.root[i] = tr.root[version];        &#125;    &#125;    return 0;&#125;\n\n例题2：洛谷 P3834 可持久化线段树2\n我们用权值线段树维护每一个数字出现的次数，对于每一个下标维护新的版本，所以在区间 [l,r][l,r][l,r] 中的权值区间 [wl,wr][wl, wr][wl,wr] 出现的次数为 sumwl,wr,r−sumwl,wr,r−1sum_{wl, wr, r} - sum_{wl, wr, r - 1}sumwl,wr,r​−sumwl,wr,r−1​。\n然后在线段树上二分找第 kkk 小即可。\nCode\n#include &lt;bits/stdc++.h&gt;using std::vector;constexpr int kMaxN = 2e5 + 5;int n, m, left, right, k, array[kMaxN];vector &lt;int&gt; current;class SegmentTree &#123;public:    class Node &#123;    public:        int left_child, right_child;        int count;        explicit Node(const int lc = 0, const int rc = 0, const int c = 0) :            left_child(lc), right_child(rc), count(c) &#123;&#125;    &#125;;    int count_node = 0, root[kMaxN] = &#123;&#125;;    Node tr[kMaxN * 20];    void copy_node(int&amp; root) &#123;        const int new_root = ++count_node;        tr[new_root] = tr[root];        root = new_root;    &#125;    void build_tree(int&amp; root, const int left, const int right) &#123;        copy_node(root);        if (left == right) return void();        const int mid = (left + right) &gt;&gt; 1;        build_tree(tr[root].left_child, left, mid);        build_tree(tr[root].right_child, mid + 1, right);    &#125;    void update_node(int&amp; root, const int left, const int right, const int position) &#123;        copy_node(root);        tr[root].count++;        if (left == right) return void();        const int mid = (left + right) &gt;&gt; 1;        if (position &lt;= mid)            update_node(tr[root].left_child, left, mid, position);        else            update_node(tr[root].right_child, mid + 1, right, position);    &#125;    int query_kth(const int root_l, const int root_r, const int left, const int right, const int k) &#123;        if (left == right) return left;        const int mid = (left + right) &gt;&gt; 1;        const int lc1 = tr[root_l].left_child;        const int lc2 = tr[root_r].left_child;        const int pre_sum = tr[lc2].count - tr[lc1].count;        if (k &lt;= pre_sum) return query_kth(tr[root_l].left_child, tr[root_r].left_child, left, mid, k);        return query_kth(tr[root_l].right_child, tr[root_r].right_child, mid + 1, right, k - pre_sum);    &#125;&#125; tr;int get_index(int value) &#123;    using std::lower_bound;    return lower_bound(current.begin(), current.end(), value) - current.begin() + 1;&#125;int main() &#123;    using std::cin;    using std::cout;    using std::sort;    using std::unique;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; array[i];        current.push_back(array[i]);    &#125;    sort(current.begin(), current.end());    current.erase(unique(current.begin(), current.end()), current.end());    tr.build_tree(tr.root[0], 1, current.size());    for (int i = 1; i &lt;= n; i++) &#123;        // ! 注意不要把 tr.root[i - 1] 填入引用中，不然在修改时 tr.root[i - 1] 的值会改变。        tr.root[i] = tr.root[i - 1];        tr.update_node(tr.root[i], 1, current.size(), get_index(array[i]));    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; left &gt;&gt; right &gt;&gt; k;        cout &lt;&lt; current[tr.query_kth(tr.root[left - 1], tr.root[right], 1, current.size(), k) - 1] &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n例题3：洛谷 P2633 Count on a Tree.\n我们用类似树上差分的思路维护即可。\nCode\n#include &lt;bits/stdc++.h&gt;constexpr int kMaxN = 1e5 + 5;int head[kMaxN], cnt = 0;int n, m, u, v, k, last;int initial_weight[kMaxN];int siz[kMaxN], son[kMaxN], dep[kMaxN], fa[kMaxN], top[kMaxN];std::vector&lt;int&gt; tmp;class Edge &#123;public:    int to, next;    explicit Edge(const int t = 0, const int ne = 0) : to(t), next(ne) &#123;&#125;&#125; e[kMaxN &lt;&lt; 2];class PresidentTree &#123;public:    class Node &#123;    public:        int left_child, right_child;        int count;        explicit Node(const int lc = 0, const int rc = 0, const int c = 0) : left_child(lc), right_child(rc), count(c) &#123;&#125;    &#125;;    int count_node = 0, root[kMaxN] = &#123;&#125;;    Node tr[kMaxN * 20];    void copy(int&amp; root) &#123;        const int new_root = ++count_node;        tr[new_root] = tr[root];        root = new_root;    &#125;    void insert(int&amp; root, const int left, const int right, const int pos) &#123;        copy(root);        tr[root].count++;        if (left == right) return void();        const int mid = (left + right) &gt;&gt; 1;        if (pos &lt;= mid)            insert(tr[root].left_child, left, mid, pos);        else            insert(tr[root].right_child, mid + 1, right, pos);    &#125;    int query_kth(int&amp; u, int&amp; v, int left, int right, int x, int y, int kth) &#123;        if (left == right) return left;        const int mid = (left + right) &gt;&gt; 1;        const int sum = tr[tr[u].left_child].count + tr[tr[v].left_child].count - tr[tr[x].left_child].count - tr[tr[y].left_child].unt;        if (kth &lt;= sum) return query_kth(tr[u].left_child, tr[v].left_child, left, mid, tr[x].left_child, tr[y].left_child, kth);        return query_kth(tr[u].right_child, tr[v].right_child, mid + 1, right, tr[x].right_child, tr[y].right_child, kth - sum);    &#125;&#125; tr;void add_edge(const int u, const int v) &#123;    e[cnt] = Edge(v, head[u]);    head[u] = cnt++;&#125;int get_index(const int value) &#123;    using std::lower_bound;    return lower_bound(tmp.begin(), tmp.end(), value) - tmp.begin() + 1;&#125;void dfs(const int u, const int father) &#123;    fa[u] = father;    dep[u] = dep[father] + 1;    siz[u] = 1;    tr.root[u] = tr.root[father];    tr.insert(tr.root[u], 1, n, get_index(initial_weight[u]));    for (int i = head[u]; ~i; i = e[i].next) &#123;        const int v = e[i].to;        if (v == father) continue;        dfs(v, u);        siz[u] += siz[u];        if (son[u] == 0 || siz[v] &gt; siz[son[u]]) son[u] = v;    &#125;&#125;void dfs2(const int u, const int topx) &#123;    top[u] = topx;    if (son[u] == 0) return void();    dfs2(son[u], topx);    for (int i = head[u]; ~i; i = e[i].next) &#123;        const int v = e[i].to;        if (v == fa[u] || v == son[u]) continue;        dfs2(v, v);    &#125;&#125;int get_LCA(int u, int v) &#123;    using std::swap;    while (top[u] != top[v]) &#123;        if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);        u = fa[top[u]];    &#125;    if (dep[u] &gt; dep[v]) swap(u, v);    return u;&#125;int main() &#123;    using std::cin;    using std::cout;    using std::sort;    using std::unique;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    std::memset(head, -1, sizeof(head));    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; initial_weight[i];        tmp.push_back(initial_weight[i]);    &#125;    for (int i = 1; i &lt; n; i++) &#123;        cin &gt;&gt; u &gt;&gt; v;        add_edge(u, v);        add_edge(v, u);    &#125;    sort(tmp.begin(), tmp.end());    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());    dfs(1, 0);    dfs2(1, 1);    for (int i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; k;        u ^= last;        int LCA = get_LCA(u, v);        last = tmp[tr.query_kth(tr.root[u], tr.root[v], 1, n, tr.root[LCA], tr.root[fa[LCA]], k) - 1];        cout &lt;&lt; last &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n可持久化区间线段树\n我们将标记一起放入节点信息中并一起维护即可，和普通线段树一样。就不放代码了。\n可持久化字典树\nUnsubmitted\n==TODO== 洛谷 P4735\n==Submission== WA 64pts\n\n虚树 (没听懂啊)\n定义\n给定节点集合 SSS，∀u,v∈S\\forall u,v \\in S∀u,v∈S，定义关键节点为 u,v,LCA⁡(u,v)u, v, \\operatorname{LCA}(u, v)u,v,LCA(u,v)。\n然后对关键节点在原树上的祖先关系建树，就得到了虚树。\n应用\n可以在树形 DPDPDP 中排除无关的节点，大大降低复杂度。\n","categories":["集训总结（2025暑）"],"tags":["集训","可持久化数据结构","线段树"]},{"title":"OI集训 Day5","url":"/posts/9ef0cbb6/","content":"Content: Problem on Tree\nDate：2025.7.21\n\n概览\n\n树的重心\n树上启发式合并\n树链剖分\n左偏树\n点分治\n\n具体内容\n树的重心\n定义\n树的重心\n树的重心是满足如下条件的点 uuu:\n\n树上不存在其他节点 vvv，使得 max⁡{siz⁡(sonv)}&lt;max⁡{size⁡(sonu)}\\max\\{\\operatorname{siz}(son_v)\\} &lt; \\max\\{\\operatorname{size}(son_u)\\}max{siz(sonv​)}&lt;max{size(sonu​)}。\n\n\n性质\n树的重心 GGG 有如下性质：\n树的重心的性质\n\n当以 GGG 为根节点时，不能存在 vvv 满足 max⁡∀v∈son⁡(u){size⁡(v)}&gt;N2\\max_{\\forall v \\in \\operatorname{son}(u)}\\{\\operatorname{size}(v)\\} &gt; \\frac{N}{2}max∀v∈son(u)​{size(v)}&gt;2N​ (NNN为整棵树的大小)。反之亦然。\n树中所有节点到 GGG 的距离之和最小，如果有两个重心，则距离相同。\n如果两棵树的重心分别为 G1G_1G1​，G2G_2G2​，则两棵树由一条边拼接起来之后，新树的重心一定在 G1G_1G1​ 到 G2G_2G2​ 的路径上。\n在一棵树上加入 (或删除) 一个叶子节点，其重心只移动一条边的距离。\n树的重心一定在以根节点为链头的重链上。\n\n\n例题\nCF685B Kay and Snowflake\n题目大意：\n求一颗大小为 nnn (1≤n≤1051 \\le n \\le 10^{5}1≤n≤105) 有根树的所有子树的重心。\n\n考虑运用性质 444，对整棵树进行 dfsdfsdfs，每次用子节点的重心暴力向上跳，再用性质 111 检查，复杂度 Θ(nlog⁡n)\\Theta(n \\log n)Θ(nlogn)。\nCode\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 3e5 + 5;int head[N], cnt = 0;int n, q, father[N], query_node;int son[N], sub_size[N], answer[N];struct Edge &#123;    int to, next;&#125; e[N &lt;&lt; 1];void add_edge(const int u, const int v) &#123;    e[cnt].to = v;    e[cnt].next = head[u];    head[u] = cnt++;&#125;void dfs(const int u) &#123;    sub_size[u] = 1;    for (int i = head[u]; ~i; i = e[i].next) &#123;        const int v = e[i].to;        if (v == father[u]) continue;        dfs(v);        sub_size[u] += sub_size[v];        if (son[u] == 0 || sub_size[v] &gt; sub_size[son[u]]) &#123;            son[u] = v;        &#125;    &#125;    if (son[u] == 0) &#123;        answer[u] = u;    &#125; else &#123;        answer[u] = answer[son[u]];        while (answer[u] != u) &#123;            if (sub_size[son[answer[u]]] * 2 &lt;= sub_size[u] &amp;&amp; (sub_size[u] - sub_size[answer[u]]) * 2 &lt;= sub_size[u]) &#123;                break;            &#125;            answer[u] = father[answer[u]];        &#125;    &#125;&#125;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    memset(head, -1, sizeof(head));    cin &gt;&gt; n &gt;&gt; q;    for (int i = 2; i &lt;= n; i++) &#123;        cin &gt;&gt; father[i];        add_edge(i, father[i]);        add_edge(father[i], i);    &#125;    dfs(1);    while (q--) &#123;        cin &gt;&gt; query_node;        cout &lt;&lt; answer[query_node] &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n树上启发式合并\n算法内容\n对于某些问题，暴力的复杂度远远大于 stdstdstd 的复杂度，我们可以考虑启发式合并的思想。\n启发式合并时人类对于算法的主观优化，我们以按秩合并的并查集为例。\n并查集\nstruct DSU &#123;    int father[N], size[N];    void init(int limit) &#123;        std::iota(father + 1, father + n + 1, 1);        std::memset(size, 1, sizeof(size));    &#125;    int find(int x) &#123;        if (father[x] != x) father[x] = find(father[x]);        return father[x];    &#125;    bool check(int x, int y) &#123;        return find(x) == find(y);    &#125;    void merge(int x, int y) &#123;        x = find(x), y = find(y);        if (x == y) return void();        // 按秩合并        if (size[x] &gt; size[y]) &#123;            swap(x, y);        &#125;        father[x] = y;    &#125;&#125;\n通过人的主观感受，我们可以知道将大小更小的子树合并到大小更大的子树上一定是更优的。树上启发式合并也是这种思想。我们通过和树链剖分类似的方法，将子节点分为重儿子和轻儿子，对于统计答案时，我们对重儿子统计的答案保留，对轻儿子统计的答案进行撤销，这样保证了复杂度的正确性。\n例题\nCF600E Lomsat gelral\n题目描述\n给定一个有根树，每个点有一个颜色 cic_ici​，对每个子树，求所有出现最多的颜色的和。\nn≤105n \\le 10^{5}n≤105\n\n我们开一个桶记录每一种颜色再子树内的出现次数，并同时维护两个变量：\n\nmaxmaxmax：当前出现最多的颜色出现的次数。\nsumsumsum：出现最多的颜色的和。\n\n每次我们遍历的时候先遍历轻儿子，再遍历重儿子，传入一个标记 fff，表示当前的统计数据是否保留，并根据题意维护 maxmaxmax 和 sumsumsum 即可。\nCode\n#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;constexpr int N = 1e5 + 5;int head[N], cnt = 0;int n, col[N], u, v;int tot[N], size[N], son[N], father[N], dfn = 0;long long max = 0, sum = 0, answer[N];class Edge &#123;public:    int to, next;    Edge(const int to = 0, const int next = 0) : to(to), next(next) &#123;&#125;&#125; e[N &lt;&lt; 1];void add_edge(const int u, const int v) &#123;    e[cnt] = Edge(v, head[u]);    head[u] = cnt++;&#125;void dfs1(const int u, const int fa) &#123;    size[u] = 1;    father[u] = fa;        for (int i = head[u]; ~i; i = e[i].next) &#123;        int v = e[i].to;        if (v == fa) continue;        dfs1(v, u);        size[u] += size[v];        if (son[u] == 0 || size[v] &gt; size[son[u]]) &#123;            son[u] = v;        &#125;    &#125;&#125;void update(const int u, const int val, const int ban) &#123;    tot[col[u]] += val;    if (tot[col[u]] == max) &#123;        sum += col[u];    &#125; else if (tot[col[u]] &gt; max) &#123;        max = tot[col[u]];        sum = col[u];    &#125;        for (int i = head[u]; ~i; i = e[i].next) &#123;        const int v = e[i].to;        if (v == father[u] || v == ban) &#123;            continue;        &#125;                update(v, val, ban);    &#125;&#125;void dfs2(const int u, const bool heavy_son) &#123;    for (int i = head[u]; ~i; i = e[i].next) &#123;        const int v = e[i].to;        if (v == father[u] || v == son[u]) &#123;            continue;        &#125;        dfs2(v, false);    &#125;        if (son[u] != 0) &#123;        dfs2(son[u], true);    &#125;        update(u, 1, son[u]);        answer[u] = sum;        if (heavy_son == false) &#123;        update(u, -1, -1);        sum = 0;        max = 0;    &#125;&#125;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);        std::memset(head, -1, sizeof(head));    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; col[i];    &#125;    for (int i = 1; i &lt; n; i++) &#123;        cin &gt;&gt; u &gt;&gt; v;        add_edge(u, v);        add_edge(v, u);    &#125;        dfs1(1, 0);    dfs2(1, true);        for (int i = 1; i &lt;= n; i++) &#123;        cout &lt;&lt; answer[i] &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\n树链剖分\n算法步骤\n我们维护 555 个数组：\n\nfa[u]fa[u]fa[u]：表示节点 uuu 的父亲。\nsize[u]size[u]size[u]：表示节点 uuu 的子树大小。\nson[u]son[u]son[u]：表示节点 uuu 的重儿子 (即节点 uuu 的子节点中子树大小最大的节点) 的编号。\ntop[u]top[u]top[u]：表示节点 uuu 所在链的链头编号。\nid[i]id[i]id[i]：表示 dfndfndfn 值为 iii 的节点编号。\n\n这样我们就把整棵树拆成了若干条链和轻边。这样我们就可以用线段树对整棵树进行维护 (每一条链都对应了一段连续的 dfndfndfn 区间)。\n例题\n洛谷 P3384 重链剖分/树链剖分\n根据题意对树剖完了的 dfndfndfn 序列用线段树维护即可。\nCode\n#include &lt;bits/stdc++.h&gt;#define OnlineJudgeusing std::cin;using std::cout;constexpr int N = 1e5 + 5;int head[N], cnt = 0;int n, m, root, P, u, v, initial_value[N], value[N], opt;int top[N], size[N], son[N], dep[N], fa[N], id[N], num = 0;class Edge &#123;public:    int to, next;    Edge(const int to = 0, const int next = 0) : to(to), next(next) &#123;&#125;&#125; e[N &lt;&lt; 1];void add_edge(int u, int v) &#123;    e[cnt] = Edge(v, head[u]);    head[u] = cnt++;&#125;struct SegmentTree &#123;    struct Node &#123;        int left, right;        long long sum, add;        explicit Node(const int l = 0, const int r = 0, const int s = 0, const int a = 0) :            left(l), right(r), sum(s), add(a) &#123;&#125;    &#125;;    Node tr[N &lt;&lt; 2];    SegmentTree() &#123;&#125;    void make_lazy(const int k, const long long value) &#123;        (tr[k].sum += (tr[k].right - tr[k].left + 1) * value) %= P;        (tr[k].add += value) %= P;    &#125;    void push_up(const int k) &#123;        const int left_child = k &lt;&lt; 1, right_child = k &lt;&lt; 1 | 1;        tr[k].sum = tr[left_child].sum + tr[right_child].sum;        tr[k].sum %= P;    &#125;    void push_down(const int k) &#123;        if (tr[k].add == 0) return void();        const int left_child = k &lt;&lt; 1, right_child = k &lt;&lt; 1 | 1;        make_lazy(left_child, tr[k].add);        make_lazy(right_child, tr[k].add);        tr[k].add = 0;    &#125;    void build_tree(const int k, const int left, const int right) &#123;        tr[k] = Node(left, right);        if (tr[k].left == tr[k].right) &#123;            tr[k].sum = value[left] % P;            return void();        &#125;        const int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;        const int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        build_tree(lc, left, mid);        build_tree(rc, mid + 1, right);        push_up(k);    &#125;    void modify(const int k, const int left, const int right, const long long value) &#123;        if (tr[k].left &gt;= left &amp;&amp; tr[k].right &lt;= right) &#123;            make_lazy(k, value);            return void();        &#125;        push_down(k);        const int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;        const int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        if (right &lt;= mid) &#123;            modify(lc, left, right, value);        &#125; else if (left &gt; mid) &#123;            modify(rc, left, right, value);        &#125; else &#123;            modify(lc, left, mid, value);            modify(rc, mid + 1, right, value);        &#125;        push_up(k);    &#125;    long long query(const int k, const int left, const int right) &#123;        if (tr[k].left &gt;= left &amp;&amp; tr[k].right &lt;= right) &#123;            return tr[k].sum % P;        &#125;        push_down(k);        const int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;        const int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;        if (right &lt;= mid) &#123;            return query(lc, left, right) % P;        &#125;        if (left &gt; mid) &#123;            return query(rc, left, right) % P;        &#125;        return (query(lc, left, mid) + query(rc, mid + 1, right)) % P;    &#125;&#125; seg;void dfs(int u, int father) &#123;    fa[u] = father;    size[u] = 1;    dep[u] = dep[father] + 1;    for (int i = head[u]; ~i; i = e[i].next) &#123;        int v = e[i].to;        if (v == father) &#123;            continue;        &#125;        dfs(v, u);        size[u] += size[v];        if (son[u] == 0 || size[v] &gt; size[son[u]]) &#123;            son[u] = v;        &#125;    &#125;&#125;void dfs2(int u, int link_top) &#123;    top[u] = link_top;    id[u] = ++num;    value[num] = initial_value[u];    if (son[u] == 0) return;        dfs2(son[u], link_top);    for (int i = head[u]; ~i; i = e[i].next) &#123;        int v = e[i].to;        if (v == fa[u] || v == son[u]) &#123;            continue;        &#125;        dfs2(v, v);    &#125;&#125;using std::swap;void update_range(int u, int v, const long long value) &#123;    while (top[u] != top[v]) &#123;        #ifndef OnlineJudge        cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; top[u] &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; top[v] &lt;&lt; &#x27;\\n&#x27;;        #endif                if (dep[top[u]] &lt; dep[top[v]]) &#123;            swap(u, v);        &#125;        seg.modify(1, id[top[u]], id[u], value);        u = fa[top[u]];    &#125;    if (dep[u] &gt; dep[v]) &#123;        swap(u, v);    &#125;    seg.modify(1, id[u], id[v], value);&#125;long long query_range(int u, int v) &#123;    long long retval = 0;    while (top[u] != top[v]) &#123;        if (dep[top[u]] &lt; dep[top[v]]) &#123;            swap(u, v);        &#125;        (retval += seg.query(1, id[top[u]], id[u])) %= P;        u = fa[top[u]];    &#125;    if (dep[u] &gt; dep[v]) &#123;        swap(u, v);    &#125;    (retval += seg.query(1, id[u], id[v])) %= P;    return retval;&#125;void update_subtree(const int u, const long long value) &#123;    seg.modify(1, id[u], id[u] + size[u] - 1, value);&#125;long long query_subtree(const int u) &#123;    return seg.query(1, id[u], id[u] + size[u] - 1);&#125;using std::cin;using std::cout;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    std::memset(head, -1, sizeof(head));        cin &gt;&gt; n &gt;&gt; m &gt;&gt; root &gt;&gt; P;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; initial_value[i];    &#125;    for (int i = 1; i &lt; n; i++) &#123;        cin &gt;&gt; u &gt;&gt; v;        add_edge(u, v);        add_edge(v, u);    &#125;    dfs(root, 0);    dfs2(root, root);    seg.build_tree(1, 1, n);    for (int i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; opt;        switch (opt) &#123;            int x, y;            long long z;            case 1:                cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;                update_range(x, y, z);                break;            case 2:                cin &gt;&gt; x &gt;&gt; y;                cout &lt;&lt; query_range(x, y) &lt;&lt; &#x27;\\n&#x27;;                break;            case 3:                cin &gt;&gt; x &gt;&gt; z;                update_subtree(x, z);                break;            case 4:                cin &gt;&gt; x;                cout &lt;&lt; query_subtree(x) &lt;&lt; &#x27;\\n&#x27;;                break;            default:                break;        &#125;    &#125;    return 0;&#125;\n左偏树\n左偏树是可并堆的一种。\n定义\n我们定义 外节点 表示子节点数小于两个的节点。定义一个节点 uuu 的 distudist_udistu​ 表示到最近的外节点的距离。\n左偏树满足如下性质：\n\n对于任意一个节点 uuu，均满足 distlson⁡(u)&gt;distrson⁡(u)dist_{\\operatorname{lson}(u)} &gt; dist_{\\operatorname{rson}(u)}distlson(u)​&gt;distrson(u)​，即 左偏。\n由上一条性质我们可以推导出：distu=distrson⁡(u)+1dist_u = dist_{\\operatorname{rson}(u)} + 1distu​=distrson(u)​+1。\n\n操作\n合并\n左偏树的合并操作有以下几个步骤：\n\n定义 merge⁡(x,y)\\operatorname{merge}(x, y)merge(x,y) 表示将以 xxx 和 yyy 为根节点的左偏树合并。\n我们钦定 valx&lt;valyval_x &lt; val_yvalx​&lt;valy​，将 xxx 作为合并后的新的根节点 即维护一个小根堆。\n接下来进行 merge⁡(lson⁡(x),y)\\operatorname{merge}(\\operatorname{lson}(x),y)merge(lson(x),y)。\n然后维护左偏树的性质：\n\n如果 distlson⁡(x)&lt;distrson⁡(x)dist_{\\operatorname{lson}(x)} &lt; dist_{\\operatorname{rson}(x)}distlson(x)​&lt;distrson(x)​，则 swap⁡(lson⁡(x),rson⁡(x))\\operatorname{swap}(\\operatorname{lson}(x), \\operatorname{rson}(x))swap(lson(x),rson(x))。\n维护 distx=distrson⁡(x)+1dist_x = dist_{\\operatorname{rson}(x)} + 1distx​=distrson(x)​+1。\n\n\n\n删除\n删除还是基于左偏树的 merge⁡(x,y)\\operatorname{merge}(x,y)merge(x,y) 操作，如果删除的是 xxx，则 merge⁡(lson⁡(x),rson⁡(x))\\operatorname{merge}(\\operatorname{lson}(x), \\operatorname{rson}(x))merge(lson(x),rson(x))，然后维护左偏树的性质即可\n例题\n洛谷 P3337 左偏树/可并堆\n模板题，根据题意维护即可。\nCode\n#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;constexpr int N = 1e5 + 5;int n, m, erase[N], op, x, y;class LeftistTree &#123;public:    struct Node &#123;        int value, index;        Node(const int v = 0, const int i = 0) :            value(v), index(i) &#123;&#125;        bool operator&lt;(const Node&amp; compare_node) const &#123;            if (value != compare_node.value) &#123;                return value &lt; compare_node.value;            &#125;            return index &lt; compare_node.index;        &#125;        bool operator&gt;(const Node&amp; compare_node) const &#123;            if (value != compare_node.value) &#123;                return value &gt; compare_node.value;            &#125;            return index &gt; compare_node.index;        &#125;    &#125; val[N];    int father[N] = &#123;&#125;;    int dist[N] = &#123;&#125;, lc[N] = &#123;&#125;, rc[N] = &#123;&#125;;    int find(const int x) &#123;        if (father[x] != x) father[x] = find(father[x]);        return father[x];    &#125;    int merge(int x, int y) &#123;        using std::swap;        if (x == 0 || y == 0) return x + y;        if (val[x] &gt; val[y]) swap(x, y);        rc[x] = merge(rc[x], y);        if (dist[lc[x]] &lt; dist[rc[x]]) swap(lc[x], rc[x]);        dist[x] = dist[rc[x]] + 1;        return x;    &#125;&#125; tr;int main() &#123;    using std::memset;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    memset(tr.rc, 0, sizeof(tr.rc));    memset(tr.lc, 0, sizeof(tr.lc));    memset(tr.dist, 0, sizeof(tr.dist));    tr.dist[0] = -1;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; tr.val[i].value;        tr.val[i].index = i;        tr.father[i] = i;    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; op;        if (op == 1) &#123;            cin &gt;&gt; x &gt;&gt; y;            if (erase[x] || erase[y]) &#123;                continue;            &#125;            x = tr.find(x), y = tr.find(y);            if (x == y) &#123;                continue;            &#125;            tr.father[x] = tr.father[y] = tr.merge(x, y);        &#125; else if (op == 2) &#123;            cin &gt;&gt; x;            if (erase[x] == true) &#123;                cout &lt;&lt; &quot;-1\\n&quot;;            &#125; else &#123;                x = tr.find(x);                cout &lt;&lt; tr.val[x].value &lt;&lt; &#x27;\\n&#x27;;                erase[x] = true;                const int current_root = tr.merge(tr.lc[x], tr.rc[x]);                tr.father[tr.lc[x]] = current_root;                tr.father[tr.rc[x]] = current_root;                tr.father[x] = current_root;                tr.lc[x] = 0;                tr.rc[x] = 0;                tr.dist[x] = 0;            &#125;        &#125;    &#125;    return 0;&#125;\n点分治\nOI Wiki\n思想\n我们对每个节点进行分治，将树上的路径分为 经过点 uuu 的 和 不经过点 uuu 的，而点 uuu 通常取树的重心。\n典型问题：KKK 长路径计数。\n","categories":["集训总结（2025暑）"],"tags":["集训","树上问题","树链剖分"]},{"title":"OI集训 Day8","url":"/posts/e041b70b/","content":"Content：DP (Interval, Tree)\nDate：2025.7.24\n\n概览\n\n区间 DP\n树形 DP\n\n例题\n洛谷-P4516 潜入行动\n题目大意\n题目大意\n给定一颗树，要求在树上选取恰好 k\\large kk 个节点 (不得重复)，每个选取的节点可以覆盖它的邻居，但是不能覆盖自己本身。要求选取的这 k\\large kk 个节点覆盖所有的 n\\large nn 个节点。求方案数。\n数据范围 n≤105,k≤100\\large n \\le 10^5, k \\le 100n≤105,k≤100。\n\n思路\n我们考虑树形动态规划。定义状态 fu,i,0/1,0/1\\large f_{u,i,0/1,0/1}fu,i,0/1,0/1​ 表示以 u\\large uu 为根的子树内，选取了 i\\large ii 个节点，其中点 u\\large uu 放了/不放，被/不被覆盖的方案数。初始状态为：\nfu,0,0,0=1fu,1,1,0=1\\large \n\\begin{aligned}\nf_{u,0,0,0} = 1 \\\\\nf_{u,1,1,0} = 1 \\\\\n\\end{aligned}\nfu,0,0,0​=1fu,1,1,0​=1​\n可以发现如果只看前两维的话，是一个典型的树形背包问题。接下来我们考虑加上后两维后如何转移 (本质还是树形背包)。\n\n\n对于 fu,i,0,0\\large f_{u,i,0,0}fu,i,0,0​，即点 u\\large uu 既不选择，也 不覆盖，所以 uuu 的子节点 vvv 一定不能选择，而 vvv 必须     覆盖，所以其转移如下：\nfu,i,0,0=∑v∈son⁡(u)fu,i−j,0,0×fv,j,0,1    \\large\n    f_{u,i,0,0} = \\sum_{v \\in \\operatorname{son}(u)} f_{u,i - j,0,0} \\times f_{v,j,0,1}\nfu,i,0,0​=v∈son(u)∑​fu,i−j,0,0​×fv,j,0,1​\n\n\n对于 fu,i,0,1\\large f_{u,i,0,1}fu,i,0,1​，即点 u\\large uu 不选择，但是被覆盖。因为状态为点 uuu 被覆盖，所以既可以是 vvv 覆盖的，也可能是 uuu 的其他子节点覆盖的，而因为 uuu 不被选择，所以 vvv 一定是已经被覆盖了的，所以其转移如下：\nfu,i,0,1=∑v∈son⁡(u)fu,i−j,0,1×(fv,j,0,1+fv,j,1,1)+∑v∈son⁡(u)fu,i−j,0,0×fv,j,1,1    \\large \n    f_{u,i,0,1} = \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,0,1} \\times (f_{v,j,0,1} + f_{v,j,1,1}) + \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,0,0} \\times f_{v,j,1,1}\nfu,i,0,1​=v∈son(u)∑​fu,i−j,0,1​×(fv,j,0,1​+fv,j,1,1​)+v∈son(u)∑​fu,i−j,0,0​×fv,j,1,1​\n\n\n对于 fu,i,1,0\\large f_{u,i,1,0}fu,i,1,0​，即点 u\\large uu 选择了，但还没有被覆盖。因为不被覆盖，所以点 v\\large vv 一定不能被选择，而点 u\\large uu 已经被选择了，所以点 v\\large vv 覆不覆盖无所谓。转移如下：\nfu,i,1,0=∑v∈son⁡(u)fu,i−j,1,0×(fv,j,0,1+fv,j,0,0)    \\large \n    f_{u,i,1,0} = \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,1,0} \\times (f_{v,j,0,1} + f_{v,j,0,0})\nfu,i,1,0​=v∈son(u)∑​fu,i−j,1,0​×(fv,j,0,1​+fv,j,0,0​)\n\n\n对于 fu,i,1,1\\large f_{u,i,1,1}fu,i,1,1​，即点 u\\large uu 选择了，也被覆盖了的情况。由 1,31,31,3 两种情况类似的推导就可以得到。转移为：\nfu,i,1,1=∑v∈son⁡(u)fu,i−j,1,1×(fv,j,0,0+fv,j,0,1+fv,j,1,0+fv,j,1,1)+∑v∈son⁡(u)fu,i−j,1,0×(fv,j,1,0+fv,j,1,1)    \\large \n    f_{u,i,1,1} = \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,1,1} \\times (f_{v,j,0,0} + f_{v,j,0,1} + f_{v,j,1,0} + f_{v,j,1,1}) + \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,1,0} \\times (f_{v,j,1,0} + f_{v,j,1,1})\nfu,i,1,1​=v∈son(u)∑​fu,i−j,1,1​×(fv,j,0,0​+fv,j,0,1​+fv,j,1,0​+fv,j,1,1​)+v∈son(u)∑​fu,i−j,1,0​×(fv,j,1,0​+fv,j,1,1​)\n\n\n最后，注意 取模 和 long long!!!\nCode\nCode\n#include &lt;bits/stdc++.h&gt;namespace IO &#123;    template&lt;typename name&gt; name read() &#123;        name x = 0, f = 1; char ch = getchar();        while (!isdigit(ch)) &#123; if (ch == &#x27;-&#x27;) f = -1; ch = getchar(); &#125;        while (isdigit(ch)) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); ch = getchar(); &#125;        return x * f;    &#125;    template&lt;typename name&gt; void _write(name x) &#123;        if (x &gt; 9) _write(x / 10);        putchar(x % 10 + &#x27;0&#x27;);    &#125;    template&lt;typename name&gt; void write(name x) &#123;        if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x;        _write(x);    &#125;&#125;constexpr int N = 1e5 + 5, K = 105, MOD = 1e9 + 7;int head[N], next[N &lt;&lt; 1], to[N &lt;&lt; 1], cnt = 0;int dp[N][K][2][2], size[N], tmp[K][2][2];int n, k, u, v;inline void AddEdge(const int u, const int v) &#123;    to[cnt] = v;    next[cnt] = head[u];    head[u] = cnt++;&#125;inline void Dfs(int u, int father) &#123;    dp[u][0][0][0] = dp[u][1][1][0] = 1;    size[u] = 1;        for (int i = head[u]; ~i; i = next[i]) &#123;        const int v = to[i];        if (v == father) continue;                Dfs(v, u);        size[u] += size[v];                // ! 这里要进行备份，不然转移的时候会出现问题（用已修改的状态修改未修改的状态）        for (int t = 0; t &lt;= std::min(k, size[u]); t++) &#123;            tmp[t][0][0] = dp[u][t][0][0];            tmp[t][1][0] = dp[u][t][1][0];            tmp[t][0][1] = dp[u][t][0][1];            tmp[t][1][1] = dp[u][t][1][1];            dp[u][t][0][0] = dp[u][t][1][0] = dp[u][t][0][1] = dp[u][t][1][1] = 0;        &#125;                // ! 注意枚举范围，不能直接枚举区间 [0,k]，不然会 TLE        for (int t = 0; t &lt;= std::min(size[u], k); t++) &#123;            // ! 这里同理            for (int j = 0; j &lt;= std::min(size[v], t); j++) &#123;                if (t - j &gt; size[u] - size[v]) continue;                                // // 可恶的转移                (dp[u][t][0][0] += (long long) tmp[t - j][0][0] * dp[v][j][0][1] % MOD) %= MOD;                (dp[u][t][0][1] += ((long long) tmp[t - j][0][1] * ((dp[v][j][0][1] + dp[v][j][1][1]) % MOD) % MOD + (long long) tmp[t - j][0][0] * dp[v][j][1][1] % MOD) % MOD) %= MOD;                (dp[u][t][1][0] += (long long) tmp[t - j][1][0] * ((dp[v][j][0][1] + dp[v][j][0][0]) % MOD) % MOD) %= MOD;                (dp[u][t][1][1] += ((long long) (tmp[t - j][1][1] * (((long long) dp[v][j][0][1] + dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][1][1]) % MOD) % MOD) + (long long) tmp[t - j][1][0] * ((dp[v][j][1][1] + dp[v][j][1][0]) % MOD) % MOD) % MOD) %= MOD;            &#125;        &#125;    &#125;&#125;int main() &#123;    using namespace IO;        n = read&lt;int&gt;();    k = read&lt;int&gt;();        for (int i = 1; i &lt;= n; i++) head[i] = -1;        for (int i = 1; i &lt; n; i++) &#123;        u = read&lt;int&gt;(), v = read&lt;int&gt;();        AddEdge(u, v);        AddEdge(v, u);    &#125;        Dfs(1, 1);        write((1ll * dp[1][k][0][1] + dp[1][k][1][1]) % MOD);        return 0;&#125;\n洛谷-P1352 没有上司的舞会 (经典题)\n题目大意\n题目大意\n给定一颗有 nnn 个节点的树，表示员工的架构，现在有一个舞会需要举办，你要选取一些人参加，第 i\\large ii 个人参加可以为舞会带来 ri\\large r_iri​ 的快乐值，但是如果第 i\\large ii 个人的直接上司 (i\\large ii 的父亲节点) 参加了，那么 i\\large ii 就不会参加，你要最大化选择的人的快乐值之和。\n数据范围：n≤6×103\\large n \\le 6 \\times 10^3n≤6×103。\n\n思路\n定义状态 fu,0/1\\large f_{u,0/1}fu,0/1​ 表示节点 u\\large uu 参加/不参加能为舞会带来的最大价值。\n转移如下：\nfu,0=∑v∈son⁡(u)max⁡(fv,0,fv,1)fu,1=∑v∈son⁡(u)fv,0+ri\\large \n\\begin{aligned}\nf_{u,0} &amp;= \\sum_{v \\in \\operatorname{son}(u)} \\max(f_{v,0}, f_{v,1}) \\\\\nf_{u,1} &amp;= \\sum_{v \\in \\operatorname{son}(u)} f_{v,0} + r_i\n\\end{aligned}\nfu,0​fu,1​​=v∈son(u)∑​max(fv,0​,fv,1​)=v∈son(u)∑​fv,0​+ri​​\n注意我的树存的是双向边，和边有关的数组要开 2\\large 22 倍。\nCode\nCode\n#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;constexpr int MAXN = 6e4 + 5;int head[MAXN], to[MAXN], next[MAXN], cnt = 0;int n, r[MAXN], u, v;int dp[MAXN][2];void add_edge(const int u, const int v) &#123;    to[cnt] = v;    next[cnt] = head[u];    head[u] = cnt++;&#125;void dfs(const int u, const int father) &#123;    dp[u][1] = r[u];        for (int i = head[u]; ~i; i = next[i]) &#123;        const int v = to[i];        if (v == father) continue;                dfs(v, u);        dp[u][0] += std::max(dp[v][0], dp[v][1]);        dp[u][1] += dp[v][0];    &#125;&#125;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    std::memset(head, -1, sizeof(head));        cin &gt;&gt; n;        for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; r[i];    &#125;        for (int i = 1; i &lt; n; i++) &#123;        cin &gt;&gt; u &gt;&gt; v;        add_edge(u, v);        add_edge(v, u);    &#125;        dfs(1, 1);        cout &lt;&lt; std::max(dp[1][0], dp[1][1]) &lt;&lt; &#x27;\\n&#x27;;        return 0;&#125;\n洛谷-P3478 消防局的 STA-Station\n题目大意\nP3478 [POI 2008] STA-Station 题目大意\n给定一个 n\\large nn 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。\n一个结点的深度之定义为该节点到根的简单路径上边的数量。\n数据范围：n≤106\\large n \\le 10^6n≤106.\n\n思路\n换根 DP。设 fu\\large f_ufu​ 表示以 u\\large uu 为根节点的时候所有节点的深度之和是多少。换根一般都有两个 dfs\\large dfsdfs，我们在第一遍 dfs\\large dfsdfs 的时候记录节点的深度 dep\\large depdep，子树大小 size\\large sizesize，然后 fu\\large f_ufu​ 的状态为：fu=depu\\large f_u = dep_ufu​=depu​。\n在第二遍 dfsdfsdfs 时，我们自上而下更新 fvf_vfv​ 的值，转移为：\nfv=fu−sizev+n−sizev\\large \nf_v = f_u - size_v + n - size_v\nfv​=fu​−sizev​+n−sizev​\n即子树 vvv 内所有点的深度减一，子树外的所有深度加一。\n注意 long long!!!\nCode\nCode\n#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;constexpr int N = 1e6 + 5;int head[N], next[N &lt;&lt; 1], to[N &lt;&lt; 1], cnt = 0;int n, u, v, dp[N], dep[N], size[N];void AddEdge(const int u, const int v) &#123;    to[cnt] = v;    next[cnt] = head[u];    head[u] = cnt++;&#125;void Dfs1(const int u, const int father) &#123;    dp[u] += dep[u];    dep[u] = dep[father] + 1;    size[N] = 1;        for (register int i = head[u]; ~i; i = next[i]) &#123;        register const int v = to[i];        if (v == father) continue;                Dfs1(v, u);        size[u] += size[v];    &#125;&#125;void Dfs2(const int u, const int father) &#123;    for (register int i = head[u]; ~i; i = next[i]) &#123;        register const int v = to[i];        if (v == father) continue;                dp[v] = dp[u] - size[v] + n - size[v];        Dfs2(v, u);    &#125;&#125;int main() &#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);     std::memset(head, -1, sizeof(head));        cin &gt;&gt; n;        for (int i = 1; i &lt; n; i++) &#123;        cin &gt;&gt; u &gt;&gt; v;                AddEdge(u, v);        AddEdge(v, u);    &#125;        Dfs1(1, 1);    Dfs2(1, 1);        int ans = 1;    for (int i = 2; i &lt;= n; i++) &#123;        if (dp[i] &gt; dp[ans]) ans = i;    &#125;        cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;        return 0;&#125;\n","categories":["集训总结（2025暑）"],"tags":["集训","DP"]},{"title":"OI集训 Day9","url":"/posts/9746879d/","content":"Content：DP (state, num)\nDate：2025.7.25\n\n概览\n\n数位 DP\n状压 DP\n\n内容\n状压 DP\n状压 DP，即状态压缩 DP，通常情况下和子集问题挂钩，以二进制的第 iii 位表示集合中的每个子集选还是不选。\n有一种 O(3n)O(3^n)O(3n) 的子集枚举方式：\n[!Note] Code\nfor (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123;    for (int j = i; j; j = (j - 1) &amp; i) &#123;        // * j 即为 i 的子集    &#125;&#125;\n数位 DP\n数位 DP，即不是以数字为状态进行动态规划，而是和人一样，对于数字的每个数位作为状态，常见问题为：\n常见问题\n给定区间 [L,R][L,R][L,R]，求出在这个区间中满足某种条件的数的个数。\n\n例题\n洛谷-P1896 互不侵犯\n思路\n我们定义 dpi,s,jdp_{i,s,j}dpi,s,j​ 表示第 iii 行的放置状态为 二进制表示下的 sss 时的放置 jjj 个国王的方案数。\n首先根据题意，我们要排除一些不合法的放置状态：\n\n对于 ∀s\\forall s∀s，如果 s &amp; s&lt;&lt;1s \\ \\&amp; \\ s &lt;&lt; 1s &amp; s&lt;&lt;1 或 s &amp; s&gt;&gt;1s \\ \\&amp; \\ s &gt;&gt; 1s &amp; s&gt;&gt;1 不为 000，那么状态 sss 不合法。（不能左右相邻）\n对于任意相邻两行的状态 ∀s,t\\forall s,t∀s,t，如果 s &amp; ts \\ \\&amp; \\ ts &amp; t 或 s &amp; t&lt;&lt;1s \\ \\&amp; \\ t &lt;&lt; 1s &amp; t&lt;&lt;1 或 s &amp; t&lt;&lt;1s \\ \\&amp; \\ t &lt;&lt; 1s &amp; t&lt;&lt;1 不为 000，那么状态 s,ts,ts,t 不合法。（题目要求）\n\n然后对于转移就是对于所有合法状态的累加。\n提交记录：link\n洛谷-P3959\n思路\n容易发现最后的答案和深度有关，不放就以深度作为状态。\n定义 dpd,sdp_{d,s}dpd,s​ 表示当前树的深度为 ddd，在树上的节点的状态为 sss。\n转移就是枚举 sss 的子集 ttt，方程如下：\ndpd,s=mint∈s{dpd−1,t+d×costt,s}dp_{d,s} = min_{t \\in s} \\{dp_{d-1,t} + d \\times cost_{t,s}\\}\ndpd,s​=mint∈s​{dpd−1,t​+d×costt,s​}\n其中 costt,scost_{t,s}costt,s​ 表示从集合 ttt 变为集合 sss 的最小花费，可以预处理得到。\n提交记录：link\n洛谷-P4363 一双木棋 chess\n思路\n轮廓线 DP。\n我们以一个长度为 n+mn+mn+m 的二进制串表示轮廓线，其中如果第 iii 位为 000，则向下走，否则向右走。手搓一下样例可以发现状态的转移是将二进制串中的 010101 变为 101010。直接转移不好转移，但是可以记忆化搜索。\n定义 dpsdp_{s}dps​ 表示轮廓线的状态为 sss 下的答案。深搜 + 记忆化即可。\n提交记录：link\n洛谷-P4371 花神的数论题\n思路\n我们发现直接在十进制下做状态不好表示，而题目的答案和二进制的乘积相关，不妨就直接以二进制表示状态。定义 dpi,j,kdp_{i,j,k}dpi,j,k​ 表示当前枚举到了二进制下的第 iii 位，数字最后在二进制下有 jjj 个 111，目前已经选择了 kkk 个 111 的方案数。\n答案即为 ∏i=1log⁡2nidplog⁡2n,i,0\\Large \\prod_{i=1}^{\\log_2n} i^{dp_{\\log_2 n,i,0}}∏i=1log2​n​idplog2​n,i,0​。\n注意：统计 dpdpdp 数组的时候不可以取模（也不会爆 long long）\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训","DP"]}]