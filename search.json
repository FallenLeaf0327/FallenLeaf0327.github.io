[{"title":"CodeForces 1114C","url":"/posts/17917da1/","content":"VJudge  CodeForcces\n算法\n\n数学（质因数分解，因数个数，进制）\n\n\n思路\n根据进制的知识，对于 $k$ 进制而言，只有当 $n \\bmod k^{i} = 0$ 时，$k$ 进制意义下的第 $i$ 位才会为零。\n由于 $k \\le 10^{12}$，所以直接进行除法操作肯定不行，考虑将 $k$ 质因数分解，对于 $k$ 的每一个质因数分别考虑。设 $k = \\prod_{i = 0}^{s} p_{i}^{\\alpha_{I}}$，$n! = \\prod_{i = 0}^{s} p_{i}^{\\beta_i}$。则 $n!$ 在 $k$ 进制下末尾 $0$ 的个数为 $\\min_{i=0}^{s} \\lfloor \\frac{\\beta_i}{\\alpha_i} \\rfloor$ 。\n代码\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int N = 1e6 + 5;\nlong long divide[N][2];\nint cnt = 0;\n\ninline long long cal(long long a, long long b) &#123;\n  if (a &lt; b) return 0;\n  else return a / b + cal(a / b, b);\n&#125;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  \n  cout.tie(nullptr);\n  \n  long long n, k;\n  cin &gt;&gt; n &gt;&gt; k;\n  \n  long long answer = 1ll &lt;&lt; 62;\n  \n  // ! 注意枚举上界为 sqrt(k) 而不是 k\n  for (long long i = 2; i * i &lt;= k; i ++) &#123;\n    if (k % i == 0) &#123;\n      long long alpha = 0;\n      while (k % i == 0) &#123;\n        k /= i;\n        alpha ++;\n      &#125;\n      \n      divide[++ cnt][0] = i;\n      divide[cnt][1] = alpha;\n    &#125;\n  &#125;\n  \n  if (k &gt; 1) &#123;\n    divide[++ cnt][0] = k;\n    divide[cnt][1] = 1;\n  &#125;\n  \n  for (int i = 1; i &lt;= cnt; i++) &#123;\n    long long p = divide[i][0], alpha = divide[i][1], beta = cal(n, p);\n    answer = min(answer, beta / alpha);\n  &#125;\n  \n  cout &lt;&lt; answer &lt;&lt; &#x27;\\n&#x27;;\n  \n  return 0;\n&#125;\n","categories":["Solution"],"tags":["CodeForces","Math"]},{"title":"CodeForces 727F","url":"/posts/e6d5c4e8/","content":"VJudge  洛谷   Codeforces\n算法\n\n贪心\n\n\n思路\n考虑特殊情况。当 $m=1$ 时，问题转化为：给定 $a_0$, 求删除最少元素使得对于任意的 $i$，满足 $\\Sigma_{j=0}^{i} a_{j} \\ge 0$。\n将特殊情况扩展到 $m \\le 10^6$，即对于每一个给定的 $a_0$，求解上述问题。\n考虑贪心，即对于一个 $i$，满足 $\\Sigma_{j=0}^{i} a_{j} &lt; 0$， 则必定删除前面最大的负数，才会使最后的结果最优.于是可以逆向思维，倒序遍历数组 $a$，维护一个大根堆(即维护绝对值最小的负数，对于每一个 $a_{i} &lt; 0$, 将其入队；对于每一个 $a_{i} \\ge 0$，用 $a_{i}$ 抵消堆顶元素，直到堆为空或 $a_{i} &lt; 0$。\n最后将堆里的元素全部放入一个新数组，即这些负数在 $a_{1} \\to a_{n}$ 里都不能被抵消，只能由 $a_{0}$ 抵消，被删除的个数即为剩余负数的个数减去 $a_{0}$ 最多可以抵消的负数，可以二分解决。\n代码\n\n            #include &lt;bits/stdc++.h&gt;\n#define OnlineJudge\n  \nusing namespace std;\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  \n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  \n  vector&lt;long long&gt; a(n), b(m);\n\n  for (int i = 0; i &lt; n; i++) &#123;\n    cin &gt;&gt; a[i];\n  &#125;\n\n  priority_queue&lt;long long, vector&lt;long long&gt;, less&lt;long long&gt;&gt; q;\n\n  for (int i = n - 1; i &gt;= 0; i--) &#123;\n    if (a[i] &lt; 0) &#123;\n      q.emplace(a[i]);\n    &#125; else &#123;\n      while (!q.empty() &amp;&amp; a[i] &gt;= 0) &#123;\n        a[i] += q.top();\n        q.pop();\n      &#125;\n      \n      if (a[i] &lt; 0) &#123;\n        q.emplace(a[i]);\n      &#125;\n    &#125;\n    continue;\n  &#125;\n  \n  vector&lt;long long&gt; modify;\n  \n  while (!q.empty()) &#123;\n    modify.emplace_back(-q.top());\n    q.pop();\n  &#125;\n\n  // reverse(modify.begin(), modify.end());\n\n  for (int i = 1; i &lt; static_cast&lt;int&gt;(modify.size()); i++) &#123;\n    modify[i] = modify[i] + modify[i - 1];\n  &#125;\n\n  #ifndef OnlineJudge\n  for (auto&amp;&amp; var : modify) &#123;\n    cout &lt;&lt; var &lt;&lt; &quot; &quot;;\n  &#125;\n  cout &lt;&lt; &quot;\\n&quot;;\n  #endif\n\n  for (int i = 0; i &lt; m; i++) &#123;\n    cin &gt;&gt; b[i];\n\n    int answer;\n    if (modify.empty() || modify.back() &lt;= b[i]) &#123;\n      answer = 0;\n    &#125; else &#123;\n      int pos = upper_bound(modify.begin(), modify.end(), b[i]) - modify.begin();\n      answer = static_cast&lt;int&gt;(modify.size()) - pos;\n    &#125;\n\n    cout &lt;&lt; answer &lt;&lt; &#x27;\\n&#x27;;\n  &#125;\n\n  return 0;\n&#125;\n          \n","categories":["Solution"],"tags":["CodeForces","贪心"]},{"title":"OI集训 Day1","url":"/posts/999d0faf/","content":"Content：Data Structs\nDate：2025.7.17\n\n内容\n\n并查集\nST表\n线段树\n\n关于树状数组\n一维树状数组\n单点修改，区间查询\n对于这一类最普通的树状数组，没有什么好说的，直接维护前缀和即可。\nstruct BIT &#123;\n  long long tr[N];\n  \n  static int lowbit(int x) &#123;\n    return x &amp; (-x);\n  &#125;\n  \n  void add(int pos, long long value) &#123;\n    for (int i = pos; i &lt;= n; i += lowbit(i))\n      tr[i] += value;\n  &#125;\n  \n  long long query(int pos) &#123;\n    long long retval = 0;\n    for (int i = pos; i &gt; 0; i -= lowbit(i))\n      retval += tr[i];\n    return retval;\n  &#125;\n&#125; tr;\n区间修改，单点查询\n这里就需要使用到差分了。\n记 $d[i] = arr[i] - arr[i - 1]$，则我们有：\n$$\narr[i] = \\sum_{i=0}^{n} d[i]\n$$\n后面的求和可以用树状数组维护。\nstruct BIT &#123;\n  long long tr[N];\n  \n  static int lowbit(int x) &#123;\n    return x &amp; (-x);\n  &#125;\n  \n  void add(int pos, int value) &#123;\n    for (int i = pos; i &lt;= n; i += lowbit(i))\n      tr[i] += value;\n  &#125;\n  \n  long long query(int pos) &#123;\n    long long retval = 0;\n    for (int i = pos; i &gt; 0; i -= lowbit(i))\n      retval += tr[i];\n    return retval;\n  &#125;\n&#125; tr;\n这一部分的代码和上面的没什么区别，区别只有 $main()$ 函数中的输入和修改。\n对于输入：\nfor (int i = 1; i &lt;= n; i++) &#123;\n  cin &gt;&gt; a[i];\n  // 这里存储的是差分后的结果，而不是 a[i]\n  tr.add(i, a[i] - a[i - 1]);\n&#125;\n对于修改：\nint l, r, x;\ncin &gt;&gt; l &gt;&gt; r &gt;&gt; x;\n\n// 差分数组上的区间价相当于 d[l] += v, d[r + 1] -= v;\ntr.add(l, x);\ntr.add(r + 1, -x);\n区间修改，区间查询\n对于区间修改，我们沿用上面的思路，接下来我们看如何区间查询。\n差分有如下性质：\n$$\narr[i] = \\sum_{i = 0}^{n} d[i]\n$$\n而我们要求的区间和可以转化为：\n$$\n\\begin{aligned}\n\\sum_{i = l}^{r} arr[i] = \\sum_{i = 0}^{r} arr[i] - \\sum_{i = 0}^{l - 1} arr[i]\n\\end{aligned}\n$$\n所以我们的问题重新转化为了如何求解前缀和。\n$$\n\\begin{aligned}\n\\sum_{i = 0}^{r} arr[i] &amp;= \\sum_{i = 0}^{r} \\sum_{j = 0}^{i} d[j] \\\n&amp;= \\sum_{i = 0}^{r} (r - i + 1) \\cdot d[i] \\\n&amp;= \\sum_{i = 0}^{r} (r + 1) \\cdot d[i] - i \\cdot d[i] \\\n&amp;= (r + 1) \\cdot \\sum_{i = 0}^{r} d[i] - \\sum_{i = 0}^{r} d[i] \\cdot i \\\n\\end{aligned}\n$$\n所以我们用两个树状数组 $tr1, tr2$ 来分别维护两个和式，就解决了区间求和的问题。\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int N = 1e6 + 5;\nint n, q, op, a[N];\n\nint lowbit(int x) &#123; return x &amp; (-x); &#125;\n\nstruct BIT &#123;\n  long long tr[N];\n\n  void add(int pos, long long value) &#123;\n    for (int i = pos; i &lt;= n; i += lowbit(i)) tr[i] += value;\n  &#125;\n\n  long long query(int pos) &#123;\n    long long retval = 0;\n    for (int i = pos; i &gt; 0; i -= lowbit(i)) retval += tr[i];\n    return retval;\n  &#125;\n&#125; tr1, tr2;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n\n  cin &gt;&gt; n &gt;&gt; q;\n\n  for (int i = 1; i &lt;= n; i++) &#123;\n    cin &gt;&gt; a[i];\n\n    tr1.add(i, a[i] - a[i - 1]);\n    tr2.add(i, 1ll * (a[i] - a[i - 1]) * i);\n  &#125;\n\n  for (int i = 1; i &lt;= q; i++) &#123;\n    cin &gt;&gt; op;\n\n    if (op == 1) &#123;\n      int l, r, value;\n      cin &gt;&gt; l &gt;&gt; r &gt;&gt; value;\n      tr1.add(l, value);\n      tr1.add(r + 1, -value);\n      tr2.add(l, 1ll * value * l);\n      tr2.add(r + 1, -1ll * value * (r + 1));\n    &#125; else if (op == 2) &#123;\n      int l, r;\n      cin &gt;&gt; l &gt;&gt; r;\n      \n      long long ans = (tr1.query(r) * (r + 1) - tr2.query(r)) - (tr1.query(l - 1) * l - tr2.query(l - 1));\n      \n      cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n  &#125;\n\n  return 0;\n&#125;\n二维树状数组\nPre：二维前缀和\n对于二维数组的前缀和有如下公式：\n$$\nsum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + arr[i][j]\n$$\n对于左上角坐标为 $(a, b)$，右下角坐标为 $(c, d)$ 的子矩阵，其和为：\n$$\nsum[c][d] - sum[a - 1][d] - sum[c][b - 1] + sum[a - 1][b - 1]\n$$\n单点修改，区间查询\n和一维树状数组类似，直接记 $tr[i][j]$ 为左上角坐标为 $(0, 0)$，右下角坐标为 $(i, j)$ 的矩阵的和。\n修改和查询直接套公式。\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int N = 1 &lt;&lt; 12 + 5;\nint n, m, op;\n\nstruct BIT &#123;\n  vector&lt;vector&lt;long long&gt;&gt; tr;\n  \n  BIT() = default;\n  \n  BIT(int n, int m) &#123;\n    tr.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));\n  &#125;\n  \n  static int lowbit(int x) &#123;\n    return x &amp; (-x);\n  &#125;\n  \n  void add(int x, int y, long long value) &#123;\n    for (int i = x; i &lt;= n; i += lowbit(i))\n      for (int j = y; j &lt;= m; j += lowbit(j))\n        tr[i][j] += value;\n  &#125;\n  \n  long long query(int x, int y) &#123;\n    long long retval = 0;\n    for (int i = x; i &gt; 0; i -= lowbit(i))\n      for (int j = y; j &gt; 0; j -= lowbit(j))\n        retval += tr[i][j];\n    return retval;\n  &#125;\n&#125; tr;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  \n  cin &gt;&gt; n &gt;&gt; m;\n  \n  tr = BIT(n, m);\n  \n  while (cin &gt;&gt; op) &#123;\n    if (op == 1) &#123;\n      int x, y, value;\n      cin &gt;&gt; x &gt;&gt; y &gt;&gt; value;\n      \n      tr.add(x, y, value);\n    &#125; else if (op == 2) &#123;\n      int a, b, c, d;\n      \n      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n      \n      long long ans = tr.query(c, d) - tr.query(a - 1, d) - tr.query(c, b - 1) + tr.query(a - 1, b - 1);\n      \n      cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n  &#125;\n  \n  return 0;\n&#125;\n区间修改，单点查询\n我们由一维树状数组的区间修改，单点查询启发，可以考虑定义二维差分。\n定义二维差分数组（为避免名字冲突，这里定义为 $c[i][j]$）$c[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] - a[i - 1][j - 1]$。\n\n            证明观察到：$$arr[i][j] = sum[i][j] - sum[i - 1][j] - sum[i][j - 1] + sum[i - 1][j - 1]$$所以二维差分数组 $d[i][j]$ 满足：$$a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + c[i][j]$$即：$$c[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]$$\n          \n所以我们得到了二维差分数组 $c[i][j]$ 的表达式。\n跟一维差分类似地，我们可以得到子矩阵 $(a, b)$，$(c, d)$ 加法在差分数组中的等效替代：\n$$\n\\begin{aligned}\nsum(a, b, c, d, v) \\iff &amp; c[a][b] + v, c[c + 1][b] - v, \\\n&amp; c[a][d + 1] - v, c[c + 1][d + 1] + v\n\\end{aligned}\n$$\n代码如下：\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint n, m, op;\n\nstruct BIT &#123;\n  vector&lt;vector&lt;long long&gt;&gt; tr;\n  \n  BIT() = default;\n  \n  BIT(int n, int m) &#123;\n    tr.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));\n  &#125;\n  \n  static int lowbit(int x) &#123;\n    return x &amp; (-x);\n  &#125;\n  \n  void add(int x, int y, int value) &#123;\n    for (int i = x; i &lt;= n; i += lowbit(i))\n      for (int j = y; j &lt;= m; j += lowbit(j))\n        tr[i][j] += value;\n  &#125;\n  \n  long long query(int x, int y) &#123;\n    long long retval = 0;\n    for (int i = x; i &gt; 0; i -= lowbit(i))\n      for (int j = y; j &gt; 0; j -= lowbit(j))\n        retval += tr[i][j];\n    return retval;\n  &#125;\n&#125; tr;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  \n  cin &gt;&gt; n &gt;&gt; m;\n  \n  tr = BIT(n, m);\n  \n  while (cin &gt;&gt; op) &#123;\n    if (op == 1) &#123;\n      int a, b, c, d, value;\n      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; value;\n      \n      tr.add(a, b, value);\n      tr.add(a, d + 1, -value);\n      tr.add(c + 1, b, -value);\n      tr.add(c + 1, d + 1, value);\n    &#125; else if (op == 2) &#123;\n      int x, y;\n      cin &gt;&gt; x &gt;&gt; y;\n      \n      cout &lt;&lt; tr.query(x, y) &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n  &#125;\n  \n  return 0;\n&#125;\n区间修改，区间查询\n保留上面二维树状数组上区间加的操作，接下来看看如何实现区间查询。\n对于二维差分，我们有：\n$$\na[x][y] = \\sum_{i = 0}^{x} \\sum_{j = 0}^{y} d[i][j]\n$$\n对于区间查询，我们用前缀和的思路转化为：\n$$\n\\sum_{i = a}^b \\sum_{j = c}^d a[i][j] = sum[c][d] - sum[a - 1][d] - sum[b - 1][c] + sum[a - 1][b - 1];\n$$\n而对于二维前缀和，我们有：\n$$\n\\begin{aligned}\nsum[a][b] &amp;= \\sum_{i = 0}^{a} \\sum_{j = 0}^{b} \\sum_{k = 0}^{i} \\sum_{l = 0}^{j} c[k][l] \\\n&amp;= \\sum_{i = 0}^{a} \\sum_{j = 0}^b (a - i + 1) \\cdot (b - j + 1) \\cdot c[i][j] \\\n&amp;= \\sum_{I = 0}^{a} \\sum_{j = 0}^b (ab - a - b + 1) \\cdot c[i][j] -\n(b + 1) \\cdot i \\cdot c[i][j] - (a + 1) \\cdot j \\cdot c[i][j] + i \\cdot j \\cdot c[i][j]\n\\end{aligned}\n$$\n所以用四个二维树状数组分别维护 $c[i][j]$，$i \\cdot c[i][j$，$j \\cdot c[i][j]$，$i \\cdot j \\cdot c[i][j]$ 就可以了。\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint n, m, op;\n\nstruct BIT &#123;\n  vector&lt;vector&lt;long long&gt;&gt; t1, t2, t3, t4;\n  \n  BIT() = default;\n  BIT(int n, int m) &#123;\n    t1.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));\n    t2.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));\n    t3.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));\n    t4.assign(n + 1, vector&lt;long long&gt;(m + 1, 0ll));\n  &#125;\n  \n  static int lowbit(int x) &#123;\n    return x &amp; (-x);\n  &#125;\n  \n  void add(int x, int y, long long value) &#123;\n    for (int i = x; i &lt;= n; i += lowbit(i)) &#123;\n      for (int j = y; j &lt;= m; j += lowbit(j)) &#123;\n        t1[i][j] += value;\n        t2[i][j] += value * x;\n        t3[i][j] += value * y;\n        t4[i][j] += value * x * y;\n      &#125;\n    &#125;\n  &#125;\n  \n  long long query(int x, int y) &#123;\n    long long retval = 0;\n    for (int i = x; i &gt; 0; i -= lowbit(i)) &#123;\n      for (int j = y; j &gt; 0; j -= lowbit(j)) &#123;\n        retval += (x + 1) * (y + 1) * t1[i][j] - (y + 1) * t2[i][j] - (x + 1) * t3[i][j] + t4[i][j];\n      &#125;\n    &#125;\n    return retval;\n  &#125;\n&#125; tr;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  \n  cin &gt;&gt; n &gt;&gt; m;\n  \n  tr = BIT(n, m);\n  \n  while (cin &gt;&gt; op) &#123;\n    if (op == 1) &#123;\n      int a, b, c, d;\n      long long value;\n      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; value;\n      \n      tr.add(a, b, value);\n      tr.add(c + 1, b, -value);\n      tr.add(a, d + 1, -value);\n      tr.add(c + 1, d + 1, value);\n    &#125; else if (op == 2) &#123;\n      int a, b, c, d;\n      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n      \n      long long ans = tr.query(c, d) - tr.query(a - 1, d) - tr.query(c, b - 1) + tr.query(a - 1, b - 1);\n      \n      cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n  &#125;\n  \n  return 0;\n&#125;","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"Hello World!","url":"/posts/1c291ca3/","content":"New Beginning, New Future\n\n也是用 Github Page 搭建了一个新的博客。\n最近应该会把博客园的文章搬运过来（搬完了喵~），继续加油吧。\n","categories":["Others"],"tags":["Others"]},{"title":"CodeForces 1192B","url":"/posts/38dfbb09/","content":"VJudge    CodeForces\n算法\n\n欧拉序\n线段树\n\n\n思路\n对于这道题考虑使用欧拉序的性质：\n\n对于树上的每一个子树，在欧拉序上都有一个区间与之对应。\n对于 $(u, v)$ 的最近公共祖先，在欧拉序上表现为区间 $[pos_u, pos_v]$ 内深度最浅的节点。\n\n所以可以将原树转化为欧拉序，将树上问题转化为序列上的区间问题，就可以使用线段树解决。\n由于题目要求树的直径，所以用线段树查找区间最值，找到点 $(u, v)$ 的最近公共祖先 $lca$，则 $dist(u, v)$ 可以表示为：\n$$\n\\large\ndist(u,v) = dep_u + dep_v - 2 \\cdot dep_{lca}\n$$\n而直径就是 $\\max{dist(u, v)}$。\n所以原题目的问题就转化为：在欧拉序上找一个三元组 $(u, lca, v)$，满足如下条件：\n\n$dep_u + dep_v - 2 \\cdot dep_{lca}$ 最大。\n$lca$ 为区间 $[pos_u, pos_v]$ 内深度最小的节点。\n\n而第二个条件可以由第一个条件限制，所以可以忽略。\n由上面两个限制条件我们可以得到线段树需要维护的数据：\n\n$max$：区间最大值。\n$min$：区间最小值。\n$left\\ mid$（以下简称 $LM$）：三元组 $(u, lca, v)$ 中 $dep_u - 2 \\cdot dep_{lca}$ 的最大值。\n$mid\\ right$（以下简称 $RM$）：三元组 $(u, lca, v)$ 中 $dep_v - 2 \\cdot dep_{lca}$ 的最大值。\n$left\\ mid\\ right$（以下简称 $LMR$）：三元组 $(u, lca, v)$ 中 $dep_u + dep_v - 2 \\cdot dep_{lca}$ 的最大值。\n\n接下来考虑如何转移 （即为 push_up(int k) 函数）。\n对于 $max$ 和 $min$ 来说转移很简单，即为：\n$$\n\\large\n\\begin{aligned}\nmax_k &amp;= \\max(max_{lc}, max_{rc}) \\\nmin_k &amp;= \\min(min_{lc}, min_{rc}) \\\n\\end{aligned}\n$$\n而对于 $LM$ 而言，可以从三个方向转移：\n$$\n\\large\nLM = \\max(LM_{lc}, LM_{rc}, max_{lc} - 2 \\cdot min_{rc})\n$$\n对于 $MR$ 同理由：\n$$\n\\large\nMR = \\max(MR_{lc}, MR_{rc}, -2 \\cdot min_{lc} + max_{rc})\n$$\n最后合并成 $LMR$：\n$$\n\\large\nLMR = \\max(LMR_{lc}, LMR_{rc}, LM_{lc} + max_{rc}, max_{lc} + MR_{rc})\n$$\n代码\n#include &lt;bits/stdc++.h&gt;\n#define OnlineJudge\n\nconstexpr int N = 1e5 + 5;\nstd::vector&lt;int&gt; euler_seq&#123;-1&#125;;\nint in[N], out[N], num = 0;\nint head[N], cnt = 0;\nint n, q, u, v, fa[N];\nlong long W, d, w, last = 0ll, dist[N];\nstd::vector&lt;std::tuple&lt;int, int, long long&gt;&gt; input_edges;\n\nclass Edge &#123;\n public:\n  int to, next;\n  long long w;\n\n&#125; edges[N &lt;&lt; 4];\n\nvoid add_edge(int u, int v, long long w) &#123;\n  edges[cnt].to = v;\n  edges[cnt].w = w;\n  edges[cnt].next = head[u];\n  head[u] = cnt++;\n&#125;\n\nclass SegmentTree &#123;\n private:\n  class Values &#123;\n    public:\n    // ! 对 lazy 要初始化（虽然在 build 里面写了，但不知道为什么有些还是没有初始化）\n    long long max = 0, min = 0, left_mid = 0, mid_right = 0, left_mid_right = 0, lazy = 0;\n  &#125;;\n \n  class NodeInfo &#123;\n   public:\n    int left = 0, right = 0;\n    Values val;\n  &#125;;\n  \n  public:\n  NodeInfo tr[N &lt;&lt; 2];\n  \n  Values merge_tags(Values a, Values b) &#123;\n    Values retval;\n    \n    retval.max = std::max(a.max, b.max);\n    retval.min = std::min(a.min, b.min);\n    retval.left_mid = std::max(&#123;a.left_mid, b.left_mid, a.max + -2 * b.min&#125;);\n    retval.mid_right = std::max(&#123;a.mid_right, b.mid_right, -2 * a.min + b.max&#125;);\n    retval.left_mid_right = std::max(&#123;a.left_mid_right, b.left_mid_right, a.left_mid + b.max, a.max + b.mid_right&#125;);\n    \n    return retval;\n  &#125;\n  \n  void modify_tags(Values&amp; root, long long value) &#123;\n    root.lazy += value;\n    root.max += value;\n    root.min += value;\n    root.left_mid -= value;\n    root.mid_right -= value;\n  &#125;\n  \n  void push_up(int k) &#123;\n    Values lc = tr[k &lt;&lt; 1].val, rc = tr[k &lt;&lt; 1 | 1].val;\n    \n    int temp = tr[k].val.lazy;\n    tr[k].val = merge_tags(lc, rc);\n    tr[k].val.lazy = temp;\n  &#125;\n  \n  void push_down(int k) &#123;\n    if (tr[k].val.lazy == 0) &#123;\n      return void();\n    &#125;\n    \n    modify_tags(tr[k &lt;&lt; 1].val, tr[k].val.lazy);\n    modify_tags(tr[k &lt;&lt; 1 | 1].val, tr[k].val.lazy);\n    \n    tr[k].val.lazy = 0;\n  &#125;\n  \n  void build_tree(int k, int l, int r) &#123;\n    tr[k].left = l;\n    tr[k].right = r;\n    tr[k].val.lazy = 0;\n    \n    if (tr[k].left == tr[k].right) &#123;\n      tr[k].val.max = tr[k].val.min = dist[euler_seq[l]];\n      tr[k].val.left_mid = tr[k].val.mid_right = -dist[euler_seq[l]];\n      tr[k].val.left_mid_right = 0;\n      \n      #ifndef OnlineJudge\n      std::cout &lt;&lt; &quot;BUILD:\\n&quot;;\n      std::cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; tr[k].left &lt;&lt; &quot; &quot; &lt;&lt; tr[k].right &lt;&lt; &quot; &quot;;\n      std::cout &lt;&lt; tr[k].val.max &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.min &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.left_mid &lt;&lt; &quot; &quot;;\n      std::cout &lt;&lt; tr[k].val.mid_right &lt;&lt; &#x27; &#x27; &lt;&lt; tr[k].val.left_mid_right &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.lazy &lt;&lt; &#x27;\\n&#x27;;\n      #endif\n      \n      return void();\n    &#125;\n    \n    int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n    \n    build_tree(lc, l, mid);\n    build_tree(rc, mid + 1, r);\n    \n    push_up(k);\n    \n    #ifndef OnlineJudge\n    std::cout &lt;&lt; &quot;BUILD:\\n&quot;;\n    std::cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; tr[k].left &lt;&lt; &quot; &quot; &lt;&lt; tr[k].right &lt;&lt; &quot; &quot;;\n    std::cout &lt;&lt; tr[k].val.max &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.min &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.left_mid &lt;&lt; &quot; &quot;;\n    std::cout &lt;&lt; tr[k].val.mid_right &lt;&lt; &#x27; &#x27; &lt;&lt; tr[k].val.left_mid_right &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.lazy &lt;&lt; &#x27;\\n&#x27;;\n    #endif\n  &#125;\n  \n  void modify(int k, int l, int r, long long value) &#123;\n    #ifndef OnlineJudge\n    std::cout &lt;&lt; &quot;MODIFY:\\n&quot;;\n    std::cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; tr[k].left &lt;&lt; &quot; &quot; &lt;&lt; tr[k].right &lt;&lt; &quot; &quot;;\n    std::cout &lt;&lt; tr[k].val.max &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.min &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.left_mid &lt;&lt; &quot; &quot;;\n    std::cout &lt;&lt; tr[k].val.mid_right &lt;&lt; &#x27; &#x27; &lt;&lt; tr[k].val.left_mid_right &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.lazy &lt;&lt; &#x27;\\n&#x27;;\n    #endif\n    \n    if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;\n      modify_tags(tr[k].val, value);\n      return void();\n    &#125;\n    \n    push_down(k);\n    \n    int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n    \n    if (r &lt;= mid) &#123;\n      modify(lc, l, r, value);\n    &#125; else if (l &gt; mid) &#123;\n      modify(rc, l, r, value);\n    &#125; else &#123;\n      modify(lc, l, mid, value);\n      modify(rc, mid + 1, r, value);\n    &#125;\n    \n    push_up(k);\n  &#125;\n  \n  Values query(int k, int l, int r) &#123;\n    #ifndef OnlineJudge\n    std::cout &lt;&lt; &quot;QUERY:\\n&quot;;\n    std::cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; tr[k].left &lt;&lt; &quot; &quot; &lt;&lt; tr[k].right &lt;&lt; &quot; &quot;;\n    std::cout &lt;&lt; tr[k].val.max &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.min &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.left_mid &lt;&lt; &quot; &quot;;\n    std::cout &lt;&lt; tr[k].val.mid_right &lt;&lt; &#x27; &#x27; &lt;&lt; tr[k].val.left_mid_right &lt;&lt; &quot; &quot; &lt;&lt; tr[k].val.lazy &lt;&lt; &#x27;\\n&#x27;;\n    #endif\n    \n    if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;\n      return tr[k].val;\n    &#125;\n    \n    push_down(k);\n    \n    int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n    \n    if (r &lt;= mid) &#123;\n      return query(lc, l, r);\n    &#125; else if (l &gt; mid) &#123;\n      return query(rc, l, r);\n    &#125; else &#123;\n      return merge_tags(query(lc, l, mid), query(rc, mid + 1, r));\n    &#125;\n  &#125;\n&#125; data;\n\nvoid dfs(int u, int father) &#123;\n  euler_seq.emplace_back(u);\n  in[u] = euler_seq.size() - 1;\n  \n  for (int i = head[u]; ~i; i = edges[i].next) &#123;\n    int v = edges[i].to;\n    if (v == father) continue;\n\n    fa[v] = u;\n    dist[v] = dist[u] + edges[i].w;\n    dfs(v, u);\n    euler_seq.emplace_back(u);\n  &#125;\n  \n  out[u] = euler_seq.size() - 1;\n&#125;\n\nint main() &#123;\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::cout.tie(nullptr);\n  \n  std::memset(head, -1, sizeof(head));\n  \n  std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; W;\n  \n  for (int i = 1; i &lt; n; i ++) &#123;\n    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n    \n    add_edge(u, v, w);\n    add_edge(v, u, w);\n    input_edges.emplace_back(u, v, w);\n  &#125;\n  \n  dfs(1, 1);\n  \n  // ! 注意调换顺序，保证前面一个点是后面一个点的父亲\n  for (int i = 0; i &lt; n - 1; i ++) &#123;\n    if (fa[std::get&lt;0&gt;(input_edges[i])] == std::get&lt;1&gt;(input_edges[i])) &#123;\n      std::swap(std::get&lt;0&gt;(input_edges[i]), std::get&lt;1&gt;(input_edges[i]));\n    &#125;\n  &#125;\n  \n  data.build_tree(1, 1, euler_seq.size() - 1);\n  \n  #ifndef OnlineJudge\n  std::cout &lt;&lt; data.query(1, 1, euler_seq.size() - 1).left_mid_right &lt;&lt; &#x27;\\n&#x27;;\n  for (auto&amp;&amp; [u, v, w] : input_edges) &#123;\n    std::cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; v &lt;&lt; &#x27; &#x27; &lt;&lt; w &lt;&lt; &#x27;\\n&#x27;;\n  &#125;\n  #endif\n  \n  last = 0;\n  for (int i = 1; i &lt;= q; i ++) &#123;\n    std::cin &gt;&gt; d &gt;&gt; w;\n    d = (d + last) % (n - 1);\n    w = (w + last) % W;\n    \n    // ! 对于边 (u, v, w)，满足 fa[v] == u，则修改后的 w&#x27; 只对 v 的子树有影响，所以只更新 v 的子树即可。\n    data.modify(1, in[std::get&lt;1&gt;(input_edges[d])], out[std::get&lt;1&gt;(input_edges[d])], w - std::get&lt;2&gt;(input_edges[d]));\n    // ! 记得将边的信息更新\n    std::get&lt;2&gt;(input_edges[d]) = w;\n    last = data.query(1, 1, euler_seq.size() - 1).left_mid_right;\n    \n    std::cout &lt;&lt; last &lt;&lt; &#x27;\\n&#x27;;\n  &#125;\n  \n  return 0;\n&#125;\n","categories":["Solution"],"tags":["CodeForces","欧拉序","SegmentTree"]},{"title":"OI集训 Day12","url":"/posts/5c259d7b/","content":"Content：模拟赛\nDate：2025.7.28\n\nProblem-A 排序\n题目大意\n优化程序：\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nconst int N = 3e7 + 5;\nint n, seed;\ndouble a[N];\n\nvoid gen_input(const int n, const int seed) &#123;\n  double x = (double)(seed);\n  unsigned int iseed = seed;\n  for (int i = 0; i &lt; n; ++i) &#123;\n    iseed = iseed * 1664525 + 1013904223;\n    x = (std::sin(iseed % 4096) + 1) / 2;\n    a[i] = std::fabs(x * (iseed &gt;&gt; (iseed % 30))) + 1e-9;\n  &#125;\n&#125;\n\nint main() &#123;\n  std::cin &gt;&gt; n &gt;&gt; seed;\n  gen_input(n, seed);\n\n  // 你需要优化这行代码\n  std::sort(a, a + n);\n\n  double ans = 0;\n  for (int i = 0; i &lt; n; i++) &#123;\n    ans += a[i] * (i % 9);\n  &#125;\n  std::cout.precision(10);\n  std::cout &lt;&lt; std::fixed &lt;&lt; ans &lt;&lt; std::endl;\n  return 0;\n&#125;\n思路\n赛场上看到这道题目一脸懵，到底是哪个出题人出的题啊。\n赛后发现这道题其实考察的是浮点数。浮点数由于其特殊的存储特性，比较的常数是特别大的，但是将 double 类型转换为 long long 类型是不影响比较的，所以只需要添加一行代码：\nlong long *p = (long long *) (void *) a;\nsort(p, p + n);\n这里就是直接把 $a$ 数组转换为 long long 类型进行比较。\nProblem-B 北京折叠\n赛时过了，就是一个模拟。\nProblem-C Git\n思路\n赛场上的贪心策略有问题，当时想的是将子树大小大的接到小的上面，这样做的操作次数会比把小的接到大的上面的操作次数少 (就是重链剖分的思路)。\n但是这道题要求是变成一条链，所以其答案一定和深度有关，不难发现将这棵树变为一条链的最小操作次数为 $n - \\max_{u} \\operatorname{dep}(u)$。所以不应该以重链剖分的思路解这道题，而是长链剖分。其他的思路就和上面一样了。就是不断的把 $u$ 的长链剖分意义下的重儿子接到任意一个轻儿子上 (选择的轻儿子变为下一次的重儿子)，不断重复这个操作，直到 $u$ 不存在轻儿子。\nProblem-D 哈利波特魔法觉醒\n思路\n赛时考虑将每个区间的信息拆开来，即对于每个区间的每个端点维护信息，然后将其按位置排序，然后 $O(n)$ 计算每个时间点的 $k$ 连胜的概率。但是显然不是很好维护。赛时也想到了要 DP，但是状态定义为：$dp_i$ 表示到第 $i$ 个时间的 $k$ 连胜的概率，转移不好考虑。\n其实对于区间的信息可以 ==差分== 维护，再在 DP 的时候进行累加还原，即可获得获胜的概率 $p$。\n所以我们逆向思维，定义 $dp_i$ 表示以 $i$ 结尾没有 $k$ 连胜的概率。而这个转移比较好考虑。\n$$\ndp_i =\n\\begin{cases}\ndp_{i-1} - dp_{i-k-1} \\times (1-p_{i-k}) \\times \\prod_{j=0}^{k-1} p_{i-j} &amp; i \\ge k \\\n1 &amp; otherwise \\\n\\end{cases}\n$$\n即以时间 $i$ 结尾的没有 $k$ 连胜的概率为前 $i-k-1$ 个时刻里没有 $k$ 连胜的概率乘上 $1$ 减去区间 $[i-k+1,i]$ 内恰好 $k$ 连胜的概率。\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day10","url":"/posts/b22bfc57/","content":"Content：dp优化\nDate：2025.7.26\n\n例题\n洛谷-P1886 滑动窗口\n思路\n直接单调队列维护即可，具体操作如下：\n\n每次查看队尾的元素，维护单调性。\n对于队头不在当前滑动窗口的元素，弹出。\n\n提交记录：link\n洛谷-P2365 任务安排\n思路\n定义 $dp_{i}$ 表示第 $i$ 个任务完成所花费的最小代价。转移如下：\n$$\ndp_{i} = \\min_{1 \\le j \\le i} dp_{j} + (s + T_i - T_{j-1}) \\times (F_{n} - F{j - 1})\n$$\n对于本题数据范围 $n \\le 3000$，$O(n^2)$ 可过。\n提交记录：link\n洛谷-P10979 任务安排 2\n思路\n$dp$ 的方式和定义与前面相同，但是 $O(n^2)$ 的复杂度无法接受，所以考虑优化。\n将 $dp$ 的式子拆开，发现：\n$$\ndp_{i} = \\min_{1 \\le j \\le i} dp_{j} + F_{i}T_{i} - F_{j}T_{i} + F_{n}s - F_{j}s\n$$\n移项，得：\n$$\ndp_{j} = (T_{i} + s)F_{j} + (dp_{i} - F_{i}T_{i} - F_{n}s)\n$$\n很明显可以用斜率优化，单调队列维护下凸壳即可。\n提交记录：link\n洛谷-P5785 [SDOI2012] 任务安排\n思路\n注意数据范围，$\\lvert T_i \\rvert \\le 2^8$，所以 $T_{i}+s$ 不具有单调性，所以上面面直接维护的方法不可做。于是我们考虑直接维护整个下凸壳，对于转移时，二分查找就可以了。\n提交记录：link\n洛谷-P4072 [SDOI2016] 征途\n思路\n我们定义 $dp_{i,j}$ 表示到第 $i$ 天走到了第 $j$ 个城市的最小平方和。之所以这样定义，是因为：\n$$\n\\begin{aligned}\ns^2 \\times m^2 &amp;= \\frac{\\sum_{i} (s_i - \\overline{s})^2}{m} \\times m^2 \\\n&amp;= \\frac{(\\frac{\\sum_i s_i}{m})^2 - 2 \\times \\frac{\\sum_i s_i}{m} \\times \\sum_i si + \\sum_i s_i^2}{m} \\times m^2 \\\n&amp;= -(\\sum_i s_i)^2 + m \\times \\sum_i s_i^2\n\\end{aligned}\n$$\n所以最后的答案只和后面的平方和有关。\n转移还是单调队列维护下凸壳即可。\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day11","url":"/posts/c52cccc1/","content":"Content：矩阵 DP\nDate：2025.7.27\n\nReview\n矩阵基本操作：link\nExample1 - 洛谷-P1962 斐波那契数列\n\n            题目描述给定 $n$，求斐波那契数列的第 $n$ 项 $f_n$。$$f_n =\\begin{cases}1 &amp; n = 0,1 \\f_{n-1} + f_{n-2} &amp; oterwise\\end{cases}$$数据范围：$n &lt; 2^{63}$。\n          \n思路\n首先显然 $O(n)$ 的递推是不行的了，我们考虑将递推式转化为矩阵乘法的形式：\n$$\n\\begin{aligned}\n\\begin{bmatrix}\nf_{n - 1} \\\nf_{n - 2}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n1 &amp; 1 \\\n0 &amp; 1 \\\n\\end{bmatrix}\n&amp;=\n\\begin{bmatrix}\nf_{n} \\\nf_{n - 1}\n\\end{bmatrix} \\\n\\\n\\begin{bmatrix}\nf_{n - 2} \\\nf_{n - 3}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n1 &amp; 1 \\\n0 &amp; 1 \\\n\\end{bmatrix}^2\n&amp;=\n\\begin{bmatrix}\nf_{n} \\\nf_{n - 1}\n\\end{bmatrix} \\\n&amp;\\dots \\\n\\begin{bmatrix}\nf_{0} \\\nf_{1} \\\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n1 &amp; 1 \\\n0 &amp; 1\n\\end{bmatrix}^{n-2}\n&amp;=\n\\begin{bmatrix}\nf_{n}\nf_{n - 1}\n\\end{bmatrix}\n\\end{aligned}\n$$\n这里只需要矩阵快速幂即可。复杂度 $O(log n)$。\n提交记录：link\nExample2 - UVA11270 Tiling Dominoes\n\n题目描述\n给定一个 $n \\times m$ 的网格，求用 $1 \\times 2$ 的方块覆盖网格的方案数。\n数据范围：$n \\times m \\le 100$。\n\n思路\n我们考虑轮廓线 DP，定义 $dp_{i,j,s}$ 表示当前修改的点是 $(i,j)$，其状态为 $s$。这里的 $s$ 和之前题目里的不同，它表示的是第 $i$ 行的前 $j-1$ 列的覆盖情况和第 $i - 1$ 行的后 $m - j + 1$ 列的覆盖情况，其中 $0$ 表示还未被覆盖，$1$ 表示已经被覆盖。\n$dp$ 的第一维可以省略，所以转化为 $dp_{i,s}$ 表示考虑到第 $j$ 列，其状态为 $s$ 的方案数。\n接下来考虑转移，设上一行的状态为 $s$，转移有三种。\n\n当前位置不放，留空 (前提条件：$s &gt;&gt; j \\ &amp; \\ 1$)：$dp_{i-1,s} \\to dp_{i,s \\oplus (1 &lt;&lt; j)}$\n当前位置横着放 (前提条件：$j &gt; 0$ 且 $s &gt;&gt; j \\ &amp; \\ 1$)：$dp_{i-1,s} \\to dp_{i,s | (1 &lt;&lt; (j - 1))}$\n当前位置竖着放 (前提条件：$i &gt; 0$ 且 $!(s &gt;&gt; j &amp; 1)$)：$dp_{i-1,s \\oplus (1 &lt;&lt; j)} \\to dp_{i, s}$。\n\n这样就写完了。\nCode\n#include &lt;bits/stdc++.h&gt;\n\nusing std::cin;\nusing std::cout;\n\nconstexpr int N = 105;\nint n, m;\nlong long dp[2][1 &lt;&lt; 11];\n\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    while (cin &gt;&gt; n &gt;&gt; m) &#123;\n        if (n &lt; m) std::swap(n, m);\n        \n        int line = 0, max_status = 1 &lt;&lt; m;\n        std::memset(dp, 0, sizeof(dp));\n        dp[line][max_status - 1] = 1;\n        \n        for (int i = 1; i &lt;= n; i++) &#123;\n            for (int j = 0; j &lt; m; j++) &#123;\n                line = !line;\n                std::memset(dp[line], 0, sizeof(dp[line]));\n                \n                for (int status = 0; status &lt; max_status; status++) &#123;\n                    if (status &gt;&gt; j &amp; 1) &#123;\n                        dp[line][status ^ (1 &lt;&lt; j)] += dp[!line][status];\n                    &#125;\n                    if (j &gt; 0 &amp;&amp; (status &gt;&gt; (j - 1) &amp; 1) == 0 &amp;&amp; (status &gt;&gt; j &amp; 1)) &#123;\n                        dp[line][status | (1 &lt;&lt; (j - 1))] += dp[!line][status];\n                    &#125;\n                    if (i &gt; 0 &amp;&amp; (status &gt;&gt; j &amp; 1) == 0) &#123;\n                        dp[line][status | (1 &lt;&lt; j)] += dp[!line][status];\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        \n        cout &lt;&lt; dp[line][max_status - 1] &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n    \n    return 0;\n&#125;\nExample3 - 洛谷-P5678 河神\n思路\n我们一样考虑将递推式转化成矩阵乘法的形式。\n但是这里我们注意到地推中的操作是 $|$ 和 $&amp;$，所以哦我们要做 $(|,&amp;)$ 矩阵乘法 (这个需要证明 $|$ 操作对 $&amp;$ 操作具有分配律，这里就不证明了)。\n$$\n\\begin{bmatrix}\na_{n - 1} &amp; a_{n-2} &amp; a_{n-3} &amp; \\dots &amp; a_{n-k}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nb_{n-1} &amp; b_{n - 2} &amp; b_{n - 3} &amp; \\dots &amp; b_1 &amp; b_0 \\\n-1 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 \\\n0 &amp; -1 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 \\\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\n0 &amp; 0 &amp; 0 &amp; \\dots &amp; -1 &amp; 0\n\\end{bmatrix}\n\\begin{bmatrix}\na_n &amp; a_{n - 1} &amp; a_{n - 2} &amp; \\dots &amp; a_{n - k + 1}\n\\end{bmatrix}\n$$\n所以就可以使用矩阵快速幂了。\n提交记录：link。\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day13","url":"/posts/2b22aded/","content":"Content：平衡树\nDate：2025.7.29\n\n具体内容\nLeafy Tree 和 Un-leafy Tree\nLeafy Tree：表示将所有的数据存放在叶子节点的树形数据结构，类似 线段树 和 WBLT 平衡树。\nUn-leafy Tree：与 Leafy Tree 相反，将数据存放在每个树节点的数据结构。\n替罪羊树\n替罪羊树是最简单的平衡树，也是 Un-leafy 的，其核心思想是定义一个常数 $\\alpha$，对于树上任意节点 $u$，若 $\\max(siz_{ls_{u}}, siz_{rs_{u}}) \\ge \\alpha \\times siz_u$，则将整棵树拍平成数组，对整棵树重构，使其保持平衡性。\n替罪羊树的复杂度是 $O(n \\log n)$ （均摊）的，同时 $\\alpha$ 的取值对复杂度的影响是直接的，当 $\\alpha$ 在区间 $[0.5,1]$ 之间时，复杂度时最优的，一般取 $\\alpha = 0.7$。\nTreap\n旋转 Treap\n旋转 Treap 主要通过旋转来调整树的平衡。我们为每一个节点新加入一个键值 $priority$。Treap 除了在维护平衡树的性质外，还要维护对于 $priority$ 的堆的性质。而这一部分的维护靠的就是旋转操作。\n复杂度：$O(n \\log n)$ （期望）\n无旋 Treap （FHQ-Treap）\n无旋 Treap （又称 FHQ-Treap）通过分裂和合并的方式来维护树的平衡性。每次按照一个阈值将树分为两个部分，然后对树进行操作后，将两个部分合并。由于其基本操作为分裂和合并，所以可以较为简单的处理区间问题，而且码量较小，但常数较大。\n复杂度：$O(n \\log n)$ （期望）\nSplay\nSplay 的基本操作为旋转 （双旋）每次将操作的节点旋转至根节点，所以每操作一次，树的形态都会发生改变。复杂度为 $O(n \\log n)$ （均摊）\nWBLT (Weight Balanced Leafy Tree)\nWBLT 是一种 Leafy 的平衡树，将所有信息存储在叶子节点上。同替罪羊树，WBLT 也是依靠设立常数 $\\alpha$ 来保证其平衡性，复杂度为 $O(n \\log n)$ （严格）\n可持久化平衡树\n路径复制，肥节点。\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"斐波那契数列与黄金分割比的关系","url":"/posts/3a2599d0/","content":"斐波那契数列与黄金分割比的关系\n\n前言\n众所周知，斐波那契数列的递推公式为：\n$$\nf_i = \\begin{cases}\n0 &amp; i=0 \\\n1 &amp; i = 1 \\\nf_{i-1}+f_{i-2} &amp; i \\ge 2\n\\end{cases}\n$$\n为什么会把斐波那契数列与黄金分割比联系再一起呢？其实和斐波那契的通项公式有关。\n斐波那契数列的通项公式\n我们考虑使用生成函数推导斐波那契数列的通项公式（别问我为什么，问就是博客正好写了，搬运一下）。\n\n            关于生成函数生成函数是指以某个序列为系数的多项式，其形式为：$$F(x) = \\sum_{i=0} a_i x^i$$其中 $x$ 的存在并没有什么意义，所以又被称为形式幂级函数\n          \n我们定义斐波那契数列的生成函数 $F(x)$ 为：\n$$\nF(x) = \\sum_{i \\ge 0} f_i x^i\n$$\n我们对这个式子进行变换\n$$\n\\begin{aligned}\nF(x) &amp;= \\sum_{i \\ge 0} f_i x^i \\\n&amp;= f_0 + x f_1 + \\sum_{i \\ge 2} f_i x^i \\\n\\end{aligned}\n$$\n当 $i \\ge 2$ 时，$f_i = f_{i-1} + f_{i - 2}$，所以：\n$$\n\\begin{aligned}\nF(x) &amp;= f_0 + x f_1 + \\sum_{i \\ge 2} (f_{i-1} + f_{i-2}) x^i \\\n&amp;= f_0 + x f_1 + \\sum_{i \\ge 2} f_{i-1} x^i + \\sum_{i \\ge 2} f_{i-2} x^i \\\n&amp;= f_0 + x f_1 + \\sum_{i \\ge 2} f_{i-1} x^i + \\sum_{i \\ge 2} f_{i-2} x^i \\\n&amp;= f_0 + x f_1 + x \\sum_{i \\ge 2} f_{i-1} x^{i-1} + x^2 \\sum_{i \\ge 2} f_{i-2} x^{i-2} \\\n&amp;= f_0 + x f_1 + x \\sum_{i \\ge 1} f_{i} x^{i} + x^2 \\sum_{i \\ge 1} f_{i} x^i\n\\end{aligned}\n$$\n然后由 $\\displaystyle F(x) = \\sum_{i \\ge 0} f_i x^i$ 且当 $i=0$ 时，$f_0 x^0 = 0$ 可得：\n$$\n\\begin{aligned}\n&amp; F(x) = f_0 + x f_1 + x \\sum_{i \\ge 1} f_{i} x^i + x^2 \\sum_{i \\ge 1} f_{} x^i \\\n&amp; F(x) = f_0 + x f_1 + x F(x) + x^2 F(x) \\\n\\because \\ &amp; f_0 = 0, f_1 = 1 \\\n\\therefore \\ &amp; F(x) = x + x F(x) + x^2 F(x) \\\n\\end{aligned}\n$$\n合并同类项，系数化为一，得：\n$$\n\\begin{aligned}\n&amp; (1 - x - x^2) F(x) = x \\\n\\therefore \\ &amp; F(x) = \\frac{x}{1 - x - x^2}\n\\end{aligned}\n$$\n这样，我们就得到了 $F(x)$ 的封闭形式。\n对于这个式子，我们考虑使用待定系数法将其部分分式分解：\n$$\n\\begin{aligned}\n\\frac{A}{1-ax} + \\frac{B}{1-bx} &amp;= \\frac{x}{1 - x - x^2} \\\n\\\n\\frac{A - Abx + B - aBx}{1 - (a + b)x + abx^2} &amp;= \\frac{x}{1 - x - x^2} \\\n\\\n\\frac{(A+B) - (Ab + aB)x}{1 - (a + b)x + abx^2} &amp;= \\frac{x}{1 - x - x^2} \\\n\\end{aligned}\n$$\n观察两边的系数，得到一个方程组：\n$$\n\\begin{cases}\nA + B = 0 \\\nAb + aB = -1 \\\na + b = 1 \\\nab = -1 \\\n\\end{cases}\n\\Rightarrow\n\\begin{cases}\nA = \\frac{1}{\\sqrt{5}} \\\nB = - \\frac{1}{\\sqrt{5}} \\\na = \\frac{1 + \\sqrt{5}}{2} \\\nb = \\frac{1 - \\sqrt{5}}{2} \\\n\\end{cases}\n$$\n接下来我们要介绍一个前置知识——几何级数（等比数列求和）。\n\n            关于几何级数几何级数是指形式为$$\\sum_{n=0}^{\\infty} r^n$$的级数。其中 $r$ 称为公比（其实就是等比数列）。当 $|r| &lt; 1$ 时，级数收敛，其和为：$$\\sum_{n=1}^{\\infty} r^n = \\frac{1}{1 - r}$$这个就是我们接下来展开要用到的公式。\n          \n我们运用几何级数将上面最初的表达式展开：\n$$\n\\begin{aligned}\n&amp; \\frac{A}{1-ax} = A\\sum_{i=0}^{\\infty} (ax)^i = A\\sum_{i=0}^{\\infty} a^i x^i \\\n&amp; \\frac{B}{1-bx} = B\\sum_{i=0}^{\\infty} (bx)^i = B\\sum_{i=0}^{\\infty} b^i x^i \\\n\\end{aligned}\n$$\n\n    \n      \n        ▶收敛性证明\n      \n      \n        \n          用几何级数展开公式时有一个前提：$|r| &lt; 1$，而上面两个式子的 $r$ 分别为 $ax$ 和 $bx$。其中 $a = \\frac{1 + \\sqrt{5}}{2}, b = \\frac{1 - \\sqrt{5}}{2}$，所以：$$\\begin{aligned}&amp; ax = \\frac{1 + \\sqrt{5}}{2} x \\&amp; bx = \\frac{1 - \\sqrt{5}}{2} x\\end{aligned}$$对于 $a,b,x$ 存在限制：$$\\begin{cases}|\\frac{1 + \\sqrt{5}}{2} x| &lt; 1 \\\\|\\frac{1 - \\sqrt{5}}{2} x| &lt; 1\\end{cases}\\Rightarrow\\begin{cases}|\\frac{1 + \\sqrt{5}}{2}| |x| &lt; 1 \\\\|\\frac{1 - \\sqrt{5}}{2}| |x| &lt; 1\\end{cases}$$所以$$\\begin{cases}|x| &lt; |\\frac{\\sqrt{5} - 1}{2}| \\\\|x| &lt; |-\\frac{\\sqrt{5} + 1}{2}|\\end{cases}$$即$$|x| &lt; \\min\\Big(|\\frac{\\sqrt{5} - 1}{2}|, |-\\frac{\\sqrt{5} + 1}{2}|\\Big) = \\frac{\\sqrt{5} - 1}{2}$$因为 $F(x)$ 定义为形式幂级数，所以我们仅关注 $x^i$ 的系数，而不关注 $x$ 的具体的值，只要由满足条件的 $x$ 存在，就可以用上面的方式对原式展开。\n        \n      \n    \n用上面两个式子等量代换，得：\n$$\n\\begin{aligned}\nF(x) &amp;= A \\Bigg(\\sum_{i=0}^{\\infty} a^i x^i \\Bigg) + B \\Bigg( \\sum_{i=0}^{\\infty} b^i x^i \\Bigg) \\\n&amp;= \\textcolor{red}{\\frac{1}{\\sqrt{5}}} \\Bigg( \\sum_{i=0}^{\\infty} \\bigg( \\frac{1 + \\sqrt{5}}{2} \\bigg)^i x^i \\Bigg) - \\textcolor{red}{\\frac{1}{\\sqrt{5}}} \\Bigg( \\sum_{i=0}^{\\infty} \\bigg( \\frac{1 - \\sqrt{5}}{2} \\bigg) x^i \\Bigg) \\\n&amp;= \\frac{1}{\\sqrt{5}} \\Bigg( \\sum_{\\textcolor{blue}{i=0}}^{\\infty} \\bigg( \\frac{1 + \\sqrt{5}}{2} \\bigg)^i x^i - \\sum_{\\textcolor{blue}{i=0}}^{\\infty} \\bigg( \\frac{1 - \\sqrt{5}}{2} \\bigg)^i x^i \\Bigg) \\\n&amp;= \\frac{1}{\\sqrt{5}} \\sum_{i=0}^{\\infty} \\bigg( \\Big(\\frac{1 + \\sqrt{5}}{2} \\Big)^i x^i - \\Big( \\frac{1-\\sqrt{5}}{2} \\Big)^i x^i \\bigg)\\\n&amp;= \\frac{1}{\\sqrt{5}} \\sum_{i=0}^{\\infty} \\textcolor{green}{x^i} \\bigg( \\Big(\\frac{1 + \\sqrt{5}}{2} \\Big)^i - \\Big( \\frac{1-\\sqrt{5}}{2} \\Big)^i \\bigg) \\\n&amp;= \\sum_{i=0}^{\\infty} \\frac{\\big(\\frac{1 + \\sqrt{5}}{2} \\big)^i - \\big( \\frac{1-\\sqrt{5}}{2} \\big)^i}{\\sqrt{5}} x^i \\\n\\end{aligned}\n$$\n对比 $F(x)$ 最初的的定义：\n$$\nF(x) = \\sum_{i=0}^{\\infty} f_i x^i\n$$\n得斐波那契数列的通项公式为：\n$$\nf_i = \\frac{\\big(\\frac{1 + \\sqrt{5}}{2} \\big)^i - \\big(\\frac{1 - \\sqrt{5}}{2} \\big)^i}{\\sqrt{5}}\n$$\n其中就有黄金分割比 $\\phi = \\frac{\\sqrt{5} - 1}{2}$ 的相反数。\n更直观的体现\n我们已经发现了斐波那契数列的通项公式中的黄金分割比，其实黄金分割比在斐波那契数列中还有更直观的体现。\n我们取斐波那契数列相邻两项的比值：\n$$\n\\begin{aligned}\n\\frac{f_i}{f_{i+1}} &amp;= \\frac{\\big ( \\frac{1+\\sqrt{5}}{2} \\big)^i - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^i}{\\big ( \\frac{1+\\sqrt{5}}{2} \\big)^{i+1} - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}} \\\n&amp;= \\frac{ \\frac{2}{1+\\sqrt{5}} \\big( \\frac{1 + \\sqrt{5}}{2} \\big)^{\\textcolor{red}{i+1}} - \\frac{2}{1-\\sqrt{5}} \\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{\\textcolor{red}{i+1}} }{ \\big(\\frac{1+\\sqrt{5}}{2} \\big)^{i+1} - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}} \\\n&amp;= \\frac{ \\frac{\\sqrt{5} - 1}{2} \\big( \\frac{1 + \\sqrt{5}}{2} \\big)^{i+1} - \\big(\\frac{\\sqrt{5} - 1}{2} - \\sqrt{5}\\big) \\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1} }{ \\big(\\frac{1+\\sqrt{5}}{2} \\big)^{i+1} - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}} \\\n&amp;= \\frac{ \\frac{\\sqrt{5} - 1}{2} \\textcolor{red}{\\big( \\frac{1 + \\sqrt{5}}{2} \\big)^{i+1}} - \\frac{\\sqrt{5} - 1}{2} \\textcolor{red}{\\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}} - \\sqrt{5}\\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}}{ \\textcolor{red}{\\big(\\frac{1+\\sqrt{5}}{2} \\big)^{i+1}} - \\textcolor{red}{\\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}}} \\\n&amp;= \\frac{\\sqrt{5} - 1}{2} - \\frac{\\sqrt{5}\\big( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1}}{\\big(\\frac{1+\\sqrt{5}}{2} \\big)^{i+1} - \\big ( \\frac{1 - \\sqrt{5}}{2} \\big)^{i+1} } \\\n&amp;= \\frac{\\sqrt{5} - 1}{2} - \\textcolor{red}{\\frac{\\sqrt{5}}{ \\big( - \\frac{3 + \\sqrt{5}}{2} \\big)^{i+1} - 1 }} \\\n\\end{aligned}\n$$\n当 $i \\to \\infty$ 时，后面的分式的值趋向于 $0$，即：\n$$\n\\lim_{i \\to \\infty} \\frac{f_i}{f_{i+1}} = \\frac{\\sqrt{5} - 1}{2}\n$$\n所以，斐波那契数列相邻两项的比值趋向于黄金分割比 $\\phi$。\n","categories":["Others"],"tags":["Others"]},{"title":"OI集训 Day14","url":"/posts/b546384e/","content":"Content：数论\nDate：2025.7.30\n\n课堂内容\n莫比乌斯函数\n定义如下：\n$$\n\\mu(n) = \\begin{cases}\n1 &amp; n=1 \\\n(-1)^k &amp; n = p_1 p_2 p_3 \\dots p_k, \\forall p_i \\in P \\\n0 &amp; otherwise \\\n\\end{cases}\n$$\n其中莫比乌斯函数有如下性质：\n$$\n\\sum_{d|n} \\mu(d) = [n=1]\n$$\n欧拉函数\n定义如下：\n$$\n\\varphi(n) = \\sum_{i=1}^n [gcd(n,i)=1]\n$$\n其中欧拉函数具有如下性质：\n$$\n\\sum_{d|n} \\varphi(d) = n\n$$\n莫比乌斯反演\n对于任意两个数论函数 $f(n)$，$g(n)$，有如下推导：\n$$\nf(n) = \\sum_{d|n} g(d) \\Leftrightarrow g(n) = \\sum_{d|n} \\mu(d) f(\\frac{n}{d})\n$$\n例题\nLuogu-P2257 YY的GCD\n题意\n给定 $n$，$m$，求：\n$$\n\\sum_{i=1}^n \\sum_{j=1}^m [gcd(i,j) \\in Prime]\n$$\n思路\n课上没怎么听懂，自己推了下竟然推出来了。\n我们看到 $[gcd(i,j) \\in Prime]$，考虑从质数入手，可以枚举质数，这样式子化为：\n$$\n\\sum_{i=1}^n \\sum_{j=1}^m \\sum_{p \\in Prime} [gcd(\\frac{i}{p},\\frac{j}{p})=1]\n$$\n把质数枚举提到前面去，得到：\n$$\n\\begin{aligned}\n&amp; \\sum_{p \\in Prime} \\sum_{i=1}^n \\sum_{j=1}^m [gcd(\\frac{i}{p}, \\frac{j}{p}) = 1] \\\n=&amp; \\sum_{p \\in Prime} \\sum_{i=1}^{\\lfloor \\frac{n}{p} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{p} \\rfloor} [gcd(i,j) = 1]\n\\end{aligned}\n$$\n对于后面一个埃德森括号，发现可以使用莫比乌斯函数的 $\\displaystyle \\sum_{d|n} \\mu(d) = [n = 1]$ 这个性质，于是式子化为（这里钦定 $n &lt; m$）：\n$$\n\\begin{aligned}\n&amp; \\sum_{p \\in Prime} \\sum_{i=1}^{\\lfloor \\frac{n}{p} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{p} \\rfloor} \\sum_{d | gcd(i,j)} \\mu(d) \\\n=&amp; \\sum_{p \\in Prime} \\sum_{d=1}^{n} \\mu(d) \\lfloor \\frac{n}{pd} \\rfloor \\lfloor \\frac{m}{pd} \\rfloor\n\\end{aligned}\n$$\n令 $pd = t$，则：\n$$\n\\begin{aligned}\n&amp; \\sum_{p \\in Prime} \\sum_{d=1}^n \\mu(d) \\lfloor \\frac{n}{t} \\rfloor \\lfloor \\frac{m}{t} \\rfloor \\\n\\end{aligned}\n$$\n这时候这个和式就可以划分为两个互相独立的部分，所以：\n$$\n\\begin{aligned}\n&amp; \\sum_{t=1}^n \\lfloor \\frac{n}{t} \\rfloor \\lfloor \\frac{m}{t} \\rfloor \\sum_{p | t, p \\in Prime} \\mu(\\frac{t}{p})\n\\end{aligned}\n$$\n前面一个和式可以整除分块，后面的可以前缀和，这样我们就做完啦~~~\n提交记录：link\nLuogu-P3455 ZAP-Queries\n题目大意\n给定 $a$，$b$ 和 $d$，求：\n$$\n\\sum_{i=1}^{a} \\sum_{j=1}^b [gcd(i,j) = d]\n$$\n思路\n对于给定的式子，我们和第一题一样做如下变换：\n令 $n = \\frac{a}{d}, m = \\frac{b}{d}$，则\n$$\n\\begin{aligned}\n&amp; \\sum_{i=1}^n \\sum_{j=1}^m [gcd(i,j) = 1] \\\n=&amp; \\sum_{i=1}^n \\sum_{j=1}^m \\sum_{k | gcd(i,j)} \\mu(k) \\\n=&amp; \\sum_{k=1}^n \\sum_{i=1}^{\\lfloor \\frac{n}{k} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{k} \\rfloor} \\mu(k) \\\n=&amp; \\sum_{k=1}^n \\mu(k) \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor\n\\end{aligned}\n$$\n所以又变回了第一题的整除分块加前缀和了。\n提交记录：link\nLuogu-P3327 约数个数和\n题目大意\n已知函数 $d(n)$ 表示整数 $n$ 的约数个数，给定 $n,m$ 求：\n$$\n\\sum_{i=1}^n \\sum_{j=1}^m d(ij)\n$$\n思路\n对于函数 $d(n)$，可以发现这是一个积性函数，但是不是一个完全积性函数，所以不能把 $d(ij)$ 拆成 $d(i) \\times d(j)$。\n但是对于这个形式的函数 $d(n)$，我们可以根据定义发现另一个更优秀的性质：\n$$\nd(ij) = \\sum_{x|i} \\sum_{y|j} [gcd(x,y) = 1]\n$$\n通过枚举原来的 $i,j$，加上容斥，我们就可以把 $d(ij)$ 写开来，这样有利于后面的变换。\n$$\n\\begin{aligned}\n&amp; \\sum_{i=1}^n \\sum_{j=1}^m d(ij) \\\n=&amp; \\sum_{i=1}^n \\sum_{j=1}^m \\sum_{x|i} \\sum_{y|j} [gcd(x,y) = 1] \\\n=&amp; \\sum_{i=1}^n \\sum_{j=1}^m \\sum_{x|i} \\sum_{y|j} \\sum_{d|gcd(x,y)} \\mu(d) \\\n=&amp; \\sum_{x=1}^n \\sum_{y=1}^m \\lfloor \\frac{n}{x} \\rfloor \\lfloor \\frac{m}{y} \\rfloor \\sum_{d|gcd(x,y)} \\mu(d) \\\n=&amp; \\sum_{d=1}^n \\mu(d) \\sum_{x=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{y=1}^{\\lfloor \\frac{m}{d} \\rfloor} \\lfloor \\frac{n}{x} \\rfloor \\lfloor \\frac{m}{y} \\rfloor \\\n=&amp; \\sum_{d=1}^n \\mu(d) (\\sum_{x=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\lfloor \\frac{n}{xd} \\rfloor) (\\sum_{y=1}^{\\lfloor \\frac{m}{d} \\rfloor} \\lfloor \\frac{m}{yd} \\rfloor )\n\\end{aligned}\n$$\n令 $f(x) = \\displaystyle \\sum_{i=1}^n \\lfloor \\frac{n}{i} \\rfloor$，则原式可以表达为：\n$$\n\\begin{aligned}\n\\sum_{d=1}^n \\mu(d) f(\\lfloor \\frac{n}{d} \\rfloor) f(\\lfloor \\frac{m}{d} \\rfloor)\n\\end{aligned}\n$$\n对于 $\\mu(d), f(n)$ 均可以预处理得到，剩下的就是整除分块了。\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day16","url":"/posts/5b485962/","content":"Content：生成函数，多项式，期望\nDate：2025.8.1\n\n课堂内容\n生成函数\n定义\n\n普通生成函数（OGF）：普通生成函数的定义为形式幂级数：$\\displaystyle F(x) = \\sum_{i} a_i x^i$\n指数生成函数（EGF）：指数生成函数的定义为形式幂级数：$\\displaystyle F(x) = \\sum_{i} a_i \\frac{x^i}{i!}$\n\n普通生成函数的基本运算\n\n$\\displaystyle F(x) \\pm G(x) = \\sum_{i} (a_i \\pm b_i) x^i$\n$\\displaystyle F(x)G(x) = \\sum_{n} x^n \\sum_{i=0}^n a_i b_{n-i}$\n封闭形式。e.g.\n\n$\\displaystyle F(x) = \\sum_{n \\ge 0} x^n = \\frac{1}{1-x}$\n证明：\n$$\n\\begin{aligned}\n&amp; F(x) = 1 + x + x^2 + x^3 + \\dots + x^n \\\n&amp; xF(x) = x + x^2 + x^3 + x^4 + \\dots + x^(n+1) \\\n&amp; \\therefore F(x) - xF(x) = 1 \\to F(x) = \\frac{1}{1-x}\n\\end{aligned}\n$$\n其他的普通生成函数也可以由这样的变换得到其封闭形式。\n\n\n\n指数生成函数的基本运算\n$$\n\\begin{aligned}\nF(x)G(x) &amp;= \\sum_{i \\ge 0} a_i \\frac{x^i}{i!} \\sum_{j \\ge 0} b_j \\frac{x^j}{j!} \\\n&amp;= \\sum_{n \\ge 0} x^n \\sum_{i=0}^n \\binom{n}{i} a_i b_{n-i} \\frac{1}{i!(n-i)!} \\\n&amp;= \\sum_{n \\ge 0} \\frac{x^n}{n!} \\sum_{i=0}^n \\binom{n}{i} a_i b_{n-i}\n\\end{aligned}\n$$\n即 $F(x)G(x)$ 的结果是序列 $\\displaystyle \\sum_{i=0}^n \\binom{n}{i} a_i b_{n-i}$ 的指数生成函数。\n例题\nLuogu-P10780 BZOJ3028 食物\n思路\n我们把每个食物的生成函数学出来再相乘，得到：\n$$\n\\begin{aligned}\n&amp; (\\frac{1}{1-x^2})(x+1)(x^2+x+1)(\\frac{x}{1-x^2})(\\frac{1}{1-x^4})(x^3+x^2+x+1)(x+1)(\\frac{1}{1-x^3}) \\\n=&amp; \\frac{x}{x^4-4x^3+6x^2-4x+1} \\\n=&amp; \\frac{x}{(x-1)^4}\n\\end{aligned}\n$$\n展开后得到：\n$$\n\\sum_{n \\ge 1} \\frac{n(n+1)(n+2)x^n}{6}\n$$\n所以答案就为：$\\displaystyle \\frac{n(n+1)(n+2)}{6}$.最后，注意取模。\n提交记录：link\nCodeForces-280C Game On Tree\n思路\n由于期望具有线性性：\n$$\nE(x+y) = E(x) + E(y)\n$$\n所以答案就是每个点被选中的概率之和。\n因为每个点被选中的概率只和这个点到根节点的长度为 $dep(u)$ 的链有关（即 $u$ 的祖先）。所以这个点被选中的概率即为 $\\displaystyle \\frac{1}{dep(u)}$。答案即为：\n$$\n\\sum_{u} \\frac{1}{dep(u)}\n$$\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day18","url":"/posts/bcf07465/","content":"Content：构造\nDate：2025.8.3\n\n课堂内容\n完全图匹配构造\n描述\n对于一个 $n$ （$n \\mid 2$） 个顶点的完全图，将其分为 $n-1$ 个匹配。\n思路\n我们将其中一个点提出来，剩下的 $n-1$ 个点形成一个正多边形，然后将提出的那个点放在中心。\n对于每一条 “斜率” 相同的边，我们把他们放在一个方案中，然后对这个方案进行旋转，就构造了 $n-1$ 个匹配。\n\n完全图曼哈顿路构造\n描述\n对于一个包含 $n$ 个点的完全图，要求将其分成 $\\lfloor n / 2 \\rfloor$ 条曼哈顿路。\n思路\n\n\n当 $n \\mid 2$ 时\n我们将这些点排成一个正 $n$ 边形，然后做如下构造：\n\n还是通过第一个构造方案的旋转得出其他的方案。\n\n\n当 $n \\nmid 2$ 时\n我们考虑通过上面的构造延伸，构造一个 正 $(n-1)$ 边形，然后在中间加入一个点，把每一条曼哈顿路的起点和中点和这个点相连，就得到了 $n$ 为奇数时的构造。下面是其中一条曼哈顿回路。\n\n\n\n后记\n今天晚上听了演唱会，所以别问我为什么现在才写。不过演唱会还挺好听的喵~\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day17","url":"/posts/2c4f69f4/","content":"Content：博弈论\nDate：2025.8.2\n\n课堂内容\nSG 函数\n表示当前游戏局面的函数，后手必胜当且仅当 SG 函数为 0。\n多个游戏的组合的 SG 函数为每个游戏的 SG 函数的 异或和。\n经典模型\n取石子游戏\n题目描述\n有 $n$ 堆石子，A、B 轮流取，每次从任意一堆中取出至少一个石子，不能取的输，问谁赢。\n解法\n一堆大小为 $n$ 的 SG 函数为 $n$，根据 SG 函数的性质，可以发现整个游戏的 SG 函数为 $\\displaystyle \\bigotimes_{i=1}^n SG_i$。\n阶梯取石子游戏\n题目描述\n有 $n$ 堆石子放在台阶上，A、B 轮流取，每次从任意一堆中取出至少一个石子，放到下一个台阶上（如果在第 1 个台阶，则扔掉），不能取的输，问谁赢。\n思路\n可以发现最后的答案之和奇数层的石子有关，所以整个游戏的 SG 函数为所有奇数层 SG 函数的异或和。\n树状取石子游戏\n题目描述\n在一颗大小为 $n$ 的树上有 $n$ 堆石子，A、B 轮流取，每次从任意一堆中取出至少一个石子，移动到他的父亲节点（如果在 1 号节点，则扔掉），不能取的输，问谁赢。\n思路\n跟上面的其实是一样的，只不过这里的答案只跟奇数层的节点的 SG 函数的异或和有关。\nBash 博弈\n题目描述\n有 $n$ 堆石子，A、B 轮流取，每次从任意一堆中取出至少一个石子，至多取 $m$ 个，不能取的输，问谁赢。\n思路\n每个石子堆的 SG 函数为 $n \\bmod (m+1)$，异或起来即可。\n1-动态减法游戏\n题目描述\n有一个正整数 $n$，A、B 轮流在上面减去一个数，第一个人至多减 $n-1$，后面每个人减的数不超过上一次的，最先吧这个数减到 0 的人获胜。问最后谁赢。\n思路\n先手每次都可以取原数的 $lowbit$（人类智慧），所以后手必胜当且仅当 $n = 2^k$。\n2-动态减法游戏\n题目描述\n有一个正整数 $n$，A、B 轮流在上面减去一个数，第一个人至多减 $n-1$，后面每个人减的数不超过上一次的 两倍 ，最先吧这个数减到 0 的人获胜。问最后谁赢。\n思路\n对原数进行斐波那契分解，先手每次取最低位的 1 （人类智慧 $\\times$ 2)，所以后手必胜当且仅当 $n$ 为斐波那契数。\nk-动态减法游戏\n题目描述\n有一个正整数 $n$，A、B 轮流在上面减去一个数，第一个人至多减 $n-1$，后面每个人减的数不超过上一次的 $k$ 倍，最先吧这个数减到 0 的人获胜。问最后谁赢。\n思路\n只需要一种满足任何表示方法中最低非零位的值的 $k$ 倍小于次低非\n零位。\n每次将新加入的数设为前面的数能表示的最大值 $+1$ 即可 （人类智慧 $\\times$ 3）。\nNimK 游戏\n题目大意\n有 $n$ 堆石头，A、B 轮流取，每次从至多 $k$ 堆中取出至少一个石头，不能取的输，问最后谁赢。\n思路\n求 SG 函数在 $k+1$ 进制下的不进位加法。\nAnti-Nim 游戏\n题目大意\n同 普通取石子游戏规则，但是不能操作的人胜利。\n思路\n先手必胜的条件为：\n\nSG 函数的和为 0 且所有游戏的 SG 函数的值均不大于 1；\nSG 函数的和不等于 0 且至少一个游戏的 SG 函数值大于 1。\n\n例题\nAGC017-D Game On Tree\n思路\n对于每一个子树，其 SG 函数为所有子节点的 SG 函数加上一条边的状态，即 $\\displaystyle SG_u = \\bigotimes_{v \\in son(u)} (SG_v + 1)$。\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day19","url":"/posts/cbf744f3/","content":"Content：欢乐 ACM\nDate：2025.8.4\n\n内容\n休息一天喵o(〃＾▽＾〃)o~\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day2","url":"/posts/945e15/","content":"Content：Segment Tree\nDate：2025.7.18\n\n主题\n\n线段树进阶\n\n关于线段树\n区间操作\n\n对于区间开根号我们可以记录最大值和最小值，然后维护极差，由此将区间开根号转化为区间加和区间覆盖问题，减小修改操作的复杂(度，均摊后复杂度为 $\\Theta(n \\log n \\log^2 V)$。（题目：HDU 5828）\n对于区间取模的操作，我们依然记录最大值，对于 $max &lt; P$ 的区间不做修改，从而降低复杂度。（题目：CodeForces 438D）\n对于区间 $gcd$ 操作，我们可以对原数组进行差分，得到差分数组 $d$，而区间 $[l, r]$ 的 $gcd$ 即为 $gcd(a_l, d_{l + 1}, d_{l + 2}, \\dots, d_{r})$。（题目：洛谷 P10463）\n\n二维数点问题\n\n二维数点问题是在一个平面中，有若干个点 $(x_i, y_i)$，询问你在矩形 $(a, b)$，$(c, d)$ 中包括了多少个点。\n离线后的二维数点问题可以用线段树扫描线解决，相当于在线的主席树。\n题目：CodeForces 1221F。\nCode:\n\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int N = 1e6 + 5, M = 1e6 + 5;\nint n;\nvector&lt;int&gt; pos;\nvector&lt;pair&lt;int, int&gt;&gt; a[M];\n\nclass Point &#123;\n public:\n  int x, y, w;\n&#125; points[N];\n\nclass SegmentTree &#123;\n  class Values &#123;\n   public:\n    long long max, add;\n    int index;\n  &#125;;\n  \n  class Node &#123;\n   public:\n    int left, right;\n    Values val;\n    \n    Node() = default;\n    Node(int l, int r) : left(l), right(r), val() &#123;&#125;\n  &#125;;\n  \n  Node tr[M &lt;&lt; 2];\n  \n  static int get_lc(int k) &#123; return k &lt;&lt; 1; &#125;\n  static int get_rc(int k) &#123; return k &lt;&lt; 1 | 1; &#125;\n  int get_mid(int k) &#123; return (tr[k].left + tr[k].right) &gt;&gt; 1; &#125;\n  \n  void make_lazy_add(int k, long long val) &#123;\n    tr[k].val.add += val;\n    tr[k].val.max += val;\n  &#125;\n  \n  void push_up(int k) &#123;\n    int lc = get_lc(k), rc = get_rc(k);\n    \n    if (tr[lc].val.max &gt; tr[rc].val.max) &#123;\n      tr[k].val.max = tr[lc].val.max;\n      tr[k].val.index = tr[lc].val.index;\n    &#125; else &#123;\n      tr[k].val.max = tr[rc].val.max;\n      tr[k].val.index = tr[rc].val.index;\n    &#125;\n  &#125;\n  \n  void push_down(int k) &#123;\n    if (tr[k].val.add == 0)\n      return void();\n    \n    int lc = get_lc(k), rc = get_rc(k);\n    \n    make_lazy_add(lc, tr[k].val.add);\n    make_lazy_add(rc, tr[k].val.add);\n    \n    tr[k].val.add = 0;\n  &#125;\n  \n public:\n  void build_tree(int k, int l, int r) &#123;\n    tr[k] = Node(l, r);\n    \n    if (tr[k].left == tr[k].right) &#123;\n      tr[k].val.max = -pos[l - 1];\n      tr[k].val.index = l;\n      return void();\n    &#125;\n    \n    int mid = get_mid(k);\n    int lc = get_lc(k), rc = get_rc(k);\n    \n    build_tree(lc, l, mid);\n    build_tree(rc, mid + 1, r);\n    \n    push_up(k);\n  &#125;\n  \n  void modify(int k, int l, int r, int val) &#123;\n    if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;\n      make_lazy_add(k, val);\n      return void();\n    &#125;\n    \n    push_down(k);\n    \n    int mid = get_mid(k);\n    int lc = get_lc(k), rc = get_rc(k);\n    \n    if (r &lt;= mid) &#123;\n      modify(lc, l, r, val);\n    &#125; else if (l &gt; mid) &#123;\n      modify(rc, l, r, val);\n    &#125; else &#123;\n      modify(lc, l, mid, val);\n      modify(rc, mid + 1, r, val);\n    &#125;\n    \n    push_up(k);\n  &#125;\n  \n  pair&lt;long long, long long&gt; query(int k, int l, int r) &#123;\n    if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;\n      return make_pair(tr[k].val.max, tr[k].val.index);\n    &#125;\n    \n    push_down(k);\n    \n    int mid = get_mid(k);\n    int lc = get_lc(k), rc = get_rc(k);\n    \n    if (r &lt;= mid) &#123;\n      return query(lc, l, r);\n    &#125; else if (l &gt; mid) &#123;\n      return query(rc, l, r);\n    &#125; else &#123;\n      return max(query(lc, l, mid), query(rc, mid + 1, r));\n    &#125;\n  &#125;\n&#125; seg;\n\nint get_index(int val) &#123;\n  return lower_bound(pos.begin(), pos.end(), val) - pos.begin() + 1;\n&#125;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  \n  cin &gt;&gt; n;\n  \n  for (int i = 1; i &lt;= n; i ++) &#123;\n    cin &gt;&gt; points[i].x &gt;&gt; points[i].y &gt;&gt; points[i].w;\n    \n    pos.emplace_back(points[i].x);\n    pos.emplace_back(points[i].y);\n    \n    if (points[i].x &gt; points[i].y) &#123;\n      swap(points[i].x, points[i].y);\n    &#125;\n  &#125;\n  \n  sort(pos.begin(), pos.end());\n  pos.erase(unique(pos.begin(), pos.end()), pos.end());\n  \n  int limit = 0;\n  for (int i = 1; i &lt;= n; i ++) &#123;\n    points[i].x = get_index(points[i].x);\n    points[i].y = get_index(points[i].y);\n    \n    limit = max(limit, points[i].y);\n    \n    a[points[i].x].emplace_back(points[i].y, points[i].w);\n  &#125;\n  \n  seg.build_tree(1, 1, limit);\n  \n  long long answer = -1ll &lt;&lt; 60, left = 0, right = 0;\n  for (int line = limit; line &gt;= 1; line --) &#123;\n    for (auto p : a[line]) &#123;\n      seg.modify(1, p.first, limit, p.second);\n    &#125;\n    \n    pair&lt;long long, long long&gt; result = seg.query(1, line, limit);\n    result.first += pos[line - 1];\n    \n    if (result.first &gt; answer) &#123;\n      answer = result.first;\n      left = pos[line - 1];\n      right = pos[result.second - 1];\n    &#125;\n  &#125;\n  \n  if (answer &lt; 0) &#123;\n    answer = 0;\n    left = 1e9 + 1, right = 1e9 + 1;\n  &#125;\n  \n  cout &lt;&lt; answer &lt;&lt; &quot;\\n&quot;;\n  cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &#x27;\\n&#x27;;\n  \n  return 0;\n&#125;\n线段树分治\n\n线段树分治问题，即在线段树上进行递归，依据线段树的结构性质完成的一类问题。\n这类问题的特点是：具有明显的前后/时间关系，且删除操作不易实现，但插入操作可以较容易的实现。\n题目：洛谷 P5787\nCode:\n\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nbool satisfied[N];\nint n, m, k, u, v, l, r;\n\nclass DSU &#123;\n  int fa[N &lt;&lt; 1], size[N &lt;&lt; 1];\n  stack&lt;pair&lt;int *, int&gt;&gt; stk;\n\n public:\n  void init(int limit) &#123;\n    for (int i = 1; i &lt;= limit; i++) fa[i] = i, size[i] = 1;\n  &#125;\n\n  int find(int x) &#123;\n    if (fa[x] != x) return find(fa[x]);\n    return x;\n  &#125;\n\n  void merge(int u, int v) &#123;\n    u = find(u);\n    v = find(v);\n    if (u == v) return void();\n\n    if (size[u] &gt; size[v]) swap(u, v);\n\n    stk.emplace(fa + u, fa[u]);\n    stk.emplace(size + v, size[v]);\n    fa[u] = v;\n    size[v] += size[u];\n  &#125;\n\n  bool check(int x, int y) &#123; return find(x) == find(y); &#125;\n\n  int get_version() &#123; return stk.size(); &#125;\n\n  void undo(int version) &#123;\n    while (stk.size() &gt; version) &#123;\n      *stk.top().first = stk.top().second;\n      stk.pop();\n    &#125;\n  &#125;\n&#125; d;\n\nclass SegmentTree &#123;\n  class Node &#123;\n   public:\n    int left, right;\n    vector&lt;pair&lt;int, int&gt;&gt; edges;\n\n    Node() = default;\n    Node(int l, int r) : left(l), right(r) &#123; edges.clear(); &#125;\n  &#125;;\n\n  Node tr[N &lt;&lt; 2];\n\n  static int get_lc(int k) &#123; return k &lt;&lt; 1; &#125;\n  static int get_rc(int k) &#123; return k &lt;&lt; 1 | 1; &#125;\n  int get_mid(int k) &#123; return (tr[k].left + tr[k].right) &gt;&gt; 1; &#125;\n\n public:\n  void build_tree(int k, int l, int r) &#123;\n    tr[k] = Node(l, r);\n\n    if (tr[k].left == tr[k].right) &#123;\n      return void();\n    &#125;\n\n    int mid = get_mid(k);\n    int lc = get_lc(k), rc = get_rc(k);\n\n    build_tree(lc, l, mid);\n    build_tree(rc, mid + 1, r);\n  &#125;\n\n  void add_edge(int k, int l, int r, pair&lt;int, int&gt; edge) &#123;\n    if (tr[k].left &gt;= l &amp;&amp; tr[k].right &lt;= r) &#123;\n      tr[k].edges.emplace_back(edge);\n      return void();\n    &#125;\n\n    int mid = get_mid(k);\n    int lc = get_lc(k), rc = get_rc(k);\n\n    if (r &lt;= mid) &#123;\n      add_edge(lc, l, r, edge);\n    &#125; else if (l &gt; mid) &#123;\n      add_edge(rc, l, r, edge);\n    &#125; else &#123;\n      add_edge(lc, l, mid, edge);\n      add_edge(rc, mid + 1, r, edge);\n    &#125;\n  &#125;\n\n  void dfs(int k) &#123;\n    bool flag = true;\n    int version = d.get_version();\n\n    for (auto edge : tr[k].edges) &#123;\n      if (d.check(edge.first, edge.second)) &#123;\n        flag = false;\n        break;\n      &#125; else &#123;\n        d.merge(edge.first, edge.second + n);\n        d.merge(edge.first + n, edge.second);\n      &#125;\n    &#125;\n\n    if (flag == false) &#123;\n      for (int i = 1; i &lt;= tr[k].right - tr[k].left + 1; i++) &#123;\n        cout &lt;&lt; &quot;No\\n&quot;;\n      &#125;\n    &#125; else &#123;\n      if (tr[k].left == tr[k].right) &#123;\n        cout &lt;&lt; &quot;Yes\\n&quot;;\n      &#125; else &#123;\n        int lc = get_lc(k), rc = get_rc(k);\n\n        dfs(lc);\n        dfs(rc);\n      &#125;\n    &#125;\n\n    d.undo(version);\n  &#125;\n&#125; seg;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n\n  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n\n  d.init(n &lt;&lt; 1);\n  seg.build_tree(1, 1, k);\n\n  for (int i = 1; i &lt;= m; i++) &#123;\n    cin &gt;&gt; u &gt;&gt; v &gt;&gt; l &gt;&gt; r;\n\n    if (l == r) continue;\n    seg.add_edge(1, l + 1, r, make_pair(u, v));\n  &#125;\n\n  seg.dfs(1);\n\n  return 0;\n&#125;\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day20","url":"/posts/9906af94/","content":"Content：字符串\nDate：2025.8.5\n\n课堂内容\n字符串哈希\n定义哈希函数 $H(s)$:\n$$\nH(s) = \\sum_{i=1}^n base^{n-i} s_i \\bmod P\n$$\n其中 $base$ 大于字符集大小。这个哈希函数的冲突概率为 $\\frac{1}{P}$。\n通过这个定义，我们可以通过前缀和处理，得到这个字符串上每个区间的哈希值。\n树哈希 （重点）\n定义哈希函数 $H(u)$，表示以 $u$ 为根节点的子树的哈希值。\n$$\nH(u) = \\sum_{i} H(son(u, i))^{1 + \\sum_{j&lt;i} 2 \\times size(son(u, j))} + 1 + 2 \\times base^{2 \\times size(u) - 1}\n$$\n其中 $son(u, i)$ 表示 $u$ 的第 $i$ 个儿子，$size(u)$ 表示以 $u$ 为根节点的子树的大小。\n字典树\n字典树就没什么好讲的了，注意一下 0/1 字典树就行。\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day22","url":"/posts/7708ceb8/","content":"Content：字符串进阶-2\nDate：2025.8.7\n\n课堂内容\n后缀数组\n后缀数组主要指两个数组 $sa$ 和 $rank$：\n\n$sa_i$ 表示所有后缀中按字典序大小从小到大排序后排名为 $i$ 的后缀的起始位置。\n$rank_i$ 表示以 $i$ 为起始位置的后缀的排名。\n\n其中这两个数组有如下性质：\n$$\nsa_{rank_i} = rank_{sa_i} = i\n$$\n可以使用倍增 + 基数排序的方式求解 $sa$ 和 $rank$ 数组，复杂度 $O(n \\log n)$。\n除此之外，还有一个 $height$ 数组表示 $sa_i$ 和 $sa_{i-1}$ 两个后缀的 LCP (Longest Common Prefix) 的长度。\n模版题：Luogu-P10469 后缀数组\n提交记录：Link\n例题\nLuogu-P3809 后缀排序\n题目大意\n给定一个长度为 $n$ 的仅由小写字母组成的字符串，将其所有后缀按字典序从小到大排序后，求排名为 $i$ 的后缀的起始位置。\n思路\n就是后缀数组的简单应用，求出 $sa$ 数组后输出即可。注意下标的问题。\n提交记录：Link\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day24","url":"/posts/9e6b6b8d/","content":"Content：模拟赛\nDate：2025.8.9\n\nProblem-A IEEE 754\n题目描述\n题目背景告诉你浮点数表示法(IEEE 754 标准)，要求你求 $5^n$，其中 $n &lt; 1024$。\n思路\n赛场上是直接写的高精度，但是赛后看过题解发现有更简单的做法。\n首先用 Python 计算发现，$5^1023$ 大约有 800 位，而 double 类型的存储精度有 308 位，所以可以用 double 类型计算，但是要计算的是 $5^(-n)$，因为是浮点数。\n提交记录：Link\nProblem-B 探险\n题目描述\n给定一个数组 $a$，有两个人轮流操作，每次交换一对 $i,j$，谁进行操作后数组 $a$ 有序（从小到大），则这个人获胜。同时有 $q$ 个修改操作，分为两类：\n\n$1$ $i$ $j$：将 $a_i$ 与 $a_j$ 交换。\n$2$ $k$：将 $a$ 循环位移 $k$ 次。\n你需要对于初始状态和每一个修改后的状态，判断是先手获胜还是后手获胜。\n\n思路\n赛场上想到了逆序对，但是时间比较少，只剩 $15$ 分钟了，而且最后开的这道题，所以脑子不太好使，就没有想出来。\n赛后发现赛时的思路大致是对的，但是没有继续思考下去。容易发现答案和逆序对个数的奇偶性有关，具体来说：\n\n当逆序对个数为 奇数 时，先手获胜；\n当逆序对个数为 偶数 时，后手获胜\n所以问题落在了如何处理修改后的逆序对变化。\n\n对于第一个操作是好求的，因为交换两个数，逆序对个数的奇偶性就会变化。而对于第二个操作，可以发现每一个跨过 $k$ 的两个数的逆序对都会反过来，所以对答案的影响就是 $k(n-k) \\bmod 2$（赛时就是这里没有想出来）。\n提交记录：Link\nProblem-C 帕奇欧\n题目描述\n初始时，你手上有 1 张 A 类牌和 1 张 B 类牌。每一回合你都可以从拥有的牌中等概率选取一张，然后获得一张与抽取出来的牌同类型的牌，问你经过无限轮操作后，拥有 $x$ 张 A 类牌和 $y$ 张 B 类牌的概率，对 $10^9 + 7$ 取模。\n思路\n手玩一下样例可以发现，答案为 $\\frac{(x + y - 3)! * (x + y - 2)}{(x + y - 1)}$ (这是赛时没化简得结果)。\n化简后是 $\\frac{1}{x + y - 1}$。\n提交记录：Link\nProblem-D 比赛\n题目描述\n有一种比赛，每一次比赛有若干个小节，率先得到 $M$ 分得人赢下这个小节。给定 $x,y,M$，求最后总分为 $x,y$ 时不同得小节数。\n思路\n赛时推了下式子，没推出来 TAT。\n首先可以发现的是，满足题目要求得小节数是一段连续的区间。\n所以我们可以分别找到这个区间的上界和下界。容易发现上界为 $\\lfloor \\frac{x}{M} \\rfloor + \\lfloor \\frac{y}{M} \\rfloor$。而下界通过分析可以发现是 $\\max(\\lceil \\frac{x - tx}{M} \\rceil, \\lceil \\frac{y - ty}{M} \\rceil, \\lceil \\frac{x + y}{M - 1} \\rceil)$，其中 $tx = \\lfloor \\frac{x}{M} \\rfloor, ty = \\lfloor \\frac{y}{M} \\rfloor$。\n提交记录：Link\nProblem-E 三目运算符\n题目描述\n给定一个只包含 $0,1,x,?,:$ 的合法三目运算符表达式，你可以将其中的 $x$ 替换为 0/1，求所有表达式的值的和对 $10^9 + 7$ 取模的结果。\n思路\n赛时直接枚举 $x$ 的取值，竟然有 80pts 的暴力分，出题人还是太良心了。\n正解是考虑和表达式树一样的结果，即对于每个节点，都有走向 0/1 的两条路，问题转化为了走向值为 1 的叶子节点的概率。\n提交记录：Link\nProblem-F 卡牌游戏\n题目描述\n你有三种不同类型的卡牌，其中每种卡牌的数量由给定的字符串决定。同时你拥有两个数组 $A,B$，你需要从卡牌中选取恰好 $k$ 张，设你选择的三种卡牌的数量分别为 $x,y,z$，则你的得分为 $A_x \\times B_y \\times 2^z$。求最大得分。\n思路\n赛时直接枚举前两种卡牌的个数，得了 20 分。\n可以发现第三种卡牌的贡献最大。设最多能选 $t$ 张第三种卡牌，则所有 $z &lt; t-60$ 的方案均更差。即使 $A_x,B_y$ 的值从 $10^9 \\times 10^9$ 变为了 $1 \\times 1$，即变为原来的 $\\frac{1}{10^{18}}$，而 $2^60 &gt; 10^{18}$，所以变化后的结果依然更优，所以只要考虑 $t - 60 \\le z \\le t$ 的方案即可。\n提交记录：先欠着吧。\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day21","url":"/posts/ee019f02/","content":"Content：字符串算法进阶\nDate：2025.8.6\n\nLuogu-P13270 最小表示法\n题意\n给定一个长度为 $n$ 的字符串 $s$，求 $s$ 的最小表示法。\n思路\n首先如果暴力的话，复杂度是 $O(n^2)$ 的，但是我们发现如果我们当前已经发现了一个最小表示法，我们想要找到一个比这个还小的表示法，那么一定存在一个位置，使得这个位置上的字符不相等，根据这个就可以把复杂度优化到 $O(n)$。\n提交记录：Link。\nLuogu-P5357 AC自动机\n题意\n给定一个字符串 $s$ 和 $n$ 个模式串 $t_i$，求每个模式串在字符串 $s$ 中的出现次数。\n思路\n首先我们可以对 $s$ 建一个 AC 自动机，然后统计每个模式串在这个 AC 自动机的字典树上经过了那些节点，然后打标记。再建出 Fail 树，然后在 Fail 树上对标记求和。\n提交记录：Link。\n模拟题 - 嗑瓜子\n题意\n有一个人在嗑 $n$ 个瓜子，每次在瓜子中等概率拿出一个，有以下两种情况：\n\n如果拿出的是瓜子，则吃掉，并把壳扔回瓜子中。\n如果拿出的是壳，则将其丢弃。\n求他吃掉所有瓜子的期望。\n\n思路\n定义 $dp_{i,j}$ 表示有 $i$ 个瓜子和 $j$ 个壳的期望。根据题意写出转移即可。\nImportant：注意空间，因为 $j_{max}$ 可以达到 $2 \\times n$，所以第二维要开到两倍。\nCode\n#include &lt;iostream&gt;\n#define OnlineJudge\n\nusing std::cin;\nusing std::cout;\n\nconstexpr int MOD = 998244353;\nconstexpr int N = 4005;    // ! 注意两倍空间\nlong long dp[N][N];\n\nlong long QuickPow(long long base, long long pow) &#123;\n    long long result = 1;\n    while (pow) &#123;\n        if (pow &amp; 1) result = result * base % MOD;\n        base = base * base % MOD;\n        pow &gt;&gt;= 1;\n    &#125;\n    return result;\n&#125;\n\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int n;\n    cin &gt;&gt; n;\n    \n    dp[n][0] = 1;\n    \n    for (int i = n - 1; i &gt;= 0; i--) &#123;\n        for (int j = (n - i) * 2; j &gt;= (i == 0 ? 2 : 0); j--) &#123;\n            if (i == 0) &#123;\n                dp[i][j] = QuickPow(j - 1, MOD - 2) * dp[i + 1][j - 2] % MOD;\n            &#125; else &#123;\n                if (j &lt; 2) &#123;\n                    dp[i][j] = (j + 1) * QuickPow(i + j + 1, MOD - 2) % MOD * dp[i][j + 1] % MOD;\n                &#125; else if (j == (n - i) * 2) &#123;\n                    dp[i][j] = (i + 1) * QuickPow(i + j - 1, MOD - 2) % MOD * dp[i + 1][j - 2] % MOD;\n                &#125; else &#123;\n                    dp[i][j] = ((i + 1) * QuickPow(i + j - 1, MOD - 2) % MOD * dp[i + 1][j - 2] % MOD + (j + 1) * QuickPow(i + j + 1, MOD - 2) % MOD * dp[i][j + 1] % MOD) % MOD;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    #ifndef OnlineJudge\n    for (int i = 0; i &lt;= n; i++) &#123;\n        for (int j = 0; j &lt;= 2 * (n - i); j++) &#123;\n            cout &lt;&lt; dp[i][j] &lt;&lt; &#x27; &#x27;;\n        &#125;\n        cout &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n    #endif\n    \n    long long answer = 0;\n    for (int i = 1; i &lt;= n * 2; i++) &#123;\n        answer = (answer + (3 * n - i) * dp[0][i] % MOD) % MOD;\n    &#125;\n    \n    cout &lt;&lt; answer &lt;&lt; &#x27;\\n&#x27;;\n    \n    return 0;\n&#125;\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day15","url":"/posts/c24108d8/","content":"Content：组合数学\nDate：2025.7.31\n\n课堂内容\n容斥原理\n其主要思想为：把禁止违反哪些规则改为钦定违反了哪几条规则，并赋予 $(-1)^k$ （即违反 $k$ 条规则）的容斥系数。\n二项式反演\n$$\n\\begin{aligned}\ng(n) &amp;= \\sum_{i=0}^n \\binom{n}{i} f(i) \\Leftrightarrow f(n) = \\sum_{i=0}^n (-1)^{n-i} \\binom{n}{i} g(i) \\\ng(n) &amp;= \\sum_{i=n}^N \\binom{i}{n} f(i) \\Leftrightarrow f(n) = \\sum_{i=n}^N (-1)^{i-n} \\binom{i}{n} g(i)\n\\end{aligned}\n$$\n例题\nLuogu-P1450 [HAOI2018] 硬币购物\n题目大意\n给定硬币面值 $c_1, c_2, c_3, c_4$ 和硬币个数 $d_1, d_2, d_3, d_4$，求恰好凑齐 $s$ 元的方案数。$T$ 组询问。\n思路\n首先我们可以对硬币做完全背包，这样我们就知道了用这些硬币可以凑出那些。\n然后带上限制条件，做容斥即可。\n提交记录：link\nAGC005D ~K Perm Counting\n题目大意\n给定 $N,K$，求所有满足 $|a_i - i| \\ne k$ 的长度为 $N$ 的排列的个数。\n思路\n参考 Dreamunk 大佬的题解。将所有的不合法的情况之间连边，我们就得到了若干条不合法的链，对这些链进行 DP 后，就可以容斥了。\n提交记录：link\n最后的最后，还是要说一句 我恨计数\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day23","url":"/posts/7708ceb8/","content":"Content：交互、通信、提交答案题\nDate：2025.8.8\n\n题目\nCodeForces-P1672E notepad.exe\n题目大意\n交互题。\n有 $n$ 个长度分别为 $l_i$ 的单词，要求将这些单词排放在一个记事本当中，每两个单词之间需要空格（换行不需要）。你最多可以询问 $n+30$ 次，每次可以询问一个宽度 $w$，裁判会告诉你至少需要高度为 $h$ 的记事本才可以放下所有的单词，求 $\\min{ hw }$。\n思路\n考虑先用 30 次找出将所有单词放在一行所需的最少宽度 $w_0$，然后对于每一个 $1 \\le i \\le n$，询问排列成 $i$ 行需要的最少行数，询问次数正好 $n + 30$ 次。\n提交记录：Link\nCodeForces-1010B Rocket\n题目大意\n交互题。\n你可以问裁判 60 次问题，裁判会根据一个循环节长度为 $n$ 的数组回答你的问题：如果 $a_i = 0$，则第 $i$ 次回答的是假话；如果 $a_i = 1$，则第 $i$ 次回答的是真话。你并不知道这个数组 $a$。你需要猜一个数 $x (1 \\le x \\le m)$。每次询问你可以问裁判一个数，他会回答你这个数是 大于(1)、等于(0)、小于(-1)（遵守之前的规则）。\n思路\n首先范围 $m \\le 10^9 &lt; 2^{30}$，所以我们可以先用 30 次机会，每次询问 1，就可以得到数组 $a$。然后二分答案 $x$ 就可以了，总询问次数为 60 次。\n提交记录：Link\nLuogu-P1337 平衡点 / 吊打 XXX\n题目大意\n求 $n$ 个点的带权费马点。\n思路\n考虑使用模拟退火，随机检查，剩下的就交给阳寿吧（WA $\\times$ 6）。\n提交记录：Link\nLuogu-P5285 [十二省联考] 骗分过样例\n写这道题上来只是小小的心灵受到了大大的震撼。怎么做到再 $20$ 组数据中找规律的啊！\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day4","url":"/posts/e9f7fb20/","content":"Content：Math\nDate：2025.7.20\n\n内容\n\n矩阵\n线性方程组\n行列式\n矩阵树定理\n线性基\n\n具体内容\n矩阵\n矩阵定义\n\n            定义将一些元素排列成若干行，每行放上相同数量的元素，就是一个矩阵 (Matrix)。对于矩阵 $A$ 的第 $i$ 行，第 $j$ 列，我们记作 $a_{i,j}$ 或 $a_{ij}$。对于举证 $A_{m \\times n}$，如果 $m = n$，则我们称矩阵 $A$ 为方阵。\n          \n矩阵基本操作\n\n矩阵加法：对于矩阵 $A_{m \\times n}$, $B_{m \\times n}$, 我们定义矩阵加法为：\n$$\nC_{i,j} = A_{i, j} + B_{i, j}\n$$\n即矩阵对应位置上的元素之和。   \n            注意只有当两个矩阵的大小相同时，才可以进行矩阵加法。\n          \n\n标量乘法：对于矩阵 $A_{m \\times n}$ 和标量 $x$, 我们定义矩阵的标量乘法为：\n$$\nC_{i, j} = A_{i, j} \\times x\n$$\n转置：对于矩阵 $A_{m \\times n}$，其转置为:\n$$\nA^{T} =\n\\begin{bmatrix}\nA_{j, i}\n\\end{bmatrix}\n$$\n矩阵的拼接：对于矩阵 $A_{m \\times n_1}$，$B_{m \\times n_2}$，其拼接为记为 $(A \\ | \\ B)$，其大小为 $m \\times (n_1 + n_2)$。\n矩阵的乘法：对于矩阵 $A_{m \\times n}$ 和矩阵 $B_{n \\times k}$，其矩阵乘法定义为：\n$$\nC_{i, j} = \\sum_{x = 1}^{n} A_{i, x} \\times B_{x, j}\n$$\n其中 $i \\in [1,n]$，$j \\in [1,k]$。\n对于矩阵乘法，有如下性质：\n\n矩阵乘法具备分配律：$(A + B)C = AC + BC$；\n矩阵乘法具有结合律：$(AB)C = A(BC)$;\n\n \n            注意矩阵乘法不具备交换律！\n          \n\n矩阵乘法单位元：\n            矩阵乘法单位元矩阵的乘法单位元 $I$ 为矩阵主对角线上全部为 $1$，其余均为 $0$ 的 $0/1$ 矩阵。\n          \n\n矩阵的逆：如果对于矩阵 $A$ 存在矩阵 $B$，使得 $AB = I$，则 $B$ 称作矩阵 $A$ 的逆元，记作 $A^{-1}$。\n对于逆元我们可以使用高斯消元求解。我们对矩阵 $(A \\ | \\ I)$ 进行高斯消元，最后会得到 $(I \\ | \\ B)$ (若无法把左边化为乘法单位元，则矩阵 $A$ 不存在逆元)，则 $B$ 就为 $A$ 的逆元。\n\n矩阵与线性方程组\n对于线性方程组\n$$\n\\begin{cases}\na_{1,1} x_1 + a_{1,2} x_2 + \\dots + a_{1,n} x_n = b_1 \\\na_{2,1} x_1 + a_{2,2} x_2 + \\dots + a_{2,n} x_n = b_2 \\\n\\vdots \\\na_{m,1} x_1 + a_{m,2} x_2 + \\dots + a_{m,n} x_n = b_m\n\\end{cases}\n$$\n将未知数的系数写成矩阵的形式，用系数所在的矩阵的行表示未知数，我们就得到了线性方程组的矩阵 (增广矩阵) 表达形式：\n$$\n\\begin{pmatrix}\n\\begin{array}{ccccc|c}\na_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; \\dots &amp; a_{1,n} &amp; b_1 \\\na_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; \\dots &amp; a_{2,n} &amp; b_2 \\\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\na_{m,1} &amp; a_{m,2} &amp; a_{m,3} &amp; \\dots &amp; a_{m,n} &amp; b_m \\\n\\end{array}\n\\end{pmatrix}\n$$\n对于线性方程组，我们通常会使用消元来求解。在矩阵表示下的线性方程组可以用高斯消元来求解。\n高斯消元是通过对矩阵进行初等变换，以保证在方程的解不变的情况下求出方程的解。一般来说步骤如下 (记增广矩阵为 $M$)：\n\n枚举变量 $i$ ($i \\in [1,m]$) 表示当前要对未知元 $x_i$ 进行消元操作。\n寻找最大的 $j \\in [i,m]$，使得 $a_{j, i} \\ne 0$，交换 $M_i \\longleftrightarrow M_j$。\n将交换后的矩阵的第 $i$ 行的未知元 $x_i$ 的系数化为 $1$，即: $a_{i,j} \\leftarrow \\frac{a_{i,j}}{a_{i,i}}$ ($j \\in [1,m]$)。\n用矩阵的第 $i$ 行对矩阵的第 $j$ ($j \\in [i + 1,m]$) 行进行消元操作，即：$a_{j,k} \\leftarrow a_{j,k} - a_{j,k} \\times a_{j,i}$。\n重复上述操作直到 $i &gt; n$ 或者找不到满足条件 $2$ 中的 $j$。\n\n最后的结果可能会有以下三种\n\n如果 $i &lt; n$，且存在 $j$ 使得 $a_{j,n} &gt; 0$，则原线性方程组无解。\n如果 $i &lt; n$，且对于 $\\forall j$ 满足 $a_{j,n} = 0$，则原线性方程组有无数解。\n否则原线性方程组有唯一解。\n\n洛谷 P3389 Code\n  #include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconstexpr int N = 105;\nconstexpr double eps = 1e-8;\n\nclass Matrix &#123;\n    double mat[N][N] = &#123;&#123;0&#125;&#125;;\n    int size = 0;\n\n    public:\n    Matrix() = default;\n\n    void input_matrix() &#123;\n        cin &gt;&gt; size;\n\n        for (int i = 0; i &lt; size; i++)\n            for (int j = 0; j &lt;= size; j++)\n                cin &gt;&gt; mat[i][j];\n    &#125;\n\n    int guess() &#123;\n        int i, j, r = 0;\n        for (int c = 0; c &lt; size; c++) &#123;\n            int t = r;\n            for (i = t + 1; i &lt; size; i++) &#123;\n                if (abs(mat[i][c]) &gt; abs(mat[t][c])) &#123;\n                    t = i;\n                &#125;\n            &#125;\n\n            if (abs(mat[t][c]) &lt; eps) continue;\n\n            for (i = c; i &lt;= size; i++) &#123;\n                swap(mat[t][i], mat[r][i]);\n            &#125;\n\n            for (i = size; i &gt;= c; i--) &#123;\n                mat[r][i] /= mat[r][c];\n            &#125;\n\n            for (i = r + 1; i &lt; size; i++) &#123;\n                if (abs(mat[i][c]) &gt; eps) &#123;\n                    for (j = size; j &gt;= c; j--) &#123;\n                        mat[i][j] -= mat[r][j] * mat[i][c];\n                    &#125;\n                &#125;\n            &#125;\n\n            r++;\n        &#125;\n\n        if (r &lt; size) &#123;\n            return -1;\n        &#125;\n\n        for (i = size - 1; i &gt;= 0; i--) &#123;\n            for (j = i + 1; j &lt; size; j++) &#123;\n                mat[i][size] -= mat[i][j] * mat[j][size];\n            &#125;\n        &#125;\n\n        return 1;\n    &#125;\n\n    int get_size() const &#123; return size; &#125;\n\n    double get_solution(int i) const &#123; return mat[i][size]; &#125;\n&#125;;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    Matrix matrix;\n\n    matrix.input_matrix();\n\n    if (matrix.guess() == -1) &#123;\n        cout &lt;&lt; &quot;No Solution\\n&quot;;\n    &#125; else &#123;\n        for (int i = 0; i &lt; matrix.get_size(); i++) &#123;\n            double answer = matrix.get_solution(i);\n            if (abs(answer) &lt; eps) &#123;\n                answer = 0;\n            &#125; else &#123;\n                answer = round(answer * 100.00) / 100.00;\n            &#125;\n\n            cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; answer &lt;&lt; &quot;\\n&quot;;\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n洛谷 P2455 Code\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int N = 110;\nconst double eps = 1e-8;\nint n;\ndouble a[N][N];\n\nint gauss() &#123;\n    int i, j, c, r = 0;\n    \n    for (c = 0; c &lt; n; c ++) &#123;\n        int t = r;\n        for (i = t + 1; i &lt; n; i ++)\n            if (abs(a[i][c]) &gt; abs(a[t][c])) t = i;\n        \n        if (abs(a[t][c]) &lt; eps) continue;\n        \n        for (i = c; i &lt;= n; i ++) swap(a[t][i], a[r][i]);\n        \n        for (i = n; i &gt;= c; i --) a[r][i] /= a[r][c];\n        \n        for (i = r + 1; i &lt; n; i ++)\n            if (abs(a[i][c]) &gt; eps)\n                for (j = n; j &gt;= c; j --)\n                    a[i][j] -= a[r][j] * a[i][c];\n        \n        r ++;\n    &#125;\n    \n    if (r &lt; n) &#123;\n        for (i = r; i &lt; n; i ++)\n            if (abs(a[i][n]) &gt; eps) return 2;\n        return 1;\n    &#125;\n    \n    for (i = n - 1; i &gt;= 0; i --)\n        for (j = i + 1; j &lt; n; j ++)\n            a[i][n] -= a[i][j] * a[j][n];\n            \n    return 0;\n&#125;\n\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    \n    for (int i = 0; i &lt; n; i ++) &#123;\n        for (int j = 0; j &lt;= n; j ++) &#123;\n            scanf(&quot;%lf&quot;, &amp;a[i][j]);\n        &#125;\n    &#125;\n    \n    int t = gauss();\n    if (t == 2) puts(&quot;-1&quot;);\n    else if (t == 1) puts(&quot;0&quot;);\n    else &#123;\n        for (int i = 0; i &lt; n; i ++) &#123;\n            printf(&quot;x%d=&quot;, i + 1);\n            if (abs(a[i][n]) &lt; eps) a[i][n] = 0;\n            printf(&quot;%.2lf\\n&quot;, a[i][n]);\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;\n除了高斯消元外，我们还有另外一种消元的方式——高斯-约旦消元，下面给出代码。\n洛谷 P3389 Code\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconstexpr int N = 105;\nconstexpr double eps = 1e-8;\n\nclass Matrix &#123;\n    double mat[N][N] = &#123;&#123;0&#125;&#125;;\n    int size = 0;\n\n    public:\n    Matrix() = default;\n\n    void input_matrix() &#123;\n        cin &gt;size;\n\n        for (int i = 0; i &lt; size; i++)\n            for (int j = 0; j &lt;= size; j++)\n                cin &gt;mat[i][j];\n    &#125;\n\n    int guess() &#123;\n        int i, j, r = 0;\n        for (int c = 0; c &lt; size; c++) &#123;\n            int t = r;\n            for (i = t + 1; i &lt; size; i++) &#123;\n                if (abs(mat[i][c]) abs(mat[t][c])) &#123;\n                    t = i;\n                &#125;\n            &#125;\n\n            if (abs(mat[t][c]) &lt; eps) continue;\n\n            for (i = c; i &lt;= size; i++) &#123;\n                swap(mat[t][i], mat[r][i]);\n            &#125;\n\n            for (i = size; i &gt;= c; i--) &#123;\n                mat[r][i] /= mat[r][c];\n            &#125;\n\n            for (i = r + 1; i &lt; size; i++) &#123;\n                if (abs(mat[i][c]) eps) &#123;\n                    for (j = size; j &gt;= c; j--) &#123;\n                        mat[i][j] -= mat[r][j] * mat[i][c];\n                    &#125;\n                &#125;\n            &#125;\n\n            r++;\n        &#125;\n\n        if (r &lt; size) &#123;\n            return -1;\n        &#125;\n\n        for (i = size - 1; i &gt;= 0; i--) &#123;\n            for (j = i + 1; j &lt; size; j++) &#123;\n                mat[i][size] -= mat[i][j] * mat[j][size];\n            &#125;\n        &#125;\n\n        return 1;\n    &#125;\n\n    int get_size() const &#123; return size; &#125;\n\n    double get_solution(int i) const &#123; return mat[i][size]; &#125;\n&#125;;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    Matrix matrix;\n\n    matrix.input_matrix();\n\n    if (matrix.guess() == -1) &#123;\n        cout &lt;&lt; &quot;No Solution\\n&quot;;\n    &#125; else &#123;\n        for (int i = 0; i &lt; matrix.get_size(); i++) &#123;\n            double answer = matrix.get_solution(i);\n            if (abs(answer) &lt; eps) &#123;\n                answer = 0;\n            &#125; else &#123;\n                answer = round(answer * 100.00) / 100.00;\n            &#125;\n\n            cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; answer &lt;&lt; &quot;\\n&quot;;\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n行列式\n定义\n对于矩阵 (通常为方阵) $A_{n \\times n}$，我们定义其行列式为：\n$$\n\\det(A) = \\sum_{p \\in P_n} \\operatorname{sgn}(p) \\prod_{i=0}^{n} A_{i,p_i}\n$$\n其中 $P_n$ 表示长度为 $n$ 的所有排列的集合，$\\operatorname{sgn}(p)$ 表示 $(-1)^{排列 p 中的逆序对的个数}$。\n这里有一张快速求解行列式的图：\n\n性质\n\n对矩阵做行 (列) 交换，行列式反号。\n            根据排列的奇偶性，我们可以知道交换一个排列中的一对元素，其排列奇偶性也会发生变化，所以 $\\operatorname{sgn}(p) = -\\operatorname{sgn}(p^{\\prime})$，证毕。\n          \n\n对矩阵做行 (列) 数乘，行列式乘上同样的常数\n            我们知道一个排列包含 $[1,n]$ 之间的所有整数，所以被修改的元素会在每个连乘中出现且每个连乘中仅出现一次，所以可以提到整个式子的前面，证毕。\n          \n\n对矩阵做行 (列) 加法，行列式不变。\n\n求解行列式\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconstexpr int N = 605;\nint n;\nlong long p;\n\nclass Matrix &#123;\n    long long mat[N][N] = &#123;&#123;&#125;&#125;;\n    int size = 0;\n\n    public:\n    Matrix() = default;\n\n    void get_input(int n) &#123;\n        size = n;\n\n        for (int i = 1; i &lt;= size; i++) &#123;\n            for (int j = 1; j &lt;= size; j++) &#123;\n                cin &gt;mat[i][j];\n            &#125;\n        &#125;\n    &#125;\n\n    long long det(const long long ModValue) &#123;\n        long long retval = 1, sgn = 1;\n\n        for (int i = 1; i &lt;= size; i++) &#123;\n            for (int j = i + 1; j &lt;= size; j++) &#123;\n                while (mat[i][i]) &#123;\n                    long long divide = mat[j][i] / mat[i][i];\n\n                    for (int k = 1; k &lt;= size; k++) &#123;\n                        mat[j][k] = (mat[j][k] - divide * mat[i][k] % ModValue + ModValue) % ModValue;\n                    &#125;\n\n                    sgn = -sgn;\n                    swap(mat[i], mat[j]);\n                &#125;\n\n                sgn = -sgn;\n                swap(mat[i], mat[j]);\n            &#125;\n        &#125;\n\n        retval = sgn;\n        for (int i = 1; i &lt;= size; i ++) &#123;\n            retval = retval * mat[i][i] % ModValue;\n        &#125;\n\n        return (retval + ModValue) % ModValue;\n    &#125;\n&#125; matrix;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    cin &gt;n &gt;p;\n\n    matrix.get_input(n);\n\n    cout &lt;&lt; matrix.det(p) &lt;&lt; &#x27;\\n&#x27;;\n\n    return 0;\n&#125;\n矩阵树定理 (根本听不懂啊)\n矩阵树定理是把图的生成树个数和矩阵行列式联系起来的一个定理。\n矩阵树定理\n对于无自环 (允许重边) 的有向图 $G = (V, E)$。设出度矩阵 $D(G)$，其中 $\\forall u \\in V$，$D_{u,u}$表示点 $u$ 的出度，其余位置全部为 $0$。而 $A(G)$ 表示图 $G$ 的邻接矩阵，其中 $a_{i,j}$ 表示 $i \\to j$ 的边的数量 ($i,j \\in V$)。那么可以得到对应的拉普拉斯矩阵 $L(G) = D(G) - A(G)$。\n$L(G)$ 关于 $L(G)_{k,k}$ 的余子式是以 $k$ 为根节点的内向生成树的个数。\n余子式\n对于矩阵 $A$，$A_{i,j}$ 的余子式定义为 $A$ 去掉第 $i$ 行第 $j$ 列的矩阵行列式。\n线性基\n定义\n在 $K$ 维异或空间下，一个向量可以用一个 $[0,2^k)$ 内的整数表示 (即该数在二进制意义下的每一位都表示一个向量)。\n对于一组向量 $S = {v_1, v_2, v_3, \\dots, v_n}$：\n\n$S$ 中数字的异或和称为这些向量的线性组合。\n若不存在非空子集 $W \\subset S$ 满足 $\\bigotimes_{v \\in W} v = 0$，则称 $S$ 线性无关。\n$S$ 的所有子集的异或和的集合构成 $S$ 的张成，记作 $\\operatorname{Span}(S)$。\n$S$ 的线性基是一个线性无关的向量集合 $W$，满足 $\\operatorname{Span}(W) = \\operatorname{Span}(S)$。\n$K$ 维空间的线性基 $W$ 满足 $\\left\\vert W \\right\\vert = K$。\n\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day5","url":"/posts/9ef0cbb6/","content":"Content: Problem on Tree\nDate：2025.7.21\n\n概览\n\n树的重心\n树上启发式合并\n树链剖分\n左偏树\n点分治\n\n具体内容\n树的重心\n定义\n\n            树的重心树的重心是满足如下条件的点 $u$:树上不存在其他节点 $v$，使得 $\\max{\\operatorname{siz}(son_v)} &lt; \\max{\\operatorname{size}(son_u)}$。\n          \n性质\n树的重心 $G$ 有如下性质：\n\n            树的重心的性质当以 $G$ 为根节点时，不能存在 $v$ 满足 $\\max_{\\forall v \\in \\operatorname{son}(u)}{\\operatorname{size}(v)} &gt; \\frac{N}{2}$ ($N$为整棵树的大小)。反之亦然。树中所有节点到 $G$ 的距离之和最小，如果有两个重心，则距离相同。如果两棵树的重心分别为 $G_1$，$G_2$，则两棵树由一条边拼接起来之后，新树的重心一定在 $G_1$ 到 $G_2$ 的路径上。在一棵树上加入 (或删除) 一个叶子节点，其重心只移动一条边的距离。树的重心一定在以根节点为链头的重链上。\n          \n例题\nCF685B Kay and Snowflake\n\n            题目大意：求一颗大小为 $n$ ($1 \\le n \\le 10^{5}$) 有根树的所有子树的重心。\n          \n考虑运用性质 $4$，对整棵树进行 $dfs$，每次用子节点的重心暴力向上跳，再用性质 $1$ 检查，复杂度 $\\Theta(n \\log n)$。\nCode\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconstexpr int N = 3e5 + 5;\nint head[N], cnt = 0;\nint n, q, father[N], query_node;\nint son[N], sub_size[N], answer[N];\n\nstruct Edge &#123;\n    int to, next;\n&#125; e[N &lt;&lt; 1];\n\nvoid add_edge(const int u, const int v) &#123;\n    e[cnt].to = v;\n    e[cnt].next = head[u];\n    head[u] = cnt++;\n&#125;\n\nvoid dfs(const int u) &#123;\n    sub_size[u] = 1;\n\n    for (int i = head[u]; ~i; i = e[i].next) &#123;\n        const int v = e[i].to;\n        if (v == father[u]) continue;\n\n        dfs(v);\n        sub_size[u] += sub_size[v];\n\n        if (son[u] == 0 || sub_size[v] &gt; sub_size[son[u]]) &#123;\n            son[u] = v;\n        &#125;\n    &#125;\n\n    if (son[u] == 0) &#123;\n        answer[u] = u;\n    &#125; else &#123;\n        answer[u] = answer[son[u]];\n\n        while (answer[u] != u) &#123;\n            if (sub_size[son[answer[u]]] * 2 &lt;= sub_size[u] &amp;&amp; (sub_size[u] - sub_size[answer[u]]) * 2 &lt;= sub_size[u]) &#123;\n                break;\n            &#125;\n            answer[u] = father[answer[u]];\n        &#125;\n    &#125;\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    memset(head, -1, sizeof(head));\n\n    cin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 2; i &lt;= n; i++) &#123;\n        cin &gt;&gt; father[i];\n        add_edge(i, father[i]);\n        add_edge(father[i], i);\n    &#125;\n\n    dfs(1);\n\n    while (q--) &#123;\n        cin &gt;&gt; query_node;\n        cout &lt;&lt; answer[query_node] &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n\n    return 0;\n&#125;\n树上启发式合并\n算法内容\n对于某些问题，暴力的复杂度远远大于 $std$ 的复杂度，我们可以考虑启发式合并的思想。\n启发式合并时人类对于算法的主观优化，我们以按秩合并的并查集为例。\n并查集\nstruct DSU &#123;\n    int father[N], size[N];\n    void init(int limit) &#123;\n        std::iota(father + 1, father + n + 1, 1);\n        std::memset(size, 1, sizeof(size));\n    &#125;\n\n    int find(int x) &#123;\n        if (father[x] != x) father[x] = find(father[x]);\n        return father[x];\n    &#125;\n\n    bool check(int x, int y) &#123;\n        return find(x) == find(y);\n    &#125;\n\n    void merge(int x, int y) &#123;\n        x = find(x), y = find(y);\n        if (x == y) return void();\n\n        // 按秩合并\n        if (size[x] &gt; size[y]) &#123;\n            swap(x, y);\n        &#125;\n\n        father[x] = y;\n    &#125;\n&#125;\n通过人的主观感受，我们可以知道将大小更小的子树合并到大小更大的子树上一定是更优的。树上启发式合并也是这种思想。我们通过和树链剖分类似的方法，将子节点分为重儿子和轻儿子，对于统计答案时，我们对重儿子统计的答案保留，对轻儿子统计的答案进行撤销，这样保证了复杂度的正确性。\n例题\nCF600E Lomsat gelral\n\n            题目描述给定一个有根树，每个点有一个颜色 $c_i$，对每个子树，求所有出现最多的颜色的和。$n \\le 10^{5}$\n          \n我们开一个桶记录每一种颜色再子树内的出现次数，并同时维护两个变量：\n\n$max$：当前出现最多的颜色出现的次数。\n$sum$：出现最多的颜色的和。\n\n每次我们遍历的时候先遍历轻儿子，再遍历重儿子，传入一个标记 $f$，表示当前的统计数据是否保留，并根据题意维护 $max$ 和 $sum$ 即可。\nCode\n#include &lt;bits/stdc++.h&gt;\n\nusing std::cin;\nusing std::cout;\n\nconstexpr int N = 1e5 + 5;\nint head[N], cnt = 0;\nint n, col[N], u, v;\nint tot[N], size[N], son[N], father[N], dfn = 0;\nlong long max = 0, sum = 0, answer[N];\n\nclass Edge &#123;\npublic:\n    int to, next;\n\n    Edge(const int to = 0, const int next = 0) : to(to), next(next) &#123;&#125;\n&#125; e[N &lt;&lt; 1];\n\nvoid add_edge(const int u, const int v) &#123;\n    e[cnt] = Edge(v, head[u]);\n    head[u] = cnt++;\n&#125;\n\nvoid dfs1(const int u, const int fa) &#123;\n    size[u] = 1;\n    father[u] = fa;\n    \n    for (int i = head[u]; ~i; i = e[i].next) &#123;\n        int v = e[i].to;\n        if (v == fa) continue;\n\n        dfs1(v, u);\n        size[u] += size[v];\n\n        if (son[u] == 0 || size[v] &gt; size[son[u]]) &#123;\n            son[u] = v;\n        &#125;\n    &#125;\n&#125;\n\nvoid update(const int u, const int val, const int ban) &#123;\n    tot[col[u]] += val;\n    if (tot[col[u]] == max) &#123;\n        sum += col[u];\n    &#125; else if (tot[col[u]] &gt; max) &#123;\n        max = tot[col[u]];\n        sum = col[u];\n    &#125;\n    \n    for (int i = head[u]; ~i; i = e[i].next) &#123;\n        const int v = e[i].to;\n        if (v == father[u] || v == ban) &#123;\n            continue;\n        &#125;\n        \n        update(v, val, ban);\n    &#125;\n&#125;\n\nvoid dfs2(const int u, const bool heavy_son) &#123;\n    for (int i = head[u]; ~i; i = e[i].next) &#123;\n        const int v = e[i].to;\n        if (v == father[u] || v == son[u]) &#123;\n            continue;\n        &#125;\n\n        dfs2(v, false);\n    &#125;\n    \n    if (son[u] != 0) &#123;\n        dfs2(son[u], true);\n    &#125;\n    \n    update(u, 1, son[u]);\n    \n    answer[u] = sum;\n    \n    if (heavy_son == false) &#123;\n        update(u, -1, -1);\n        sum = 0;\n        max = 0;\n    &#125;\n&#125;\n\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    std::memset(head, -1, sizeof(head));\n\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) &#123;\n        cin &gt;&gt; col[i];\n    &#125;\n\n    for (int i = 1; i &lt; n; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v;\n        add_edge(u, v);\n        add_edge(v, u);\n    &#125;\n    \n    dfs1(1, 0);\n    dfs2(1, true);\n    \n    for (int i = 1; i &lt;= n; i++) &#123;\n        cout &lt;&lt; answer[i] &lt;&lt; &quot; &quot;;\n    &#125;\n\n    return 0;\n&#125;\n树链剖分\n算法步骤\n我们维护 $5$ 个数组：\n\n$fa[u]$：表示节点 $u$ 的父亲。\n$size[u]$：表示节点 $u$ 的子树大小。\n$son[u]$：表示节点 $u$ 的重儿子 (即节点 $u$ 的子节点中子树大小最大的节点) 的编号。\n$top[u]$：表示节点 $u$ 所在链的链头编号。\n$id[i]$：表示 $dfn$ 值为 $i$ 的节点编号。\n\n这样我们就把整棵树拆成了若干条链和轻边。这样我们就可以用线段树对整棵树进行维护 (每一条链都对应了一段连续的 $dfn$ 区间)。\n例题\n洛谷 P3384 重链剖分/树链剖分\n根据题意对树剖完了的 $dfn$ 序列用线段树维护即可。\nCode\n#include &lt;bits/stdc++.h&gt;\n#define OnlineJudge\n\nusing std::cin;\nusing std::cout;\n\nconstexpr int N = 1e5 + 5;\nint head[N], cnt = 0;\nint n, m, root, P, u, v, initial_value[N], value[N], opt;\nint top[N], size[N], son[N], dep[N], fa[N], id[N], num = 0;\n\nclass Edge &#123;\npublic:\n    int to, next;\n\n    Edge(const int to = 0, const int next = 0) : to(to), next(next) &#123;&#125;\n&#125; e[N &lt;&lt; 1];\n\nvoid add_edge(int u, int v) &#123;\n    e[cnt] = Edge(v, head[u]);\n    head[u] = cnt++;\n&#125;\n\nstruct SegmentTree &#123;\n    struct Node &#123;\n        int left, right;\n        long long sum, add;\n\n        explicit Node(const int l = 0, const int r = 0, const int s = 0, const int a = 0) :\n            left(l), right(r), sum(s), add(a) &#123;&#125;\n    &#125;;\n\n    Node tr[N &lt;&lt; 2];\n\n    SegmentTree() &#123;&#125;\n\n    void make_lazy(const int k, const long long value) &#123;\n        (tr[k].sum += (tr[k].right - tr[k].left + 1) * value) %= P;\n        (tr[k].add += value) %= P;\n    &#125;\n\n    void push_up(const int k) &#123;\n        const int left_child = k &lt;&lt; 1, right_child = k &lt;&lt; 1 | 1;\n        tr[k].sum = tr[left_child].sum + tr[right_child].sum;\n        tr[k].sum %= P;\n    &#125;\n\n    void push_down(const int k) &#123;\n        if (tr[k].add == 0) return void();\n\n        const int left_child = k &lt;&lt; 1, right_child = k &lt;&lt; 1 | 1;\n        make_lazy(left_child, tr[k].add);\n        make_lazy(right_child, tr[k].add);\n\n        tr[k].add = 0;\n    &#125;\n\n    void build_tree(const int k, const int left, const int right) &#123;\n        tr[k] = Node(left, right);\n\n        if (tr[k].left == tr[k].right) &#123;\n            tr[k].sum = value[left] % P;\n            return void();\n        &#125;\n\n        const int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;\n        const int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n\n        build_tree(lc, left, mid);\n        build_tree(rc, mid + 1, right);\n\n        push_up(k);\n    &#125;\n\n    void modify(const int k, const int left, const int right, const long long value) &#123;\n        if (tr[k].left &gt;= left &amp;&amp; tr[k].right &lt;= right) &#123;\n            make_lazy(k, value);\n            return void();\n        &#125;\n\n        push_down(k);\n\n        const int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;\n        const int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n\n        if (right &lt;= mid) &#123;\n            modify(lc, left, right, value);\n        &#125; else if (left &gt; mid) &#123;\n            modify(rc, left, right, value);\n        &#125; else &#123;\n            modify(lc, left, mid, value);\n            modify(rc, mid + 1, right, value);\n        &#125;\n\n        push_up(k);\n    &#125;\n\n    long long query(const int k, const int left, const int right) &#123;\n        if (tr[k].left &gt;= left &amp;&amp; tr[k].right &lt;= right) &#123;\n            return tr[k].sum % P;\n        &#125;\n\n        push_down(k);\n\n        const int mid = (tr[k].left + tr[k].right) &gt;&gt; 1;\n        const int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n\n        if (right &lt;= mid) &#123;\n            return query(lc, left, right) % P;\n        &#125;\n        if (left &gt; mid) &#123;\n            return query(rc, left, right) % P;\n        &#125;\n        return (query(lc, left, mid) + query(rc, mid + 1, right)) % P;\n    &#125;\n&#125; seg;\n\nvoid dfs(int u, int father) &#123;\n    fa[u] = father;\n    size[u] = 1;\n    dep[u] = dep[father] + 1;\n\n    for (int i = head[u]; ~i; i = e[i].next) &#123;\n        int v = e[i].to;\n        if (v == father) &#123;\n            continue;\n        &#125;\n\n        dfs(v, u);\n        size[u] += size[v];\n        if (son[u] == 0 || size[v] &gt; size[son[u]]) &#123;\n            son[u] = v;\n        &#125;\n    &#125;\n&#125;\n\nvoid dfs2(int u, int link_top) &#123;\n    top[u] = link_top;\n    id[u] = ++num;\n    value[num] = initial_value[u];\n\n    if (son[u] == 0) return;\n    \n    dfs2(son[u], link_top);\n\n    for (int i = head[u]; ~i; i = e[i].next) &#123;\n        int v = e[i].to;\n        if (v == fa[u] || v == son[u]) &#123;\n            continue;\n        &#125;\n\n        dfs2(v, v);\n    &#125;\n&#125;\n\nusing std::swap;\n\nvoid update_range(int u, int v, const long long value) &#123;\n    while (top[u] != top[v]) &#123;\n        #ifndef OnlineJudge\n        cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; top[u] &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; top[v] &lt;&lt; &#x27;\\n&#x27;;\n        #endif\n        \n        if (dep[top[u]] &lt; dep[top[v]]) &#123;\n            swap(u, v);\n        &#125;\n\n        seg.modify(1, id[top[u]], id[u], value);\n        u = fa[top[u]];\n    &#125;\n\n    if (dep[u] &gt; dep[v]) &#123;\n        swap(u, v);\n    &#125;\n    seg.modify(1, id[u], id[v], value);\n&#125;\n\nlong long query_range(int u, int v) &#123;\n    long long retval = 0;\n\n    while (top[u] != top[v]) &#123;\n        if (dep[top[u]] &lt; dep[top[v]]) &#123;\n            swap(u, v);\n        &#125;\n\n        (retval += seg.query(1, id[top[u]], id[u])) %= P;\n        u = fa[top[u]];\n    &#125;\n\n    if (dep[u] &gt; dep[v]) &#123;\n        swap(u, v);\n    &#125;\n    (retval += seg.query(1, id[u], id[v])) %= P;\n\n    return retval;\n&#125;\n\nvoid update_subtree(const int u, const long long value) &#123;\n    seg.modify(1, id[u], id[u] + size[u] - 1, value);\n&#125;\n\nlong long query_subtree(const int u) &#123;\n    return seg.query(1, id[u], id[u] + size[u] - 1);\n&#125;\n\nusing std::cin;\nusing std::cout;\n\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    std::memset(head, -1, sizeof(head));\n    \n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; root &gt;&gt; P;\n\n    for (int i = 1; i &lt;= n; i++) &#123;\n        cin &gt;&gt; initial_value[i];\n    &#125;\n\n    for (int i = 1; i &lt; n; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v;\n\n        add_edge(u, v);\n        add_edge(v, u);\n    &#125;\n\n    dfs(root, 0);\n    dfs2(root, root);\n\n    seg.build_tree(1, 1, n);\n\n    for (int i = 1; i &lt;= m; i++) &#123;\n        cin &gt;&gt; opt;\n\n        switch (opt) &#123;\n            int x, y;\n            long long z;\n\n            case 1:\n                cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n                update_range(x, y, z);\n                break;\n            case 2:\n                cin &gt;&gt; x &gt;&gt; y;\n                cout &lt;&lt; query_range(x, y) &lt;&lt; &#x27;\\n&#x27;;\n                break;\n            case 3:\n                cin &gt;&gt; x &gt;&gt; z;\n                update_subtree(x, z);\n                break;\n            case 4:\n                cin &gt;&gt; x;\n                cout &lt;&lt; query_subtree(x) &lt;&lt; &#x27;\\n&#x27;;\n                break;\n            default:\n                break;\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n左偏树\n左偏树是可并堆的一种。\n定义\n我们定义 外节点 表示子节点数小于两个的节点。定义一个节点 $u$ 的 $dist_u$ 表示到最近的外节点的距离。\n左偏树满足如下性质：\n\n对于任意一个节点 $u$，均满足 $dist_{\\operatorname{lson}(u)} &gt; dist_{\\operatorname{rson}(u)}$，即 左偏。\n由上一条性质我们可以推导出：$dist_u = dist_{\\operatorname{rson}(u)} + 1$。\n\n操作\n合并\n左偏树的合并操作有以下几个步骤：\n\n定义 $\\operatorname{merge}(x, y)$ 表示将以 $x$ 和 $y$ 为根节点的左偏树合并。\n我们钦定 $val_x &lt; val_y$，将 $x$ 作为合并后的新的根节点 即维护一个小根堆。\n接下来进行 $\\operatorname{merge}(\\operatorname{lson}(x),y)$。\n然后维护左偏树的性质：\n\n如果 $dist_{\\operatorname{lson}(x)} &lt; dist_{\\operatorname{rson}(x)}$，则 $\\operatorname{swap}(\\operatorname{lson}(x), \\operatorname{rson}(x))$。\n维护 $dist_x = dist_{\\operatorname{rson}(x)} + 1$。\n\n\n\n删除\n删除还是基于左偏树的 $\\operatorname{merge}(x,y)$ 操作，如果删除的是 $x$，则 $\\operatorname{merge}(\\operatorname{lson}(x), \\operatorname{rson}(x))$，然后维护左偏树的性质即可\n例题\n洛谷 P3337 左偏树/可并堆\n模板题，根据题意维护即可。\nCode\n#include &lt;bits/stdc++.h&gt;\n\nusing std::cin;\nusing std::cout;\n\nconstexpr int N = 1e5 + 5;\nint n, m, erase[N], op, x, y;\n\nclass LeftistTree &#123;\npublic:\n    struct Node &#123;\n        int value, index;\n\n        Node(const int v = 0, const int i = 0) :\n            value(v), index(i) &#123;&#125;\n\n        bool operator&lt;(const Node&amp; compare_node) const &#123;\n            if (value != compare_node.value) &#123;\n                return value &lt; compare_node.value;\n            &#125;\n            return index &lt; compare_node.index;\n        &#125;\n\n        bool operator&gt;(const Node&amp; compare_node) const &#123;\n            if (value != compare_node.value) &#123;\n                return value &gt; compare_node.value;\n            &#125;\n            return index &gt; compare_node.index;\n        &#125;\n    &#125; val[N];\n    int father[N] = &#123;&#125;;\n    int dist[N] = &#123;&#125;, lc[N] = &#123;&#125;, rc[N] = &#123;&#125;;\n\n    int find(const int x) &#123;\n        if (father[x] != x) father[x] = find(father[x]);\n        return father[x];\n    &#125;\n\n    int merge(int x, int y) &#123;\n        using std::swap;\n\n        if (x == 0 || y == 0) return x + y;\n        if (val[x] &gt; val[y]) swap(x, y);\n\n        rc[x] = merge(rc[x], y);\n\n        if (dist[lc[x]] &lt; dist[rc[x]]) swap(lc[x], rc[x]);\n        dist[x] = dist[rc[x]] + 1;\n\n        return x;\n    &#125;\n&#125; tr;\n\nint main() &#123;\n    using std::memset;\n\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    memset(tr.rc, 0, sizeof(tr.rc));\n    memset(tr.lc, 0, sizeof(tr.lc));\n    memset(tr.dist, 0, sizeof(tr.dist));\n    tr.dist[0] = -1;\n\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++) &#123;\n        cin &gt;&gt; tr.val[i].value;\n        tr.val[i].index = i;\n        tr.father[i] = i;\n    &#125;\n\n    for (int i = 1; i &lt;= m; i++) &#123;\n        cin &gt;&gt; op;\n\n        if (op == 1) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n\n            if (erase[x] || erase[y]) &#123;\n                continue;\n            &#125;\n\n            x = tr.find(x), y = tr.find(y);\n            if (x == y) &#123;\n                continue;\n            &#125;\n\n            tr.father[x] = tr.father[y] = tr.merge(x, y);\n        &#125; else if (op == 2) &#123;\n            cin &gt;&gt; x;\n\n            if (erase[x] == true) &#123;\n                cout &lt;&lt; &quot;-1\\n&quot;;\n            &#125; else &#123;\n                x = tr.find(x);\n                cout &lt;&lt; tr.val[x].value &lt;&lt; &#x27;\\n&#x27;;\n\n                erase[x] = true;\n                const int current_root = tr.merge(tr.lc[x], tr.rc[x]);\n                tr.father[tr.lc[x]] = current_root;\n                tr.father[tr.rc[x]] = current_root;\n                tr.father[x] = current_root;\n                tr.lc[x] = 0;\n                tr.rc[x] = 0;\n                tr.dist[x] = 0;\n            &#125;\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n点分治\nOI Wiki\n思想\n我们对每个节点进行分治，将树上的路径分为 经过点 $u$ 的 和 不经过点 $u$ 的，而点 $u$ 通常取树的重心。\n典型问题：$K$ 长路径计数。\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day3","url":"/posts/77936e83/","content":"Content： Data structs\nDate：2025.7.19\n\n内容\n\n三维偏序问题\nCDQ分治\n整体二分\n分块\n莫队算法\n\n具体内容\n三维偏序问题\n\n            问题描述给定一些三元组 $(a_i, b_i, c_i)$，询问对于三元组 $(a_j, b_j, c_j)$，有多少个三元组满足 $a_i \\le a_j$ 且 $b_i \\le b_j$ 且 $c_i \\le c_j$。\n          \n首先对于这个问题，我们考虑先去重，然后排序。排序规则如下：\n\n如果 $a_i \\ne a_j$，则返回 $a_i &lt; a_j$\n如果 $b_i \\ne b_j$，则返回 $b_i &lt; b_j$\n否则返回 $c_i &lt; c_j$\n\n这样我们就把 $a_i &lt; a_j$ 的条件去掉了。\n接下来我们考虑分治，定义函数 $solve(l, r)$ 表示当前解决到了区间 $[l, r]$，取其中点 $mid$，将原序列的问题转化为三个部分：\n\n$j &lt; i \\le mid$，由 $solve(l, mid)$ 解决。\n$mid &lt; j &lt; i$，由 $solve(mid + 1, r)$ 解决。\n$j \\le mid &lt; i$，即被 $mid$ 分成了两个部分。\n\n对于第三种情况，我们需要解决的是如下问题：\n\n            问题描述在区间 $[l,r]$ 中，有多少对二元组 $(i, j)$ （其中 $i \\ne j$）满足 $b_i &lt; b_j$ 且 $c_i &lt; c_j$。\n          \n可见问题转化为了二维偏序问题，用线段树解决就可以。\n整体二分\n普通的二分操作是直接对于每个询问二分答案，判断答案是否合法。\n整体二分的思路是将所有询问一起二分，根据二分的答案对询问进行分类，再逐步求解。\n例题：\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day7","url":"/posts/70feaa9a/","content":"Content：Competition\nDate：2025.7.23\n\nT1：宝宝巴士之小猫数数\n赛时思路\n开始题意理解错了，以为是倒数第二位开始的连续的 $0$，后面也没有什么新的思路，就用 python 打了个 $n \\le 5000$ 的表，拿了 $50$ 分的部分分。\n正解\n其实就是赛时的思路，根据那个方法打表，但是每次只维护前面几位 (根据样例可以知道答案很小)，然后就没有然后了。\nT2：宝宝巴士之换一换\n赛时思路\n以为时分治，每次合并跨过 $mid$ 的区间，维护一个双指针，每次往结果大的方向移动，同时用不在所选区间内的最大值替换所选区间内的最小值，但其实这个贪心是不对的。\n正解\n其中有一个 Subtask 3 对问题的思考是很有帮助的。\n\n            Solution For Subtask 3我们发现问题的答案是 最长的连续的一的个数 和 最长的连续的二的个数 $\\times$ 2 中的最大值。\n          \n我们由此受到启发。观察原式 $(r-l+1)\\min{a_l, a_{l+1}, a_{l+2},\\dots,a_{r}}$，我们考虑枚举最小值，将大于最小值的数变为 $1$，将小于最小值的数变为 $0$，那么问题转化为如何求序列中连续的 $1$ 的个数。\n将问题抽象出来，可以发现需要维护一个支持如下操作的数据结构：\n\n单点修改\n求连续区间\n\n并查集可以维护。\nT3：宝宝巴士之小猫过河\n赛时思路\n无\n正解\n首先我们考虑 Subtask 3 $n \\le 5000$ 怎么做，很显然需要一个复杂度为 $\\Theta(n^2)$ 的做法。考虑动态规划，定义状态 $dp_{i,j,0/1}$，表示左侧走了前 $i$ 队猫咪🐱，右侧走了前 $j$ 队猫咪，$0/1$ 表示上一次走的是左侧/右侧的猫咪。\n发现状态太多不好优化。其实答案具有单调性 (显然)，我们可以考虑二分答案，对于二分的答案 $mid$，设当前还剩下 $limit$ 的时间，每一队猫的过桥时间为 $t_i + k_i + m - 2$，我们把这些区间 $[t_i, t_i + k_i + m - 2]$ 紧挨着 $mid$ 排，如果发现有一对队伍 $(l,r)$，无论如何都会冲突，就返回 $false$。\n\n\n\n            总结这次比赛时间分配有问题，认为 T2 的复杂度正确，就一直在调试，希望拿到全部分，结果最后不仅没有分，还因为时间不够而没有把暴力的 $25pts$ 的代码提交上去，后面的 T3，T4 的部分分 ($50pts + 15pts$) 没有拿到。接下来比赛的时候应该注意：比赛前浏览题目，确定哪些部分分是可以拿到的 (在草稿纸上做好笔记，赛后复盘)，能拿部分分的题目留 $40min ~ 50min$。比赛期间不要在同一到题目上花费太长的时间，给自己一个限定的时间范围，如果在范围内没有调出来，要及时放弃。\n          \n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day9","url":"/posts/9746879d/","content":"Content：DP (state, num)\nDate：2025.7.25\n\n概览\n\n数位 DP\n状压 DP\n\n内容\n状压 DP\n状压 DP，即状态压缩 DP，通常情况下和子集问题挂钩，以二进制的第 $i$ 位表示集合中的每个子集选还是不选。\n有一种 $O(3^n)$ 的子集枚举方式：\n[!Note] Code\nfor (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123;\n    for (int j = i; j; j = (j - 1) &amp; i) &#123;\n        // * j 即为 i 的子集\n    &#125;\n&#125;\n数位 DP\n数位 DP，即不是以数字为状态进行动态规划，而是和人一样，对于数字的每个数位作为状态，常见问题为：\n\n            常见问题给定区间 $[L,R]$，求出在这个区间中满足某种条件的数的个数。\n          \n例题\n洛谷-P1896 互不侵犯\n思路\n我们定义 $dp_{i,s,j}$ 表示第 $i$ 行的放置状态为 二进制表示下的 $s$ 时的放置 $j$ 个国王的方案数。\n首先根据题意，我们要排除一些不合法的放置状态：\n\n对于 $\\forall s$，如果 $s \\ &amp; \\ s &lt;&lt; 1$ 或 $s \\ &amp; \\ s &gt;&gt; 1$ 不为 $0$，那么状态 $s$ 不合法。（不能左右相邻）\n对于任意相邻两行的状态 $\\forall s,t$，如果 $s \\ &amp; \\ t$ 或 $s \\ &amp; \\ t &lt;&lt; 1$ 或 $s \\ &amp; \\ t &lt;&lt; 1$ 不为 $0$，那么状态 $s,t$ 不合法。（题目要求）\n\n然后对于转移就是对于所有合法状态的累加。\n提交记录：link\n洛谷-P3959\n思路\n容易发现最后的答案和深度有关，不放就以深度作为状态。\n定义 $dp_{d,s}$ 表示当前树的深度为 $d$，在树上的节点的状态为 $s$。\n转移就是枚举 $s$ 的子集 $t$，方程如下：\n$$\ndp_{d,s} = min_{t \\in s} {dp_{d-1,t} + d \\times cost_{t,s}}\n$$\n其中 $cost_{t,s}$ 表示从集合 $t$ 变为集合 $s$ 的最小花费，可以预处理得到。\n提交记录：link\n洛谷-P4363 一双木棋 chess\n思路\n轮廓线 DP。\n我们以一个长度为 $n+m$ 的二进制串表示轮廓线，其中如果第 $i$ 位为 $0$，则向下走，否则向右走。手搓一下样例可以发现状态的转移是将二进制串中的 $01$ 变为 $10$。直接转移不好转移，但是可以记忆化搜索。\n定义 $dp_{s}$ 表示轮廓线的状态为 $s$ 下的答案。深搜 + 记忆化即可。\n提交记录：link\n洛谷-P4371 花神的数论题\n思路\n我们发现直接在十进制下做状态不好表示，而题目的答案和二进制的乘积相关，不妨就直接以二进制表示状态。定义 $dp_{i,j,k}$ 表示当前枚举到了二进制下的第 $i$ 位，数字最后在二进制下有 $j$ 个 $1$，目前已经选择了 $k$ 个 $1$ 的方案数。\n答案即为 $\\Large \\prod_{i=1}^{\\log_2n} i^{dp_{\\log_2 n,i,0}}$。\n注意：统计 $dp$ 数组的时候不可以取模（也不会爆 long long）\n提交记录：link\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day8","url":"/posts/e041b70b/","content":"Content：DP (Interval, Tree)\nDate：2025.7.24\n\n概览\n\n区间 DP\n树形 DP\n\n例题\n洛谷-P4516 潜入行动\n题目大意\n\n            题目大意给定一颗树，要求在树上选取恰好 $\\large k$ 个节点 (不得重复)，每个选取的节点可以覆盖它的邻居，但是不能覆盖自己本身。要求选取的这 $\\large k$ 个节点覆盖所有的 $\\large n$ 个节点。求方案数。数据范围 $\\large n \\le 10^5, k \\le 100$。\n          \n思路\n我们考虑树形动态规划。定义状态 $\\large f_{u,i,0/1,0/1}$ 表示以 $\\large u$ 为根的子树内，选取了 $\\large i$ 个节点，其中点 $\\large u$ 放了/不放，被/不被覆盖的方案数。初始状态为：\n$$\n\\large\n\\begin{aligned}\nf_{u,0,0,0} = 1 \\\nf_{u,1,1,0} = 1 \\\n\\end{aligned}\n$$\n可以发现如果只看前两维的话，是一个典型的树形背包问题。接下来我们考虑加上后两维后如何转移 (本质还是树形背包)。\n\n\n对于 $\\large f_{u,i,0,0}$，即点 $\\large u$ 既不选择，也 不覆盖，所以 $u$ 的子节点 $v$ 一定不能选择，而 $v$ 必须     覆盖，所以其转移如下：\n$$\n\\large\nf_{u,i,0,0} = \\sum_{v \\in \\operatorname{son}(u)} f_{u,i - j,0,0} \\times f_{v,j,0,1}\n$$\n\n\n对于 $\\large f_{u,i,0,1}$，即点 $\\large u$ 不选择，但是被覆盖。因为状态为点 $u$ 被覆盖，所以既可以是 $v$ 覆盖的，也可能是 $u$ 的其他子节点覆盖的，而因为 $u$ 不被选择，所以 $v$ 一定是已经被覆盖了的，所以其转移如下：\n$$\n\\large\nf_{u,i,0,1} = \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,0,1} \\times (f_{v,j,0,1} + f_{v,j,1,1}) + \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,0,0} \\times f_{v,j,1,1}\n$$\n\n\n对于 $\\large f_{u,i,1,0}$，即点 $\\large u$ 选择了，但还没有被覆盖。因为不被覆盖，所以点 $\\large v$ 一定不能被选择，而点 $\\large u$ 已经被选择了，所以点 $\\large v$ 覆不覆盖无所谓。转移如下：\n$$\n\\large\nf_{u,i,1,0} = \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,1,0} \\times (f_{v,j,0,1} + f_{v,j,0,0})\n$$\n\n\n对于 $\\large f_{u,i,1,1}$，即点 $\\large u$ 选择了，也被覆盖了的情况。由 $1,3$ 两种情况类似的推导就可以得到。转移为：\n$$\n\\large\nf_{u,i,1,1} = \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,1,1} \\times (f_{v,j,0,0} + f_{v,j,0,1} + f_{v,j,1,0} + f_{v,j,1,1}) + \\sum_{v \\in \\operatorname{son}(u)} f_{u,i-j,1,0} \\times (f_{v,j,1,0} + f_{v,j,1,1})\n$$\n\n\n最后，注意 取模 和 long long!!!\nCode\nCode\n#include &lt;bits/stdc++.h&gt;\n\nnamespace IO &#123;\n    template&lt;typename name&gt; name read() &#123;\n        name x = 0, f = 1; char ch = getchar();\n        while (!isdigit(ch)) &#123; if (ch == &#x27;-&#x27;) f = -1; ch = getchar(); &#125;\n        while (isdigit(ch)) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); ch = getchar(); &#125;\n        return x * f;\n    &#125;\n    template&lt;typename name&gt; void _write(name x) &#123;\n        if (x &gt; 9) _write(x / 10);\n        putchar(x % 10 + &#x27;0&#x27;);\n    &#125;\n    template&lt;typename name&gt; void write(name x) &#123;\n        if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x;\n        _write(x);\n    &#125;\n&#125;\n\nconstexpr int N = 1e5 + 5, K = 105, MOD = 1e9 + 7;\nint head[N], next[N &lt;&lt; 1], to[N &lt;&lt; 1], cnt = 0;\nint dp[N][K][2][2], size[N], tmp[K][2][2];\nint n, k, u, v;\n\ninline void AddEdge(const int u, const int v) &#123;\n    to[cnt] = v;\n    next[cnt] = head[u];\n    head[u] = cnt++;\n&#125;\n\ninline void Dfs(int u, int father) &#123;\n    dp[u][0][0][0] = dp[u][1][1][0] = 1;\n    size[u] = 1;\n    \n    for (int i = head[u]; ~i; i = next[i]) &#123;\n        const int v = to[i];\n        if (v == father) continue;\n        \n        Dfs(v, u);\n        size[u] += size[v];\n        \n        // ! 这里要进行备份，不然转移的时候会出现问题（用已修改的状态修改未修改的状态）\n        for (int t = 0; t &lt;= std::min(k, size[u]); t++) &#123;\n            tmp[t][0][0] = dp[u][t][0][0];\n            tmp[t][1][0] = dp[u][t][1][0];\n            tmp[t][0][1] = dp[u][t][0][1];\n            tmp[t][1][1] = dp[u][t][1][1];\n            dp[u][t][0][0] = dp[u][t][1][0] = dp[u][t][0][1] = dp[u][t][1][1] = 0;\n        &#125;\n        \n        // ! 注意枚举范围，不能直接枚举区间 [0,k]，不然会 TLE\n        for (int t = 0; t &lt;= std::min(size[u], k); t++) &#123;\n            // ! 这里同理\n            for (int j = 0; j &lt;= std::min(size[v], t); j++) &#123;\n                if (t - j &gt; size[u] - size[v]) continue;\n                \n                // // 可恶的转移\n                (dp[u][t][0][0] += (long long) tmp[t - j][0][0] * dp[v][j][0][1] % MOD) %= MOD;\n                (dp[u][t][0][1] += ((long long) tmp[t - j][0][1] * ((dp[v][j][0][1] + dp[v][j][1][1]) % MOD) % MOD + (long long) tmp[t - j][0][0] * dp[v][j][1][1] % MOD) % MOD) %= MOD;\n                (dp[u][t][1][0] += (long long) tmp[t - j][1][0] * ((dp[v][j][0][1] + dp[v][j][0][0]) % MOD) % MOD) %= MOD;\n                (dp[u][t][1][1] += ((long long) (tmp[t - j][1][1] * (((long long) dp[v][j][0][1] + dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][1][1]) % MOD) % MOD) + (long long) tmp[t - j][1][0] * ((dp[v][j][1][1] + dp[v][j][1][0]) % MOD) % MOD) % MOD) %= MOD;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main() &#123;\n    using namespace IO;\n    \n    n = read&lt;int&gt;();\n    k = read&lt;int&gt;();\n    \n    for (int i = 1; i &lt;= n; i++) head[i] = -1;\n    \n    for (int i = 1; i &lt; n; i++) &#123;\n        u = read&lt;int&gt;(), v = read&lt;int&gt;();\n        AddEdge(u, v);\n        AddEdge(v, u);\n    &#125;\n    \n    Dfs(1, 1);\n    \n    write((1ll * dp[1][k][0][1] + dp[1][k][1][1]) % MOD);\n    \n    return 0;\n&#125;\n洛谷-P1352 没有上司的舞会 (经典题)\n题目大意\n\n            题目大意给定一颗有 $n$ 个节点的树，表示员工的架构，现在有一个舞会需要举办，你要选取一些人参加，第 $\\large i$ 个人参加可以为舞会带来 $\\large r_i$ 的快乐值，但是如果第 $\\large i$ 个人的直接上司 ($\\large i$ 的父亲节点) 参加了，那么 $\\large i$ 就不会参加，你要最大化选择的人的快乐值之和。数据范围：$\\large n \\le 6 \\times 10^3$。\n          \n思路\n定义状态 $\\large f_{u,0/1}$ 表示节点 $\\large u$ 参加/不参加能为舞会带来的最大价值。\n转移如下：\n$$\n\\large\n\\begin{aligned}\nf_{u,0} &amp;= \\sum_{v \\in \\operatorname{son}(u)} \\max(f_{v,0}, f_{v,1}) \\\nf_{u,1} &amp;= \\sum_{v \\in \\operatorname{son}(u)} f_{v,0} + r_i\n\\end{aligned}\n$$\n注意我的树存的是双向边，和边有关的数组要开 $\\large 2$ 倍。\nCode\nCode\n#include &lt;bits/stdc++.h&gt;\n\nusing std::cin;\nusing std::cout;\n\nconstexpr int MAXN = 6e4 + 5;\nint head[MAXN], to[MAXN], next[MAXN], cnt = 0;\nint n, r[MAXN], u, v;\nint dp[MAXN][2];\n\nvoid add_edge(const int u, const int v) &#123;\n    to[cnt] = v;\n    next[cnt] = head[u];\n    head[u] = cnt++;\n&#125;\n\nvoid dfs(const int u, const int father) &#123;\n    dp[u][1] = r[u];\n    \n    for (int i = head[u]; ~i; i = next[i]) &#123;\n        const int v = to[i];\n        if (v == father) continue;\n        \n        dfs(v, u);\n        dp[u][0] += std::max(dp[v][0], dp[v][1]);\n        dp[u][1] += dp[v][0];\n    &#125;\n&#125;\n\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    std::memset(head, -1, sizeof(head));\n    \n    cin &gt;&gt; n;\n    \n    for (int i = 1; i &lt;= n; i++) &#123;\n        cin &gt;&gt; r[i];\n    &#125;\n    \n    for (int i = 1; i &lt; n; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v;\n        add_edge(u, v);\n        add_edge(v, u);\n    &#125;\n    \n    dfs(1, 1);\n    \n    cout &lt;&lt; std::max(dp[1][0], dp[1][1]) &lt;&lt; &#x27;\\n&#x27;;\n    \n    return 0;\n&#125;\n洛谷-P3478 消防局的 STA-Station\n题目大意\n\n            P3478 [POI 2008] STA-Station 题目大意给定一个 $\\large n$ 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。一个结点的深度之定义为该节点到根的简单路径上边的数量。数据范围：$\\large n \\le 10^6$.\n          \n思路\n换根 DP。设 $\\large f_u$ 表示以 $\\large u$ 为根节点的时候所有节点的深度之和是多少。换根一般都有两个 $\\large dfs$，我们在第一遍 $\\large dfs$ 的时候记录节点的深度 $\\large dep$，子树大小 $\\large size$，然后 $\\large f_u$ 的状态为：$\\large f_u = dep_u$。\n在第二遍 $dfs$ 时，我们自上而下更新 $f_v$ 的值，转移为：\n$$\n\\large\nf_v = f_u - size_v + n - size_v\n$$\n即子树 $v$ 内所有点的深度减一，子树外的所有深度加一。\n注意 long long!!!\nCode\nCode\n#include &lt;bits/stdc++.h&gt;\n\nusing std::cin;\nusing std::cout;\n\nconstexpr int N = 1e6 + 5;\nint head[N], next[N &lt;&lt; 1], to[N &lt;&lt; 1], cnt = 0;\nint n, u, v, dp[N], dep[N], size[N];\n\nvoid AddEdge(const int u, const int v) &#123;\n    to[cnt] = v;\n    next[cnt] = head[u];\n    head[u] = cnt++;\n&#125;\n\nvoid Dfs1(const int u, const int father) &#123;\n    dp[u] += dep[u];\n    dep[u] = dep[father] + 1;\n    size[N] = 1;\n    \n    for (register int i = head[u]; ~i; i = next[i]) &#123;\n        register const int v = to[i];\n        if (v == father) continue;\n        \n        Dfs1(v, u);\n        size[u] += size[v];\n    &#125;\n&#125;\n\nvoid Dfs2(const int u, const int father) &#123;\n    for (register int i = head[u]; ~i; i = next[i]) &#123;\n        register const int v = to[i];\n        if (v == father) continue;\n        \n        dp[v] = dp[u] - size[v] + n - size[v];\n        Dfs2(v, u);\n    &#125;\n&#125;\n\n\n\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n \n    std::memset(head, -1, sizeof(head));\n    \n    cin &gt;&gt; n;\n    \n    for (int i = 1; i &lt; n; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v;\n        \n        AddEdge(u, v);\n        AddEdge(v, u);\n    &#125;\n    \n    Dfs1(1, 1);\n    Dfs2(1, 1);\n    \n    int ans = 1;\n    for (int i = 2; i &lt;= n; i++) &#123;\n        if (dp[i] &gt; dp[ans]) ans = i;\n    &#125;\n    \n    cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;\n    \n    return 0;\n&#125;\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"OI集训 Day6","url":"/posts/7f99a0c/","content":"Content：Data Structures;\nDate：2025.7.22\n\n概览\n\n可持久化线段树\n虚树\n\n具体内容\n可持久化线段树\n可持久化线段树实现可持久化数组\n我们对每一个版本维护一颗线段树，这样显然空间复杂度是 $\\Theta(nm)$ 的，肯定不对。\n接下来我们通过观察可以发现，其实新版本线段树上的很多节点与原线段树\n上的节点是重复的，极大地浪费了空间。\n我们考虑对那些不用修改的节点进行空间上的优化，具体如下：\n\n假设线段树节点 $k$ 维护的区间为 $[l,r]$，其中点为 $mid$。\n我们对新版本新建了一个节点 $k’$，接下来分两种情况讨论：\n\n如果区间 $[l, mid]$ 包括我们要修改的位置，则 $lc(k’) = cnt + 1$，$rc(k’) = rc(k)$。即我们继承不用修改的节点。\n对于区间 $[mid + 1, r]$ 同理。\n\n\n\n这样我们就极大地降低了空间复杂度。\n放张 OI Wiki 的图在这里方便理解：\n\n\n例题1：洛谷 P3919 可持久化线段树1\n我们直接按题意维护即可。\nCode\n#include &lt;bits/stdc++.h&gt;\n\nusing std::cin;\nusing std::cout;\n\nconstexpr int N = 1e6 + 5;\nint n, m, version, op, p, c;\nint array[N];\n\nclass SegmentTree &#123;\npublic:\n    class Node &#123;\n    public:\n        int left, right;\n        int left_child, right_child;\n        long long value;\n\n        explicit Node(const int l = 0, const int r = 0, const int lc = 0, const int rc = 0, const int val = 0) :\n            left(l), right(r), left_child(lc), right_child(rc), value(val) &#123;&#125;\n    &#125;;\n\n    int count_node = 0, root[N] = &#123;&#125;;\n    Node node_info[N * 30];\n\n    void copy(int&amp; root) &#123;\n        const int new_root = ++count_node;\n        node_info[new_root] = node_info[root];\n        root = new_root;\n    &#125;\n\n    void build_tree(int&amp; k, const int left, const int right) &#123;\n        k = ++count_node;\n        node_info[k] = Node(left, right);\n\n        if (node_info[k].left == node_info[k].right) &#123;\n            node_info[k].value = array[left];\n            return void();\n        &#125;\n\n        const int mid = (node_info[k].left + node_info[k].right) &gt;&gt; 1;\n        build_tree(node_info[k].left_child, left, mid);\n        build_tree(node_info[k].right_child, mid + 1, right);\n    &#125;\n\n    void insert_node(int&amp; k, const int position, const int value) &#123;\n        copy(k);\n\n        if (node_info[k].left == node_info[k].right) &#123;\n            node_info[k].value = value;\n            return void();\n        &#125;\n\n        const int mid = (node_info[k].left + node_info[k].right) &gt;&gt; 1;\n\n        if (position &lt;= mid)\n            insert_node(node_info[k].left_child, position, value);\n        else\n            insert_node(node_info[k].right_child, position, value);\n    &#125;\n\n    long long query(int&amp; k, const int position) &#123;\n        if (node_info[k].left == node_info[k].right) return node_info[k].value;\n\n        const int mid = (node_info[k].left + node_info[k].right) &gt;&gt; 1;\n\n        if (position &lt;= mid) return query(node_info[k].left_child, position);\n        return query(node_info[k].right_child, position);\n    &#125;\n&#125; tr;\n;\n\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; array[i];\n\n    tr.root[0] = 1;\n    tr.build_tree(tr.root[0], 1, n);\n\n    for (int i = 1; i &lt;= m; i++) &#123;\n        cin &gt;&gt; version &gt;&gt; op &gt;&gt; p;\n\n        if (op == 1) &#123;\n            cin &gt;&gt; c;\n\n            tr.root[i] = tr.root[version];\n            tr.insert_node(tr.root[i], p, c);\n        &#125; else &#123;\n            cout &lt;&lt; tr.query(tr.root[version], p) &lt;&lt; &#x27;\\n&#x27;;\n            tr.root[i] = tr.root[version];\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n\n例题2：洛谷 P3834 可持久化线段树2\n我们用权值线段树维护每一个数字出现的次数，对于每一个下标维护新的版本，所以在区间 $[l,r]$ 中的权值区间 $[wl, wr]$ 出现的次数为 $sum_{wl, wr, r} - sum_{wl, wr, r - 1}$。\n然后在线段树上二分找第 $k$ 小即可。\nCode\n#include &lt;bits/stdc++.h&gt;\n\nusing std::vector;\n\nconstexpr int kMaxN = 2e5 + 5;\nint n, m, left, right, k, array[kMaxN];\nvector &lt;int&gt; current;\n\nclass SegmentTree &#123;\npublic:\n    class Node &#123;\n    public:\n        int left_child, right_child;\n        int count;\n\n        explicit Node(const int lc = 0, const int rc = 0, const int c = 0) :\n            left_child(lc), right_child(rc), count(c) &#123;&#125;\n    &#125;;\n\n    int count_node = 0, root[kMaxN] = &#123;&#125;;\n    Node tr[kMaxN * 20];\n\n    void copy_node(int&amp; root) &#123;\n        const int new_root = ++count_node;\n        tr[new_root] = tr[root];\n        root = new_root;\n    &#125;\n\n    void build_tree(int&amp; root, const int left, const int right) &#123;\n        copy_node(root);\n\n        if (left == right) return void();\n\n        const int mid = (left + right) &gt;&gt; 1;\n        build_tree(tr[root].left_child, left, mid);\n        build_tree(tr[root].right_child, mid + 1, right);\n    &#125;\n\n    void update_node(int&amp; root, const int left, const int right, const int position) &#123;\n        copy_node(root);\n        tr[root].count++;\n\n        if (left == right) return void();\n\n        const int mid = (left + right) &gt;&gt; 1;\n        if (position &lt;= mid)\n            update_node(tr[root].left_child, left, mid, position);\n        else\n            update_node(tr[root].right_child, mid + 1, right, position);\n    &#125;\n\n    int query_kth(const int root_l, const int root_r, const int left, const int right, const int k) &#123;\n        if (left == right) return left;\n\n        const int mid = (left + right) &gt;&gt; 1;\n        const int lc1 = tr[root_l].left_child;\n        const int lc2 = tr[root_r].left_child;\n        const int pre_sum = tr[lc2].count - tr[lc1].count;\n\n        if (k &lt;= pre_sum) return query_kth(tr[root_l].left_child, tr[root_r].left_child, left, mid, k);\n        return query_kth(tr[root_l].right_child, tr[root_r].right_child, mid + 1, right, k - pre_sum);\n    &#125;\n&#125; tr;\n\nint get_index(int value) &#123;\n    using std::lower_bound;\n    return lower_bound(current.begin(), current.end(), value) - current.begin() + 1;\n&#125;\n\nint main() &#123;\n    using std::cin;\n    using std::cout;\n    using std::sort;\n    using std::unique;\n\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++) &#123;\n        cin &gt;&gt; array[i];\n        current.push_back(array[i]);\n    &#125;\n\n    sort(current.begin(), current.end());\n    current.erase(unique(current.begin(), current.end()), current.end());\n    tr.build_tree(tr.root[0], 1, current.size());\n\n    for (int i = 1; i &lt;= n; i++) &#123;\n        // ! 注意不要把 tr.root[i - 1] 填入引用中，不然在修改时 tr.root[i - 1] 的值会改变。\n        tr.root[i] = tr.root[i - 1];\n        tr.update_node(tr.root[i], 1, current.size(), get_index(array[i]));\n    &#125;\n\n    for (int i = 1; i &lt;= m; i++) &#123;\n        cin &gt;&gt; left &gt;&gt; right &gt;&gt; k;\n        cout &lt;&lt; current[tr.query_kth(tr.root[left - 1], tr.root[right], 1, current.size(), k) - 1] &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n\n    return 0;\n&#125;\n\n例题3：洛谷 P2633 Count on a Tree.\n我们用类似树上差分的思路维护即可。\nCode\n#include &lt;bits/stdc++.h&gt;\n\nconstexpr int kMaxN = 1e5 + 5;\nint head[kMaxN], cnt = 0;\nint n, m, u, v, k, last;\nint initial_weight[kMaxN];\nint siz[kMaxN], son[kMaxN], dep[kMaxN], fa[kMaxN], top[kMaxN];\nstd::vector&lt;int&gt; tmp;\n\nclass Edge &#123;\npublic:\n    int to, next;\n\n    explicit Edge(const int t = 0, const int ne = 0) : to(t), next(ne) &#123;&#125;\n&#125; e[kMaxN &lt;&lt; 2];\n\nclass PresidentTree &#123;\npublic:\n    class Node &#123;\n    public:\n        int left_child, right_child;\n        int count;\n\n        explicit Node(const int lc = 0, const int rc = 0, const int c = 0) : left_child(lc), right_child(rc), count(c) &#123;&#125;\n    &#125;;\n\n    int count_node = 0, root[kMaxN] = &#123;&#125;;\n    Node tr[kMaxN * 20];\n\n    void copy(int&amp; root) &#123;\n        const int new_root = ++count_node;\n        tr[new_root] = tr[root];\n        root = new_root;\n    &#125;\n\n    void insert(int&amp; root, const int left, const int right, const int pos) &#123;\n        copy(root);\n        tr[root].count++;\n\n        if (left == right) return void();\n\n        const int mid = (left + right) &gt;&gt; 1;\n        if (pos &lt;= mid)\n            insert(tr[root].left_child, left, mid, pos);\n        else\n            insert(tr[root].right_child, mid + 1, right, pos);\n    &#125;\n\n    int query_kth(int&amp; u, int&amp; v, int left, int right, int x, int y, int kth) &#123;\n        if (left == right) return left;\n\n        const int mid = (left + right) &gt;&gt; 1;\n        const int sum = tr[tr[u].left_child].count + tr[tr[v].left_child].count - tr[tr[x].left_child].count - tr[tr[y].left_child].unt;\n\n        if (kth &lt;= sum) return query_kth(tr[u].left_child, tr[v].left_child, left, mid, tr[x].left_child, tr[y].left_child, kth);\n        return query_kth(tr[u].right_child, tr[v].right_child, mid + 1, right, tr[x].right_child, tr[y].right_child, kth - sum);\n    &#125;\n&#125; tr;\n\nvoid add_edge(const int u, const int v) &#123;\n    e[cnt] = Edge(v, head[u]);\n    head[u] = cnt++;\n&#125;\n\nint get_index(const int value) &#123;\n    using std::lower_bound;\n    return lower_bound(tmp.begin(), tmp.end(), value) - tmp.begin() + 1;\n&#125;\n\nvoid dfs(const int u, const int father) &#123;\n    fa[u] = father;\n    dep[u] = dep[father] + 1;\n    siz[u] = 1;\n\n    tr.root[u] = tr.root[father];\n    tr.insert(tr.root[u], 1, n, get_index(initial_weight[u]));\n\n    for (int i = head[u]; ~i; i = e[i].next) &#123;\n        const int v = e[i].to;\n        if (v == father) continue;\n\n        dfs(v, u);\n        siz[u] += siz[u];\n\n        if (son[u] == 0 || siz[v] &gt; siz[son[u]]) son[u] = v;\n    &#125;\n&#125;\n\nvoid dfs2(const int u, const int topx) &#123;\n    top[u] = topx;\n\n    if (son[u] == 0) return void();\n\n    dfs2(son[u], topx);\n\n    for (int i = head[u]; ~i; i = e[i].next) &#123;\n        const int v = e[i].to;\n        if (v == fa[u] || v == son[u]) continue;\n        dfs2(v, v);\n    &#125;\n&#125;\n\nint get_LCA(int u, int v) &#123;\n    using std::swap;\n\n    while (top[u] != top[v]) &#123;\n        if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);\n        u = fa[top[u]];\n    &#125;\n\n    if (dep[u] &gt; dep[v]) swap(u, v);\n    return u;\n&#125;\n\nint main() &#123;\n    using std::cin;\n    using std::cout;\n    using std::sort;\n    using std::unique;\n\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    std::memset(head, -1, sizeof(head));\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++) &#123;\n        cin &gt;&gt; initial_weight[i];\n        tmp.push_back(initial_weight[i]);\n    &#125;\n\n    for (int i = 1; i &lt; n; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v;\n        add_edge(u, v);\n        add_edge(v, u);\n    &#125;\n\n    sort(tmp.begin(), tmp.end());\n    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n\n    dfs(1, 0);\n    dfs2(1, 1);\n\n    for (int i = 1; i &lt;= m; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; k;\n\n        u ^= last;\n        int LCA = get_LCA(u, v);\n        last = tmp[tr.query_kth(tr.root[u], tr.root[v], 1, n, tr.root[LCA], tr.root[fa[LCA]], k) - 1];\n\n        cout &lt;&lt; last &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n\n    return 0;\n&#125;\n可持久化区间线段树\n我们将标记一起放入节点信息中并一起维护即可，和普通线段树一样。就不放代码了。\n可持久化字典树\n\n            Unsubmitted==TODO== 洛谷 P4735==Submission== WA 64pts\n          \n虚树 (没听懂啊)\n定义\n给定节点集合 $S$，$\\forall u,v \\in S$，定义关键节点为 $u, v, \\operatorname{LCA}(u, v)$。\n然后对关键节点在原树上的祖先关系建树，就得到了虚树。\n应用\n可以在树形 $DP$ 中排除无关的节点，大大降低复杂度。\n","categories":["集训总结（2025暑）"],"tags":["集训"]},{"title":"Luogu P3129","url":"/posts/aeca22f/","content":"Luogu\n算法\n\n贪心\n\n\n思路\n由于 Bessie 预先知道了 Elsie 的出牌策略, 所以可以贪心, 考虑每次都出比 Elsie 大一点点的牌, 如果没有就改变规则, 这样可以保证得分最大化.\n记 $f_i$ 表示每次都出大一点点的牌最多可以赢几次, $g_i$ 相反.\n则最后的答案为 $max_{i}^{n} {f_i + g_{i+1}}$\n关于重复的证明见 Link\n代码\n\n            #include &lt;bits/stdc++.h&gt;\n  \nusing namespace std;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  \n  int n;\n  cin &gt;&gt; n;\n  \n  vector&lt;int&gt; Elsie(n);\n  set&lt;int, greater&lt;int&gt;&gt; BessieG;\n  set&lt;int, less&lt;int&gt;&gt; BessieL;\n  vector&lt;bool&gt; used(2 * n + 1, false);\n  \n  for (int i = 0; i &lt; n; i++) &#123;\n    cin &gt;&gt; Elsie[i];\n  \n    used[Elsie[i]] = true;\n  &#125;\n  \n  for (int i = 1; i &lt;= 2 * n; i++) &#123;\n    if (used[i] == false) &#123;\n      BessieG.insert(i);\n      BessieL.insert(i);\n    &#125;\n  &#125;\n  \n  vector&lt;int&gt; f(n + 2), g(n + 2);\n  \n  for (int i = 1; i &lt;= n; i++) &#123;\n    set&lt;int&gt;::iterator found = BessieL.lower_bound(Elsie[i - 1]);\n  \n    // * 如果 found != BessieG.end(), 则 Bessie 可以在这一轮出比 Elsie 大的\n    if (found != BessieL.end()) &#123;\n      BessieL.erase(found);\n      f[i] = f[i - 1] + 1;\n    &#125; else &#123;\n      f[i] = f[i - 1];\n    &#125;\n  &#125;\n  \n  // ! 注意这里要逆序循环 (40 pts)\n  for (int i = n; i &gt;= 1; i--) &#123;\n    set&lt;int&gt;::iterator found = BessieG.lower_bound(Elsie[i - 1]);\n  \n    // * 如果 found != BessieL.end(), 则 Bessie 可以在这一轮出比 Elsie 小的\n    if (found != BessieG.end()) &#123;\n      BessieG.erase(found);\n      g[i] = g[i + 1] + 1;\n    &#125; else &#123;\n      g[i] = g[i + 1];\n    &#125;\n  &#125;\n  \n  int answer = 0;\n  \n  // ! 这里统计答案的范围为 [0, n] (47 pts)\n  for (int i = 0; i &lt;= n; i++) &#123;\n    answer = max(answer, f[i] + g[i + 1]);\n  &#125;\n  \n  cout &lt;&lt; answer &lt;&lt; &#x27;\\n&#x27;;\n  \n  return 0;\n&#125;\n          ","categories":["Solution"],"tags":["贪心","Luogu"]},{"title":"Luogu P2831","url":"/posts/aa4147b6/","content":"Luogu\n算法\n\n搜索\n\n\n思路\n由于 $n \\le 18$，可以考虑搜索。\n定义 $dfs(cur, a, b)$ 表示搜索到了第 $cur$ 头猪，使用了 $a$ 条抛物线，前面还有 $b$ 头猪为被击中。\n对于一条抛物线 $y=ax^{2}+bx+c$，需要三个点确定其解析式。由于题目钦定了抛物线必定经过 $(0,0)$，所以还需要两个点。在前面为被击中的 $b$ 头猪中选择一头与第 $cur$ 头猪配对。假设两头猪的坐标为 $(x_{1}, y_{1}), (x_{2},y_{2})$。则\n$$\n\\begin{cases}\na x_{1}^{2} + b x_{1} = y_{1} \\\na x_{2}^{2} + b x_{2} = y_{2} \\\n\\end{cases}\n\\to\n\\begin{cases}\na = \\frac{(y_{1} x_{2} - y_{2} x_{1})}{x_{1}^{2} x_{2} - x_{1} x_{2}^{2}} \\\nb = \\frac{y_{1} - x_{1}^{2} a}{x_{1}} \\\n\\end{cases}\n$$\n于是就可以得到这两头猪配对的抛物线解析式。\n然后进行剪枝。如果由于前面未配对的猪必须要有一条单独的抛物线经过，所以有最优性剪枝： $a + b &gt; answer$ 时 return。\n代码\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconstexpr int N = 25;\nconstexpr double EPS = 1e-9;\npair&lt;double, double&gt; pig[N], line[N], unused[N];\nint test_case, n, m, answer;\n\nbool equal(double a, double b) &#123;\n  return fabs(a - b) &lt; EPS;\n&#125;\n\nvoid dfs(int cur, int a, int b) &#123;\n  if (a + b &gt;= answer) &#123;\n    return void();\n  &#125; else if (cur &gt; n) &#123;\n    answer = min(answer, a + b);\n    return void();\n  &#125;\n  \n  double x = pig[cur].first, y = pig[cur].second;\n  \n  bool crossed = false;\n  for (int i = 1; i &lt;= a; i++) &#123;\n    if (equal(line[i].first * x * x + line[i].second * x, y) == true) &#123;\n      crossed = true;\n      break;\n    &#125;\n  &#125;\n  \n  if (crossed == true) &#123;\n    dfs(cur + 1, a, b);\n  &#125; else &#123;\n    for (int i = 1; i &lt;= b; i++) &#123;\n      double tx = unused[i].first, ty = unused[i].second;\n      \n      if (equal(x, tx) == true) &#123;\n        continue;\n      &#125;\n      \n      double pa = (y * tx - ty * x) / (x * x * tx - tx * tx * x);\n      double pb = (y - x * x * pa) / x;\n      \n      if (pa &gt;= 0) &#123;\n        continue;\n      &#125;\n      \n      line[a + 1] = make_pair(pa, pb);\n      \n      pair&lt;double, double&gt; tmp = unused[i];\n      for (int j = i; j &lt;= b - 1; j++) &#123;\n        unused[j] = unused[j + 1];\n      &#125;\n      \n      dfs(cur + 1, a + 1, b - 1);\n      \n      for (int j = b; j &gt; i; j--) &#123;\n        unused[j] = unused[j - 1];\n      &#125;\n      \n      unused[i] = tmp;\n    &#125;\n    \n    unused[b + 1] = pig[cur];\n    dfs(cur + 1, a, b + 1);\n  &#125;\n&#125;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  \n  cin &gt;&gt; test_case;\n  \n  while (test_case --) &#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    \n    for (int i = 1; i &lt;= n; i++) &#123;\n      cin &gt;&gt; pig[i].first &gt;&gt; pig[i].second;\n    &#125;\n    \n    answer = 100000;\n    dfs(1, 0, 0);\n    \n    cout &lt;&lt; answer &lt;&lt; &quot;\\n&quot;;\n  &#125;\n  \n  return 0;\n&#125;","categories":["Solution"],"tags":["Luogu","搜索"]},{"title":"Luogu P1471","url":"/posts/d582d438/","content":"Luogu\n算法\n\n线段树\n数学推导（平均数，方差）\n\n\n思路\n区间操作，很容易想到线段树。\n但是方差不好合并，考虑拆解：\n$$\n\\large\n\\begin{aligned}\ns^2 &amp;= \\frac{1}{n} \\sum_{i = 1}^{n} (A_i - \\overline A)^2 \\\n&amp;= \\frac{1}{n} \\sum_{i = 1}^{n} (A_i^2 - 2 \\cdot A_i^2 \\cdot \\overline A + \\overline A^2) \\\n&amp;= \\frac{1}{n} (\\sum_{i = 1}^{n} A_i^2 - \\sum_{i = 1}^{n} 2 \\cdot A_i^2 \\cdot \\overline A + \\sum_{i = 1}^{n} \\overline A^2) \\\n&amp;= \\frac{1}{n} (\\sum_{i = 1}^{n} A_i^2 - 2 \\cdot \\overline A \\cdot \\sum_{i = 1}^{n} A_i + n \\overline A^2)\n\\end{aligned}\n$$\n所以我们只需要维护区间和 $sum$，区间平方和 $sum_square$ 就可以了。\n对于区间加的操作，有如下推导（记 $sum2$ 为区间平方和）：\n$$\n\\large\n\\begin{aligned}\nsum2^{\\prime} &amp;= \\sum_{i = 1}^{n} (A_i + val)^2 \\\n&amp;= \\sum_{i = 1}^{n} (A_i^2 + 2 \\cdot A_i \\cdot val + val^2) \\\n&amp;= \\sum_{i = 1}^{n} A_i^2 + \\sum_{i = 1}^{n} 2 \\cdot A_i \\cdot val + \\sum_{i = 1}^{n} val^2 \\\n&amp;= sum2 + 2 \\cdot val \\cdot \\sum_{i = 1}^{n} + n \\cdot val^2\n\\end{aligned}\n$$\n然后我们就做完了。\n代码\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconstexpr int N = 1e5 + 5;\nlong double arr[N], k;\nint n, m, op_type, l, r;\n\nstruct SegmentTree &#123;\n  public:\n  struct Node &#123;\n    int l, r;\n    long double sum_square, sum, add;\n  &#125;;\n  \n  Node tr[N &lt;&lt; 2];\n  \n  void lazy(int k, long double value) &#123;\n    tr[k].sum_square += tr[k].sum * 2 * value + (tr[k].r - tr[k].l + 1) * value * value;\n    tr[k].sum += (tr[k].r - tr[k].l + 1) * value;\n    tr[k].add += value;\n  &#125;\n  \n  void push_up(int k) &#123;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n    tr[k].sum_square = tr[lc].sum_square + tr[rc].sum_square;\n    tr[k].sum = tr[lc].sum + tr[rc].sum;\n  &#125;\n  \n  void push_down(int k) &#123;\n    if (tr[k].add == 0) &#123;\n      return void();\n    &#125;\n    \n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n    lazy(lc, tr[k].add);\n    lazy(rc, tr[k].add);\n    \n    // ! 注意下传懒标记要清空。\n    tr[k].add = 0;\n  &#125;\n  \n  void build_tree(int k, int l, int r) &#123;\n    tr[k].l = l, tr[k].r = r;\n    tr[k].sum = tr[k].sum_square = tr[k].add = 0;\n    \n    if (tr[k].l == tr[k].r) &#123;\n      tr[k].sum = arr[l];\n      tr[k].sum_square = arr[l] * arr[l];\n      return void();\n    &#125;\n    \n    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n    \n    build_tree(lc, l, mid);\n    build_tree(rc, mid + 1, r);\n    \n    push_up(k);\n  &#125;\n  \n  void modify(int k, int l, int r, long double value) &#123;\n    if (tr[k].l &gt;= l &amp;&amp; tr[k].r &lt;= r) &#123;\n      lazy(k, value);\n      return void();\n    &#125;\n    \n    push_down(k);\n    \n    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n    \n    if (r &lt;= mid) &#123;\n      modify(lc, l, r, value);\n    &#125; else if (l &gt; mid) &#123;\n      modify(rc, l, r, value);\n    &#125; else &#123;\n      modify(lc, l, mid, value);\n      modify(rc, mid + 1, r, value);\n    &#125;\n    \n    push_up(k);\n  &#125;\n  \n  long double __query_sum(int k, int l, int r) &#123;\n    if (tr[k].l &gt;= l &amp;&amp; tr[k].r &lt;= r) &#123;\n      return tr[k].sum;\n    &#125;\n    \n    push_down(k);\n    \n    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n    \n    if (r &lt;= mid) &#123;\n      return __query_sum(lc, l, r);\n    &#125; else if (l &gt; mid) &#123;\n      return __query_sum(rc, l, r);\n    &#125; else &#123;\n      return __query_sum(lc, l, mid) + __query_sum(rc, mid + 1, r);\n    &#125;\n  &#125;\n  \n  long double __query_sum_square(int k, int l, int r) &#123;\n    if (tr[k].l &gt;= l &amp;&amp; tr[k].r &lt;= r) &#123;\n      return tr[k].sum_square;\n    &#125;\n    \n    push_down(k);\n    \n    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n    \n    if (r &lt;= mid) &#123;\n      return __query_sum_square(lc, l, r);\n    &#125; else if (l &gt; mid) &#123;\n      return __query_sum_square(rc, l, r);\n    &#125; else &#123;\n      return __query_sum_square(lc, l, mid) + __query_sum_square(rc, mid + 1, r);\n    &#125;\n  &#125;\n  \n  long double query_average(int l, int r) &#123;\n    long double sum = __query_sum(1, l, r);\n    return sum / (long double) (r - l + 1);\n  &#125;\n  \n  long double query_variance(int l, int r) &#123;\n    long double average = query_average(l, r);\n    long double sum = __query_sum(1, l, r);\n    long double sum_square = __query_sum_square(1, l, r);\n    int length = r - l + 1;\n    \n    // cout &lt;&lt; average &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; sum_square &lt;&lt; &#x27;\\n&#x27;;\n    \n    return (sum_square - 2 * average * sum + length * average * average) / (long double) length;\n  &#125;\n&#125; segment_tree;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  \n  cin &gt;&gt; n &gt;&gt; m;\n  \n  for (int i = 1; i &lt;= n; i ++) &#123;\n    cin &gt;&gt; arr[i];\n  &#125;\n  \n  segment_tree.build_tree(1, 1, n);\n  \n  while (m --) &#123;\n    cin &gt;&gt; op_type &gt;&gt; l &gt;&gt; r;\n    \n    if (op_type == 1) &#123;\n      cin &gt;&gt; k;\n      segment_tree.modify(1, l, r, k);\n    &#125; else if (op_type == 2) &#123;\n      long double result = segment_tree.query_average(l, r);\n      result = round(result * 10000) / (long double) 10000;\n      \n      cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(4) &lt;&lt; result &lt;&lt; &#x27;\\n&#x27;;\n    &#125; else if (op_type == 3) &#123;\n      long double result = segment_tree.query_variance(l, r);\n      result = round(result * 10000) / (long double) 10000;\n      \n      cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(4) &lt;&lt; result &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n  &#125;\n  \n  return 0;\n&#125;","categories":["Solution"],"tags":["Math","SegmentTree","Luogu"]},{"title":"Luogu P1445","url":"/posts/f9c243e2/","content":"Luogu\n算法\n\n数学（素数筛，因子个数）\n\n\n思路\n对于原式做如下推导：\n$$\n\\large\n\\begin{aligned}\n\\frac{1}{x} + \\frac{1}{y} &amp;= \\frac{1}{n!} \\\n\\frac{x + y}{xy} &amp;= \\frac{1}{n!} \\\nn! \\cdot (x + y) &amp;= xy \\\nn! \\cdot x + n! \\cdot y - xy &amp;= 0 \\\nxy - n! \\cdot x - n! \\cdot y &amp;= 0\n\\end{aligned}\n$$\n由上式联想到：\n$$\n\\large\n(a - x) (b - x) \\to ab - ax - bx - X^2\n$$\n比较两式，发现缺少 $(n!)^2$ 项。加上 $(n!)^2$，得：\n$$\n\\large\n\\begin{aligned}\n(x - n!)(y - n!) = (n!)^2\n\\end{aligned}\n$$\n由于等式左边是乘积的形式，所以 $(x - n!)$ 和 $(y - n!)$ 必定是 $(n!)^2$ 的一对因子。\n将 $n$ 质因数分解：\n$$\n\\large\nn = \\prod_{i = 0}^{k} p_i^{\\alpha_{i}}\n$$\n对于 $n!$ 的因子个数 $sum_{1}$ 有：\n$$\nsum_{1} = \\prod_{i=0}^{k} (\\alpha_{i}+ 1)\n$$\n而 $(n!)^2$ 的因子个数 $sum_{2}$ 为：\n$$\nsum_{2} = \\prod_{i = 0}^{k} (\\alpha_{1} \\cdot 2 + 1)\n$$\n根据乘法原理，最后的答案为所有 $sum_{2}$ 的乘积。\n代码\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconstexpr int MOD = 1e9 + 7;\n\ninline vector&lt;int&gt; GetPrimes(int Limit) &#123;\n  vector&lt;int&gt; primes;\n  vector&lt;bool&gt; mark(Limit + 1);\n  \n  for (int i = 2; i &lt;= Limit; i ++) &#123;\n    if (mark[i] == false) &#123;\n      primes.emplace_back(i);\n    &#125;\n    \n    for (int j = 0; i * primes[j] &lt;= Limit; j ++) &#123;\n      mark[i * primes[j]] = true;\n      if (i % primes[j] == 0) &#123;\n        break;\n      &#125;\n    &#125;\n  &#125;\n  \n  return primes;\n&#125;\n\nint main() &#123;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  \n  int n;\n  cin &gt;&gt; n;\n  \n  vector&lt;int&gt; primes = GetPrimes(n);\n  // * 注意由于是连乘，所以 answer 的初始值为 1.\n  long long answer = 1;\n  \n  for (auto&amp;&amp; p : primes) &#123;\n    int alpha = 0, number = n;\n    \n    while (number) &#123;\n      alpha += number / p;\n      number /= p;\n    &#125;\n    \n    answer = (answer * (alpha + alpha + 1) % MOD) % MOD;\n  &#125;\n  \n  cout &lt;&lt; answer % MOD &lt;&lt; &#x27;\\n&#x27;;\n  \n  return 0;\n&#125;","categories":["Solution"],"tags":["Math","Luogu"]},{"title":"SPOJ GSS3","url":"/posts/63ce06a9/","content":"洛谷   VJudge\n算法\n\n线段树\n\n\n思路\n题目要求维护支持单点修改和查询区间最大子段和的数据结构。\n考虑使用线段树维护。对于区间 $[l_1,r_1], [l_2,r_2]$ ，合并后的最大子段和有一下三种情况：\n\n区间 $[l_1,r_1]$ 的最大子段和。\n区间 $[l_2,r_2]$ 的最大子段和。\n跨过中间，区间 $[l_1,r_1]$ 的右边部分和区间 $[l_2,r_2]$ 的左边部分合并后的最大子段和。\n\n所以线段树要维护的信息有四个：\n\n区间和\n区间最大子段和\n区间左侧最大子段和。\n区间右侧最大子段和。\n\n对以上四个信息分别维护即可。\n代码\n#include &lt;bits/stdc++.h&gt;\n\nconstexpr int N = 5e4 + 5;\nint n, m, op, l, r, arr[N];\n\nclass SegmentTree &#123;\n protected:\n  class Values &#123;\n   public:\n    int sum = 0, max = 0, left_max = 0, right_max = 0;\n\n    Values() = default;\n\n    Values(int x) &#123;\n      sum = x;\n      max = x;\n      left_max = x;\n      right_max = x;\n    &#125;\n  &#125;;\n\n  class Node &#123;\n   public:\n    int l, r;\n    Values val;\n  &#125;;\n\n  Node tr[N &lt;&lt; 2];\n\n public:\n  Values merge(Values a, Values b) &#123;\n    Values retval;\n\n    retval.sum = a.sum + b.sum;\n    retval.max = std::max(&#123;a.max, b.max, a.right_max + b.left_max&#125;);\n    retval.left_max = std::max(a.left_max, a.sum + b.left_max);\n    retval.right_max = std::max(b.right_max, b.sum + a.right_max);\n\n    return retval;\n  &#125;\n\n  void push_up(int k) &#123;\n    Values lc = tr[k &lt;&lt; 1].val, rc = tr[k &lt;&lt; 1 | 1].val;\n    tr[k].val = merge(lc, rc);\n  &#125;\n\n  void build_tree(int k, int l, int r) &#123;\n    tr[k].l = l, tr[k].r = r;\n    tr[k].val = Values(0);\n\n    if (tr[k].l == tr[k].r) &#123;\n      tr[k].val = Values(arr[l]);\n      return void();\n    &#125;\n\n    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n\n    build_tree(lc, l, mid);\n    build_tree(rc, mid + 1, r);\n\n    push_up(k);\n  &#125;\n\n  void modify(int k, int pos, int value) &#123;\n    if (tr[k].l == tr[k].r &amp;&amp; tr[k].r == pos) &#123;\n      tr[k].val = Values(value);\n      return void();\n    &#125;\n\n    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n\n    if (pos &lt;= mid) &#123;\n      modify(lc, pos, value);\n    &#125; else &#123;\n      modify(rc, pos, value);\n    &#125;\n\n    push_up(k);\n  &#125;\n\n  Values query(int k, int l, int r) &#123;\n    if (tr[k].l &gt;= l &amp;&amp; tr[k].r &lt;= r) &#123;\n      return tr[k].val;\n    &#125;\n\n    int mid = (tr[k].l + tr[k].r) &gt;&gt; 1;\n    int lc = k &lt;&lt; 1, rc = k &lt;&lt; 1 | 1;\n\n    if (r &lt;= mid) &#123;\n      return query(lc, l, r);\n    &#125; else if (l &gt; mid) &#123;\n      return query(rc, l, r);\n    &#125; else &#123;\n      return merge(query(lc, l, mid), query(rc, mid + 1, r));\n    &#125;\n  &#125;\n&#125; segment_tree;\n\nint main() &#123;\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::cout.tie(nullptr);\n\n  std::cin &gt;&gt; n;\n\n  for (int i = 1; i &lt;= n; i++) &#123;\n    std::cin &gt;&gt; arr[i];\n  &#125;\n\n  segment_tree.build_tree(1, 1, n);\n  \n  std::cin &gt;&gt; m;\n\n  while (m--) &#123;\n    std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n    \n    if (op == 0) &#123;\n      segment_tree.modify(1, l, r);\n    &#125; else if (op == 1) &#123;\n      std::cout &lt;&lt; segment_tree.query(1, l, r).max &lt;&lt; &#x27;\\n&#x27;;\n    &#125;\n  &#125;\n\n  return 0;\n&#125;","categories":["Solution"],"tags":["SegmentTree","SPOJ"]}]